#include "SBAnalysisManager.hh"
#include "SBDetectorConstruction.hh"
#include "G4UnitsTable.hh"
#include "G4Event.hh"
#include "G4EventManager.hh"

#include <TH1.h>
#include "TF1.h"
#include <TH2.h>

#include <iostream>
#include <fstream>

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

SBAnalysisManager* SBAnalysisManager::fManager = 0;

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

SBAnalysisManager* SBAnalysisManager::getInstance()
{
 if(!fManager) { fManager = new SBAnalysisManager() ;  }
 return fManager;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

SBAnalysisManager::SBAnalysisManager()
{
//============================================================  
  EnuMAX=1.5;// SPL standard
  ENbins=75;//SPL standard
  EnuMIN=0;

  //EnuMAX=1.5;// SPL prova
  //ENbins=20;//SPL prova

  //EnuMAX=10.;// PS2
  //ENbins=50;//PS2
  //EnuMAX=50.;// CNGS
  //ENbins=50;// CNGS

  //EnuMAX=50.;// NOVA
  //ENbins=1000;// NOVA
  //=============================================================

   rMAX=250;

   xMAX=2.5;
   yMAX=2.5;

   zMIN=-30.;//tunnel make this depend on tunnel parameters!!
   zMAX=30.;//tunnel
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

SBAnalysisManager::~SBAnalysisManager()
{
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::InitDataStructure()
{
  h_ETarg = new TH1F("h_ETarg","h_ETarg",100,0.,2000.) ;
  h_LTarg = new TH1F("h_LTarg","h_LTarg",100,0.,50.)   ;
  
  //muons
  h_p_muplus_PI = new TH1F("h_p_muplus_PI","h_p_muplus_PI",ENbins,EnuMIN/CLHEP::GeV,0.8);
  h_p_muminus_PI = new TH1F("h_p_muminus_PI","h_p_muminus_PI",ENbins,EnuMIN/CLHEP::GeV,0.8);
  h_p_muplus_K = new TH1F("h_p_muplus_K","h_p_muplus_K",ENbins,EnuMIN/CLHEP::GeV,0.8);
  h_p_muminus_K = new TH1F("h_p_muminus_K","h_p_muminus_K",ENbins,EnuMIN/CLHEP::GeV,0.8);

  // neutrino fluxes

  // unweighted
  pions_numu_du_pi_NW = new TH1F("pions_numu_du_pi_NW","pions_numu_du_pi_NW",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  pions_anumu_du_pi_NW = new TH1F("pions_anumu_du_pi_NW","pions_anumu_du_pi_NW",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_numu_du_ka_NW = new TH1F("kaons_numu_du_ka_NW","kaons_numu_du_ka_NW",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anumu_du_ka_NW = new TH1F("kaons_anumu_du_ka_NW","kaons_anumu_du_ka_NW",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
 // weighted
  kaons_numu_du_ka = new TH1F("kaons_numu_du_ka","kaons_numu_du_ka",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anumu_du_ka = new TH1F("kaons_anumu_du_ka","kaons_anumu_du_ka",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  pions_numu_du_pi_IDEAL = new TH1F("pions_numu_du_pi_IDEAL","pions_numu_du_pi_IDEAL",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  pions_numu_du_pi = new TH1F("pions_numu_du_pi","pions_numu_du_pi",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  pions_anumu_du_pi = new TH1F("pions_anumu_du_pi","pions_anumu_du_pi",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  kaons_numu_du_pi = new TH1F("kaons_numu_du_pi","kaons_numu_du_pi",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anumu_du_pi = new TH1F("kaons_anumu_du_pi","kaons_anumu_du_pi",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  kzeros_numu_du_pi = new TH1F("kzeros_numu_du_pi","kzeros_numu_du_pi",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_anumu_du_pi = new TH1F("kzeros_anumu_du_pi","kzeros_anumu_du_pi",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  
  kaons_numu_du_3 = new TH1F("kaons_numu_du_3","kaons_numu_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anumu_du_3 = new TH1F("kaons_anumu_du_3","kaons_anumu_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_nue_du_3 = new TH1F("kaons_nue_du_3","kaons_nue_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anue_du_3 = new TH1F("kaons_anue_du_3","kaons_anue_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  kzeros_numu_du_3 = new TH1F("kzeros_numu_du_3","kzeros_numu_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_anumu_du_3 = new TH1F("kzeros_anumu_du_3","kzeros_anumu_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_nue_du_3 = new TH1F("kzeros_nue_du_3","kzeros_nue_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_anue_du_3 = new TH1F("kzeros_anue_du_3","kzeros_anue_du_3",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  pions_numu_du_mu = new TH1F("pions_numu_du_mu","pions_numu_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  pions_anumu_du_mu = new TH1F("pions_anumu_du_mu","pions_anumu_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  pions_nue_du_mu = new TH1F("pions_nue_du_mu","pions_nue_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  pions_anue_du_mu = new TH1F("pions_anue_du_mu","pions_anue_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  kaons_nue_du_mu = new TH1F("kaons_nue_du_mu","kaons_nue_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anumu_du_mu = new TH1F("kaons_anumu_du_mu","kaons_anumu_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_anue_du_mu = new TH1F("kaons_anue_du_mu","kaons_anue_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kaons_numu_du_mu = new TH1F("kaons_numu_du_mu","kaons_numu_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  kzeros_nue_du_mu = new TH1F("kzeros_nue_du_mu","kzeros_nue_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_anumu_du_mu = new TH1F("kzeros_anumu_du_mu","kzeros_anumu_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_anue_du_mu = new TH1F("kzeros_anue_du_mu","kzeros_anue_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  kzeros_numu_du_mu = new TH1F("kzeros_numu_du_mu","kzeros_numu_du_mu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  // sum
  h_numu = new TH1F("h_numu","h_numu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  h_anumu = new TH1F("h_anumu","h_anumu",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  h_nue = new TH1F("h_nue","h_nue",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);
  h_anue = new TH1F("h_anue","h_anue",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  // geometrical distribution of decay in flight of pions and kaons

  h_piminus_DIF_r = new TH1F("h_piminus_DIF_r","h_piminus_DIF_r",208,0.,rMAX);
  h_piminus_DIF_z = new TH1F("h_piminus_DIF_z","h_piminus_DIF_z",500,zMIN,zMAX);
  h_piminus_DIF_xy = new TH2F("h_piminus_DIF_xy","h_piminus_DIF_xy",100,-xMAX,xMAX,100,-yMAX,yMAX);
  h_piminus_DIF_xy->Draw("CONT0Z");
  h_piminus_DIF_zr = new TH2F("h_piminus_DIF_zr","h_piminus_DIF_zr",100,zMIN,zMAX,208,0.,rMAX);
  h_piminus_DIF_thp = new TH2F("h_piminus_DIF_thp","h_piminus_DIF_thp",100,0,1,100,0,1.5);
  h_piminus_DIF_thp_EnuW = new TH2F("h_piminus_DIF_thp_EnuW","h_piminus_DIF_thp_EnuW",100,0,1,100,0,1.5);
  h_piminus_DIF_thpinu = new TH2F("h_piminus_DIF_thpinu","h_piminus_DIF_thpinu",100,0,3.141592,100,0,3.141592);
  h_piminus_DIF_Ethnu = new TH2F("h_piminus_DIF_Ethnu","h_piminus_DIF_Ethnu",100,0,3.141592,100,0,1);
  h_piminus_DIF_EnuForw = new TH1F("h_piminus_DIF_EnuForw","h_piminus_DIF_EnuForw",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  h_Kminus_DIF_r =  new TH1F("h_Kminus_DIF_r","h_Kminus_DIF_r",208,0.,rMAX);
  h_Kminus_DIF_z =  new TH1F("h_Kminus_DIF_z","h_Kminus_DIF_z",500,zMIN,zMAX);
  h_Kminus_DIF_xy =  new TH2F("h_Kminus_DIF_xy","h_Kminus_DIF_xy",100,-xMAX,xMAX,100,-yMAX,yMAX);
  h_Kminus_DIF_zr =  new TH2F("h_Kminus_DIF_zr","h_Kminus_DIF_zr",100,zMIN,zMAX,208,0.,rMAX);
  h_Kminus_DIF_thp =  new TH2F("h_Kminus_DIF_thp","h_Kminus_DIF_thp",100,0,1,100,0,1.5);
  h_Kminus_DIF_thp_EnuW =  new TH2F("h_Kminus_DIF_thp_EnuW","h_Kminus_DIF_thp_EnuW",100,0,1,100,0,1.5);
  h_Kminus_DIF_thpinu =  new TH2F("h_Kminus_DIF_thpinu","h_Kminus_DIF_thpinu",100,0,3.141592,100,0,3.141592);
  h_Kminus_DIF_Ethnu =  new TH2F("h_Kminus_DIF_Ethnu","h_Kminus_DIF_Ethnu",100,0,3.141592,100,0,1);
  h_Kminus_DIF_EnuForw = new TH1F("h_Kminus_DIF_EnuForw","h_Kminus_DIF_EnuForw",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  h_piplus_DIF_r =  new TH1F("h_piplus_DIF_r","h_piplus_DIF_r",208,0.,rMAX);
  h_piplus_DIF_z =  new TH1F("h_piplus_DIF_z","h_piplus_DIF_z",500,zMIN,zMAX);
  h_piplus_DIF_xy =  new TH2F("h_piplus_DIF_xy","h_piplus_DIF_xy",100,-xMAX,xMAX,100,-yMAX,yMAX);
  h_piplus_DIF_zr =  new TH2F("h_piplus_DIF_zr","h_piplus_DIF_zr",100,zMIN,zMAX,208,0.,rMAX);
  h_piplus_DIF_thp =  new TH2F("h_piplus_DIF_thp","h_piplus_DIF_thp",100,0,1,100,0,1.5);
  h_piplus_DIF_thp_EnuW =  new TH2F("h_piplus_DIF_thp_EnuW","h_piplus_DIF_thp_EnuW",100,0,1,100,0,1.5);
  h_piplus_DIF_thpinu =  new TH2F("h_piplus_DIF_thpinu","h_piplus_DIF_thpinu",100,0,3.141592,100,0,3.141592);
  h_piplus_DIF_Ethnu =  new TH2F("h_piplus_DIF_Ethnu","h_piplus_DIF_Ethnu",100,0,3.141592,100,0,1);
  h_piplus_DIF_EnuForw = new TH1F("h_piplus_DIF_EnuForw","h_piplus_DIF_EnuForw",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

  h_Kplus_DIF_r =  new TH1F("h_Kplus_DIF_r","h_Kplus_DIF_r",208,0.,rMAX);
  h_Kplus_DIF_z =  new TH1F("h_Kplus_DIF_z","h_Kplus_DIF_z",500,zMIN,zMAX);
  h_Kplus_DIF_xy =  new TH2F("h_Kplus_DIF_xy","h_Kplus_DIF_xy",100,-xMAX,xMAX,100,-yMAX,yMAX);
  h_Kplus_DIF_zr =  new TH2F("h_Kplus_DIF_zr","h_Kplus_DIF_zr",100,zMIN,zMAX,208,0.,rMAX);
  h_Kplus_DIF_thp =  new TH2F("h_Kplus_DIF_thp","h_Kplus_DIF_thp",100,0,1,100,0,1.5);
  h_Kplus_DIF_thp_EnuW =  new TH2F("h_Kplus_DIF_thp_EnuW","h_Kplus_DIF_thp_EnuW",100,0,1,100,0,1.5);
  h_Kplus_DIF_thpinu =  new TH2F("h_Kplus_DIF_thpinu","h_Kplus_DIF_thpinu",100,0,3.141592,100,0,3.141592);
  h_Kplus_DIF_Ethnu =  new TH2F("h_Kplus_DIF_Ethnu","h_Kplus_DIF_Ethnu",100,0,3.141592,100,0,1);
  h_Kplus_DIF_EnuForw = new TH1F("h_Kplus_DIF_EnuForw","h_Kplus_DIF_EnuForw",ENbins,EnuMIN/CLHEP::GeV,EnuMAX);

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillHisto(Double_t EnerTarg, Double_t LengthTarg)
{
  h_ETarg->Fill(EnerTarg);
  h_LTarg->Fill(LengthTarg);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillHisto2(Double_t p_muplus_PI,
			           Double_t p_muminus_PI,
			           Double_t p_muplus_K,
			           Double_t p_muminus_K,
			           Double_t E_numu_PI,
			           Double_t E_anumu_PI,
			           Double_t E_numu_K,
			           Double_t E_anumu_K)
{
  h_p_muplus_PI->Fill(p_muplus_PI/CLHEP::GeV);
  h_p_muminus_PI->Fill(p_muminus_PI/CLHEP::GeV);
  h_p_muplus_K->Fill(p_muplus_K/CLHEP::GeV);
  h_p_muminus_K->Fill(p_muminus_K/CLHEP::GeV);

  pions_numu_du_pi_NW->Fill(E_numu_PI/CLHEP::GeV);
  pions_anumu_du_pi_NW->Fill(E_anumu_PI/CLHEP::GeV);
  kaons_numu_du_ka_NW->Fill(E_numu_K/CLHEP::GeV);
  kaons_anumu_du_ka_NW->Fill(E_anumu_K/CLHEP::GeV);

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillGeometryDecay(Double_t x,
			                  Double_t y,
			                  Double_t z,
			                  Double_t px,
			                  Double_t py,
			                  Double_t pz,
			                  Double_t pxnu,
			                  Double_t pynu,
			                  Double_t pznu,
			                  Int_t moth,
			                  Int_t q)
{
  Double_t r=sqrt(x*x+y*y);
  Double_t p=sqrt((px*px)+(py*py)+(pz*pz));
  Double_t enu=sqrt((pxnu*pxnu)+(pynu*pynu)+(pznu*pznu));
  Double_t th=0,thnu=0;
  //Double_t THFOR = 0.01;

  if(p)th=acos(pz/p);

  Double_t OffAxisAngle=3.141592*2.5/180.;
  Double_t OffAxisPhi=0;

  Double_t eOME[3]={0.,0.,0.};
  eOME[0]=sin(OffAxisAngle)*cos(OffAxisPhi);
  eOME[1]=sin(OffAxisAngle)*sin(OffAxisPhi);
  eOME[2]=cos(OffAxisAngle);

  if(enu)thnu=acos(((eOME[0]*pxnu)+(eOME[1]*pynu)+(eOME[2]*pznu))/enu);   //angle theta
  
  if(q==1){//plus

    if(moth==1){//pi
      if(r)h_piplus_DIF_r->Fill(r/CLHEP::cm);
      if(z)h_piplus_DIF_z->Fill(z/CLHEP::m);
      if(x&&y)h_piplus_DIF_xy->Fill(x/CLHEP::m,y/CLHEP::m);
      if(z&&r)h_piplus_DIF_zr->Fill(z/CLHEP::m,r/CLHEP::cm);                
      if(p&&th)h_piplus_DIF_thp->Fill(th,p/CLHEP::GeV);           
      if(p&&th)h_piplus_DIF_thp_EnuW->Fill(th,p/CLHEP::GeV,enu/CLHEP::GeV);
      if(th&&thnu)h_piplus_DIF_thpinu->Fill(th,thnu);
      if(enu&&thnu)h_piplus_DIF_Ethnu->Fill(thnu,enu/CLHEP::GeV);
      if(thnu)h_piplus_DIF_EnuForw->Fill(enu/CLHEP::GeV);   //if(thnu<THFOR)
    } else if (moth==2){//K
      if(r)h_Kplus_DIF_r->Fill(r/CLHEP::cm);
      if(z)h_Kplus_DIF_z->Fill(z/CLHEP::m);
      if(x&&y)h_Kplus_DIF_xy->Fill(x/CLHEP::m,y/CLHEP::m);
      if(z&&r)h_Kplus_DIF_zr->Fill(z/CLHEP::m,r/CLHEP::cm);
      if(p&&th)h_Kplus_DIF_thp->Fill(th,p/CLHEP::GeV);
      if(p&&th)h_Kplus_DIF_thp_EnuW->Fill(th,p/CLHEP::GeV,enu/CLHEP::GeV);
      if(th&&thnu)h_Kplus_DIF_thpinu->Fill(th,thnu);
      if(enu&&thnu)h_Kplus_DIF_Ethnu->Fill(thnu,enu/CLHEP::GeV);
      if(thnu)h_Kplus_DIF_EnuForw->Fill(enu/CLHEP::GeV);   //if(thnu<THFOR)
    }
    
  } else if (q==-1){
    
    if(moth==1){//pi
      if(r)h_piminus_DIF_r->Fill(r/CLHEP::cm);
      if(z)h_piminus_DIF_z->Fill(z/CLHEP::m);
      if(x&&y)h_piminus_DIF_xy->Fill(x/CLHEP::m,y/CLHEP::m);
      if(z&&r)h_piminus_DIF_zr->Fill(z/CLHEP::m,r/CLHEP::cm);
      if(p&&th)h_piminus_DIF_thp->Fill(th,p/CLHEP::GeV);
      if(p&&th)h_piminus_DIF_thp_EnuW->Fill(th,p/CLHEP::GeV,enu/CLHEP::GeV);
      if(th&&thnu)h_piminus_DIF_thpinu->Fill(th,thnu);
      if(enu&&thnu)h_piminus_DIF_Ethnu->Fill(thnu,enu/CLHEP::GeV);
      if(thnu)h_piminus_DIF_EnuForw->Fill(enu/CLHEP::GeV);  //if(thnu<THFOR)
    } else if (moth==2){//K
      if(r)h_Kminus_DIF_r->Fill(r/CLHEP::cm);
      if(z)h_Kminus_DIF_z->Fill(z/CLHEP::m);
      if(x&&y)h_Kminus_DIF_xy->Fill(x/CLHEP::m,y/CLHEP::m);
      if(z&&r)h_Kminus_DIF_zr->Fill(z/CLHEP::m,r/CLHEP::cm);
      if(p&&th)h_Kminus_DIF_thp->Fill(th,p/CLHEP::GeV);
      if(p&&th)h_Kminus_DIF_thp_EnuW->Fill(th,p/CLHEP::GeV,enu/CLHEP::GeV);
      if(th&&thnu)h_Kminus_DIF_thpinu->Fill(th,thnu);
      if(enu&&thnu)h_Kminus_DIF_Ethnu->Fill(thnu,enu/CLHEP::GeV);
      if(thnu)h_Kminus_DIF_EnuForw->Fill(enu/CLHEP::GeV);  //if(thnu<THFOR)
    }
    
  }

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillProba2(Int_t q,
                                   G4String partyp,
                                   Int_t parfl,
                                   Double_t enuLAB,
                                   Double_t weight,
                                   Double_t weightIDEAL)
{

    if(partyp=="kaon"){
      if(parfl==0){
	if(q==(+1))kaons_numu_du_ka->Fill(enuLAB/CLHEP::GeV,weight);
	if(q==(-1))kaons_anumu_du_ka->Fill(enuLAB/CLHEP::GeV,weight);
      }
    }

    if(partyp=="pion"){
      if(parfl==0){
	if(q==(+1))pions_numu_du_pi->Fill(enuLAB/CLHEP::GeV,weight);
	if(q==(+1))pions_numu_du_pi_IDEAL->Fill(enuLAB/CLHEP::GeV,weightIDEAL);
	if(q==(-1))pions_anumu_du_pi->Fill(enuLAB/CLHEP::GeV,weight);	
      }else if(parfl==1){
	if(q==(+1))kaons_numu_du_pi->Fill(enuLAB/CLHEP::GeV,weight);
	if(q==(-1))kaons_anumu_du_pi->Fill(enuLAB/CLHEP::GeV,weight);
      }else if(parfl==2){
	if(q==(+1))kzeros_numu_du_pi->Fill(enuLAB/CLHEP::GeV,weight);
	if(q==(-1))kzeros_anumu_du_pi->Fill(enuLAB/CLHEP::GeV,weight);
      }    
    }

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillProba3K(Int_t decflag,
                                    Double_t e_nu,
                                    Double_t weight)
{

    if(decflag==7)kaons_nue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==8)kaons_anue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==9)kaons_numu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==10)kaons_anumu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    
    if(decflag==13)kzeros_nue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==14)kzeros_anue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==15)kzeros_numu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==16)kzeros_anumu_du_3->Fill(e_nu/CLHEP::GeV,weight);


}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
void SBAnalysisManager::FillprobaMu(Int_t ipart,
                                    Int_t parflag,
                                    Double_t e_nu,
                                    Double_t weight,
                                    Double_t weightnue)
{
      if(ipart==1){//mu+
	if(parflag==1){
	  pions_anumu_du_mu->Fill(e_nu/CLHEP::GeV,weight);
	  pions_nue_du_mu->Fill(e_nu/CLHEP::GeV,weightnue);
	} else if(parflag==2) {
	  kaons_anumu_du_mu->Fill(e_nu/CLHEP::GeV,weight);
	  kaons_nue_du_mu->Fill(e_nu/CLHEP::GeV,weightnue);
	} else if(parflag==3) {
	  kzeros_anumu_du_mu->Fill(e_nu/CLHEP::GeV,weight);
	  kzeros_nue_du_mu->Fill(e_nu/CLHEP::GeV,weightnue);
	}
	
      } else if (ipart==-1){//mu-
	if(parflag==1){
	  pions_numu_du_mu->Fill(e_nu/CLHEP::GeV,weight);
	  pions_anue_du_mu->Fill(e_nu/CLHEP::GeV,weightnue);
	} else if(parflag==2) {
	  kaons_numu_du_mu->Fill(e_nu/CLHEP::GeV,weight);
	  kaons_anue_du_mu->Fill(e_nu/CLHEP::GeV,weightnue);
	} else if(parflag==3) {
	  kzeros_numu_du_mu->Fill(e_nu/CLHEP::GeV,weight);
	  kzeros_anue_du_mu->Fill(e_nu/CLHEP::GeV,weightnue);
	}
      }

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillSumFluxesFlavours()
{

  h_numu->Add(pions_numu_du_pi);
  h_numu->Add(pions_numu_du_mu);

  h_numu->Add(kaons_numu_du_ka);
  h_numu->Add(kaons_numu_du_pi);
  h_numu->Add(kaons_numu_du_mu);
  h_numu->Add(kaons_numu_du_3);

  h_numu->Add(kzeros_numu_du_pi);
  h_numu->Add(kzeros_numu_du_mu);
  h_numu->Add(kzeros_numu_du_3);

  //----//

  h_anumu->Add(pions_anumu_du_pi);
  h_anumu->Add(pions_anumu_du_mu);

  h_anumu->Add(kaons_anumu_du_ka);
  h_anumu->Add(kaons_anumu_du_pi);
  h_anumu->Add(kaons_anumu_du_mu);
  h_anumu->Add(kaons_anumu_du_3);

  h_anumu->Add(kzeros_anumu_du_pi);
  h_anumu->Add(kzeros_anumu_du_mu);
  h_anumu->Add(kzeros_anumu_du_3);

  //----//

  h_nue->Add(pions_nue_du_mu);
  h_nue->Add(kaons_nue_du_mu);
  h_nue->Add(kaons_nue_du_3);
  h_nue->Add(kzeros_nue_du_mu);
  h_nue->Add(kzeros_nue_du_3);

  //----//

  h_anue->Add(pions_anue_du_mu);
  h_anue->Add(kaons_anue_du_mu);
  h_anue->Add(kaons_anue_du_3);
  h_anue->Add(kzeros_anue_du_mu);
  h_anue->Add(kzeros_anue_du_3);

}


//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::PrepareGLoBESFlux(G4String fname="nufluxes_GLOBESformat.txt",G4double L=130.)
{
  double scal = pow(100./L,2);
  //double bwscale = 0.02/h_nue->GetBinWidth(1);// norm factor in GLOBES valid for 20MeV bins !        /////////////
  //scal*=bwscale;
  
  ofstream fout(fname);
  double nutau=0,antinutau=0;
  for(int i=1;i<h_numu->GetNbinsX();i++){
    fout 
      << h_numu->GetBinCenter(i)+0.5*h_nue->GetBinWidth(i)<< " " 
      << scal*h_nue->GetBinContent(i) << " " 
      << scal*h_numu->GetBinContent(i) << " " 
      << scal*nutau << " "
      << scal*h_anue->GetBinContent(i) << " " 
      << scal*h_anumu->GetBinContent(i) << " " 
      << scal*antinutau
      << G4endl;
    G4cout 
      << h_numu->GetBinCenter(i)+0.5*h_nue->GetBinWidth(i)<< " " 
      << scal*h_nue->GetBinContent(i) << " " 
      << scal*h_numu->GetBinContent(i) << " " 
      << scal*nutau << " "
      << scal*h_anue->GetBinContent(i) << " " 
      << scal*h_anumu->GetBinContent(i) << " " 
      << scal*antinutau
      << G4endl;
  }

  int nleft = 502-ENbins;
  for(int i=0;i<nleft;i++){
    fout 
      << EnuMAX/CLHEP::GeV+h_nue->GetBinWidth(i)*i << " " 
      << 0. << " " 
      << 0. << " " 
      << 0. << " "
      << 0. << " " 
      << 0. << " " 
      << 0.
      << G4endl;
  }
  fout.close();
  //system(Form("cat completamento.dat >> %s",fname));
  G4cout << fname << " created. Scaled by " << scal <<" (100/130)^2. "<< L <<" Km "<< G4endl; 

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::FillFinalOps(Double_t ProcEvtsScale,Double_t K_REP)
{
  h_piminus_DIF_r->Scale(ProcEvtsScale);
  h_piminus_DIF_z->Scale(ProcEvtsScale);
  h_piminus_DIF_xy->Scale(ProcEvtsScale);
  h_piminus_DIF_zr->Scale(ProcEvtsScale);
  
  h_Kminus_DIF_r->Scale(ProcEvtsScale);
  h_Kminus_DIF_z->Scale(ProcEvtsScale);
  h_Kminus_DIF_xy->Scale(ProcEvtsScale);
  h_Kminus_DIF_zr->Scale(ProcEvtsScale);
  
  h_piplus_DIF_r->Scale(ProcEvtsScale);
  h_piplus_DIF_z->Scale(ProcEvtsScale);
  h_piplus_DIF_xy->Scale(ProcEvtsScale);
  h_piplus_DIF_zr->Scale(ProcEvtsScale);
  
  h_Kplus_DIF_r->Scale(ProcEvtsScale);
  h_Kplus_DIF_z->Scale(ProcEvtsScale);
  h_Kplus_DIF_xy->Scale(ProcEvtsScale);
  h_Kplus_DIF_zr->Scale(ProcEvtsScale);
  
  //neutrino.........weight
  kaons_numu_du_ka->Scale(ProcEvtsScale/K_REP);
  kaons_anumu_du_ka->Scale(ProcEvtsScale/K_REP);

  pions_numu_du_pi_IDEAL->Scale(ProcEvtsScale);

  pions_numu_du_pi->Scale(ProcEvtsScale);
  pions_anumu_du_pi->Scale(ProcEvtsScale);

  kaons_numu_du_pi->Scale(ProcEvtsScale/K_REP);
  kaons_anumu_du_pi->Scale(ProcEvtsScale/K_REP);

  kzeros_numu_du_pi->Scale(ProcEvtsScale/K_REP);
  kzeros_anumu_du_pi->Scale(ProcEvtsScale/K_REP);

  kaons_numu_du_3->Scale(ProcEvtsScale/K_REP);
  kaons_anumu_du_3->Scale(ProcEvtsScale/K_REP);
  kaons_nue_du_3->Scale(ProcEvtsScale/K_REP);
  kaons_anue_du_3->Scale(ProcEvtsScale/K_REP);

  kzeros_numu_du_3->Scale(ProcEvtsScale/K_REP);
  kzeros_anumu_du_3->Scale(ProcEvtsScale/K_REP);
  kzeros_nue_du_3->Scale(ProcEvtsScale/K_REP);
  kzeros_anue_du_3->Scale(ProcEvtsScale/K_REP);

  pions_numu_du_mu->Scale(ProcEvtsScale);
  pions_anumu_du_mu->Scale(ProcEvtsScale);
  pions_nue_du_mu->Scale(ProcEvtsScale);
  pions_anue_du_mu->Scale(ProcEvtsScale);

  kaons_nue_du_mu->Scale(ProcEvtsScale/K_REP);
  kaons_anumu_du_mu->Scale(ProcEvtsScale/K_REP);
  kaons_anue_du_mu->Scale(ProcEvtsScale/K_REP);
  kaons_numu_du_mu->Scale(ProcEvtsScale/K_REP);

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::BeginOfRun()
{
 SBAnalysisManager();
 InitDataStructure();
 
 /* 
 ROOTFileName = "SB.root";
 //ROOTDirectory = "/scratch9/fkoll/";
 //ROOTFileName = ROOTDirectory+ROOTFileName;
 G4cout << "Opening the output file : " << ROOTFileName << G4endl ;
 
 rootFile = new TFile(ROOTFileName,"RECREATE");
 if (!rootFile) { rootFile = new TFile("SB.root") ; } ;
*/

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::EndOfRun()
{

  h_ETarg->Write();
  h_LTarg->Write();
  //
  h_p_muplus_PI->Write();
  h_p_muminus_PI->Write();
  h_p_muplus_K->Write();
  h_p_muminus_K->Write();
  //neutrino........unweight
  pions_numu_du_pi_NW->Write();
  pions_anumu_du_pi_NW->Write();
  kaons_numu_du_ka_NW->Write();
  kaons_anumu_du_ka_NW->Write();
  //neutrino........weight
  kaons_numu_du_ka->Write();
  kaons_anumu_du_ka->Write();

  pions_numu_du_pi_IDEAL->Write();

  pions_numu_du_pi->Write();
  pions_anumu_du_pi->Write();

  kaons_numu_du_pi->Write();
  kaons_anumu_du_pi->Write();

  kzeros_numu_du_pi->Write();
  kzeros_anumu_du_pi->Write();

  kaons_numu_du_3->Write();
  kaons_anumu_du_3->Write();
  kaons_nue_du_3->Write();
  kaons_anue_du_3->Write();

  kzeros_numu_du_3->Write();
  kzeros_anumu_du_3->Write();
  kzeros_nue_du_3->Write();
  kzeros_anue_du_3->Write(); 

  pions_numu_du_mu->Write();
  pions_anumu_du_mu->Write();
  pions_nue_du_mu->Write();
  pions_anue_du_mu->Write();

  kaons_nue_du_mu->Write();
  kaons_anumu_du_mu->Write();
  kaons_anue_du_mu->Write();
  kaons_numu_du_mu->Write();

  kzeros_nue_du_mu->Write();
  kzeros_anumu_du_mu->Write();
  kzeros_anue_du_mu->Write();
  kzeros_numu_du_mu->Write();
  
  h_numu->Write();
  h_anumu->Write();
  h_nue->Write();
  h_anue->Write();

  //
  h_piminus_DIF_r->Write();
  h_piminus_DIF_z->Write();
  h_piminus_DIF_xy->Write();
  h_piminus_DIF_zr->Write();
  h_piminus_DIF_thp->Write();
  h_piminus_DIF_thp_EnuW->Write();
  h_piminus_DIF_thpinu->Write();
  h_piminus_DIF_Ethnu->Write();
  h_piminus_DIF_EnuForw->Write();

  h_Kminus_DIF_r->Write();
  h_Kminus_DIF_z->Write();
  h_Kminus_DIF_xy->Write();
  h_Kminus_DIF_zr->Write();
  h_Kminus_DIF_thp->Write();
  h_Kminus_DIF_thp_EnuW->Write();
  h_Kminus_DIF_thpinu->Write();
  h_Kminus_DIF_Ethnu->Write();
  h_Kminus_DIF_EnuForw->Write();

  h_piplus_DIF_r->Write();
  h_piplus_DIF_z->Write();
  h_piplus_DIF_xy->Write();
  h_piplus_DIF_zr->Write();
  h_piplus_DIF_thp->Write();
  h_piplus_DIF_thp_EnuW->Write();
  h_piplus_DIF_thpinu->Write();
  h_piplus_DIF_Ethnu->Write();
  h_piplus_DIF_EnuForw->Write();

  h_Kplus_DIF_r->Write();
  h_Kplus_DIF_z->Write();
  h_Kplus_DIF_xy->Write();
  h_Kplus_DIF_zr->Write();
  h_Kplus_DIF_thp->Write();
  h_Kplus_DIF_thp_EnuW->Write();
  h_Kplus_DIF_thpinu->Write();
  h_Kplus_DIF_Ethnu->Write();
  h_Kplus_DIF_EnuForw->Write();
  //







/*
  h_ETarg->Delete();
  h_LTarg->Delete();
  
  rootFile->Close();
  rootFile->Delete();

  G4cout << "Closing root file" << G4endl;
*/
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::BeginOfEvent()
{
  //G4cout << " Event ID = " << evtID << G4endl;
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBAnalysisManager::EndOfEvent()
{
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo
//
// SBDetectorconstructionNew ->  Detector construction.    
//
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo


#include "G4NistManager.hh"
#include "G4PhysicalConstants.hh"
#include "G4SystemOfUnits.hh"

#include "SBDetectorConstruction.hh"
#include "SBDetectorConstructionMessenger.hh"             /////////////////////////////
//#include "SBFieldSetup.hh"
#include "QGSP_BERT.hh"
#include "G4Material.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4Polycone.hh"
#include "G4LogicalVolume.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"

#include "G4GeometryManager.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4SolidStore.hh"
#include "G4SubtractionSolid.hh"  

#include "G4UserLimits.hh"

#include "G4VisAttributes.hh"
#include "G4Colour.hh"
#include "G4Transform3D.hh"
#include "G4RotationMatrix.hh"
#include "G4PVPlacement.hh"
#include "G4PVParameterised.hh"

#include "G4PropagatorInField.hh"
#include "G4ClassicalRK4.hh"
#include "SBField.hh"


#include "G4FieldManager.hh"
#include "G4TransportationManager.hh"
#include "G4Mag_UsualEqRhs.hh"
#include "G4MagIntegratorStepper.hh"
#include "G4ChordFinder.hh"

#include "G4Mag_UsualEqRhs.hh"

#include "TMath.h"

#include "Riostream.h"
#include "Rtypes.h"
#include "TROOT.h"
#include "TLine.h"
#include "TVirtualPad.h"
#include "TClass.h"
#include "TVirtualX.h"

#include "G4RunManager.hh"

//to make it a ROOT class
//ClassImp(SBDetectorConstruction)

void SBDetectorConstruction::SetOffAxisAngle(G4double val){OffAxisAngle=val;}
void SBDetectorConstruction::SetOffAxisPhi(G4double val){OffAxisPhi=val;}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

SBDetectorConstruction::SBDetectorConstruction():TargetMaterial(0),defaultMaterial(0),solidWorld(0),logicWorld(0),physiWorld(0)
{
// default parameter values     (target +tunnel)
  TargetThickness=780.*mm;
  TargetDiameter=11*mm;
  TargetHalfThickness=(TargetThickness*0.5); 

  TunnelLength=40000.*mm;
  HalfTunnelLength=(TunnelLength*0.5);
  TunnelRadius=2000.*mm;

  current1 = -300000.*ampere;
  current2 = -300000.*ampere;

  // Default parameter for the horn position.
  // ----------------------------------------
  Horn_xpos = 1000.0*mm;
  Horn_ypos = 1000.0*mm;
  Horn_zpos = -0.5*L_Hall+2.*HalfMotherVoluLength-HalfHornLength;
  Horn_rpos = sqrt((Horn_xpos*Horn_xpos)+(Horn_ypos*Horn_ypos));
  
  // Materials
  // ---------
  DefineMaterials();
  
  // create commands for interactive definition
  // ------------------------------------------
  detectorConstructionMessenger=new SBDetectorConstructionMessenger(this);
//fEmFieldSetup=new SBFieldSetup();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

SBDetectorConstruction::~SBDetectorConstruction()
{
  delete detectorConstructionMessenger;
  //if (fEmFieldSetup) delete fEmFieldSetup ;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

G4VPhysicalVolume* SBDetectorConstruction::Construct()
{
  return ConstructSystem();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

G4VPhysicalVolume* SBDetectorConstruction::ConstructSystem()
{
  
  bool placeInnerConductor=true;
  bool placeBfield1=true;
  bool placeOuterConductor=true;
  bool placeBfield2=true;
  bool placeTarget=true;
  bool placeTunnel=true;
  
  placeInnerConductor=true;
  placeBfield1=true;
  placeOuterConductor=true;
  placeBfield2=true;
  placeTarget=true;
  placeTunnel=true;
  

// Clean old geometry, if any
  G4GeometryManager::GetInstance()->OpenGeometry();
  G4PhysicalVolumeStore::GetInstance()->Clean();
  G4LogicalVolumeStore::GetInstance()->Clean();
  G4SolidStore::GetInstance()->Clean();

  SetHornParameters();

//WorldVolume
  solidWorld=new G4Tubs("World",0.*cm,rO_Hall,L_Hall/2.,0.*deg,360.*deg);               
  logicWorld=new G4LogicalVolume(solidWorld,defaultMaterial,"World");
  physiWorld=new G4PVPlacement(0,G4ThreeVector(),logicWorld,"World",0,false,0);
  G4cout << physiWorld->GetName() <<" created."<<G4endl;

  DoInnerConductor(placeInnerConductor);
  DoOuterConductor(placeOuterConductor);
  DoMagField1(placeBfield1);
  DoMagField2(placeBfield2);
  DoTarget(placeTarget);
  DoTunnel(placeTunnel);

  SetVolumesVisibility();

 return physiWorld;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::UpdateGeometry()
{
  G4cout << "SBDetectorConstruction::UpdateGeometry "<< G4endl;  
  G4RunManager::GetRunManager()->DefineWorldVolume(ConstructSystem());
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::SetHornParameters()
{
 G4cout << "SBDetectorConstruction::SetHornParameters "<< G4endl; 
 
  // Double Skin (Water surround the horn and the double skin surround the water)
  //WaterThickness = 2*mm;
  //SkinThickness = 2*mm;

// Target
  TargetRadius = TargetDiameter/2.;

// variables for the Horn
 L1 = 589.0*mm;
 L2 = 468.0*mm;
 L3 = 603.0*mm;
 L4 = 475.0*mm;
 L5 = 10.8*mm;
 t1 = 3.0*mm;
 t2 = 3.0*mm;
 t3 = 3.0*mm;
 t4 = 10.0*mm;
  R = 12.0*mm;  
 r3 = 50.8*mm; 
 R4 = 272.0*mm;          
 R2 = 191.0*mm;  
 R3 = 359.0*mm;
 totL = t2+r3+L1+L2+L3+L4+L5+R4+t3;       //2474,6*mm
 OutCondHalfLength = totL*0.5;            //1237,3*mm 
 InCondHalfLength = (totL-t2-t3)*0.5;    //1234,3*mm
 
 Clearance = 3000.*mm;
 HalfHornLength = OutCondHalfLength;
 G4cout <<"HalfHornLength= "<<HalfHornLength<<" mm"<<G4endl;
 rO_Hall=4000.*mm;    
 
 HalfMotherVoluLength = HalfHornLength+Clearance/2.;
 G4cout <<"HalfMotherVoluLength= "<<HalfMotherVoluLength<<" mm"<<G4endl;

 L_Hall = TunnelLength+2.*HalfMotherVoluLength;
 G4cout <<"L_Hall= "<<L_Hall<<" mm"<<G4endl; 

/*
 Horn_xpos = 1000.0*mm;
 Horn_ypos = 1000.0*mm;
 Horn_zpos = -0.5*L_Hall+2.*HalfMotherVoluLength-HalfHornLength;
 G4cout << "================================================" << G4endl;
 G4cout <<"Horn_xpos= "<<Horn_xpos<<" mm"<<G4endl;
 G4cout <<"Horn_ypos= "<<Horn_ypos<<" mm"<<G4endl;
 G4cout <<"Horn_zpos= "<<Horn_zpos<<" mm"<<G4endl;
 G4cout << "================================================" << G4endl;
*/

 G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo
void SBDetectorConstruction::DefineMaterials()
{
  G4cout << "SBDetectorConstruction::DefineMaterials "<< G4endl;  
  G4String symbol;
  G4double a, z, density;
  G4int ncomponents, natoms;
  G4double fractionmass;
  
  G4Element* H  = new G4Element("Hydrogen",symbol="H" , z= 1., a= 1.01*g/mole);
  G4Element* C  = new G4Element("Carbon"  ,symbol="C" , z= 6., a= 12.01*g/mole);
  G4Element* N  = new G4Element("Nitrogen",symbol="N" , z= 7., a= 14.01*g/mole);
  G4Element* O  = new G4Element("Oxygen"  ,symbol="O" , z= 8., a= 16.00*g/mole);
  G4Element* Si = new G4Element("Silicon",symbol="Si" , z= 14., a= 28.09*g/mole);
  G4Element* Al = new G4Element("Aluminum",symbol="Al" , z= 13., a= 26.9815386*g/mole);
  G4Element* Be = new G4Element("Berillium",symbol="Be" , z= 4., a= 9.0121823*g/mole);

  G4Material* Aluminum=new G4Material("Aluminum",z=13.,a=26.98*g/mole,density=2.700*g/cm3);

  G4Material* myGraphite=new G4Material("myGraphite",z=6.,a=12.01*g/mole,density=1.85*g/cm3);
  //G4Material* myTantalum=new G4Material("myTantalum",z=73.,a=180.94788*g/mole,density=16.69*g/cm3);

  G4Material* H2O=new G4Material("Water", density= 1.000*g/cm3, ncomponents=2);
  H2O->AddElement(H,natoms=2);
  H2O->AddElement(O,natoms=1); 
  H2O->GetIonisation()->SetMeanExcitationEnergy(75.0*eV);
  
  G4Material* Sci=new G4Material("Scintillator", density= 1.032*g/cm3, ncomponents=2);
  Sci->AddElement(C,natoms=9);
  Sci->AddElement(H,natoms=10);
  
  G4Material* Myl=new G4Material("Mylar", density= 1.397*g/cm3, ncomponents=3);
  Myl->AddElement(C,natoms=10);
  Myl->AddElement(H,natoms=8);
  Myl->AddElement(O,natoms=4);
  
  G4Material* SiO2=new G4Material("quartz",density= 2.200*g/cm3, ncomponents=2);
  SiO2->AddElement(Si,natoms=1);
  SiO2->AddElement(O,natoms=2);
  
  G4Material* Air=new G4Material("Air",density= 1.290*mg/cm3,ncomponents=2);
  Air->AddElement(N,fractionmass=0.7);
  Air->AddElement(O,fractionmass=0.3);
 
  G4Material* AlBeMet=new G4Material("AlBeMet",density=0.2071*g/cm3,ncomponents=2);
  AlBeMet->AddElement(Al,fractionmass=38.*perCent);
  AlBeMet->AddElement(Be,fractionmass=62.*perCent);
  
  G4Material* CO2=new G4Material("CarbonicGas", density= 1.842*mg/cm3, ncomponents=2,kStateGas, 325.*kelvin, 50.*atmosphere);
  CO2->AddElement(C,natoms=1);
  CO2->AddElement(O,natoms=2);
 
  G4Material* steam=new G4Material("WaterSteam",density=0.3*mg/cm3,ncomponents=1,kStateGas,500.*kelvin,2.*atmosphere);
  steam->AddMaterial(H2O,fractionmass=1.);

  G4Material* Vacuum=new G4Material("Galactic", z=1., a=1.01*g/mole,density= universe_mean_density,kStateGas, 2.73*kelvin, 3.e-18*pascal);

  G4Material* beam=new G4Material("Beam", density= 1.e-5*g/cm3, ncomponents=1,kStateGas, STP_Temperature, 2.e-2*bar);

  beam->AddMaterial(Air, fractionmass=1.);
  G4Material* AirTunnel=new G4Material("AirTunnel",density= 0.00154*g/cm3,ncomponents=1,kStateGas,STP_Temperature,0.001238*atmosphere); 
  AirTunnel->AddMaterial(Air,fractionmass=1.);

  if(0)G4cout << *(G4Material::GetMaterialTable()) << G4endl;
 
  defaultMaterial=Air;
  HornMaterial=Aluminum;
  TargetMaterial=myGraphite;
 
  //HornMaterial=Vacuum; 
  //TargetMaterial=Vacuum;
  
  FillingMaterial=Vacuum;
  TunnelMaterial=AirTunnel;
  //TunnelMaterial=Vacuum;
  //TunnelMaterial=Air;
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::DoInnerConductor(bool place)
{
  G4cout << "SBDetectorConstruction::DoInnerConductor "<< G4endl; 
  // Warning:l'origine du systeme de coordonnées globales est au centre du world volume 
  // -- 
  numZPlanes=23;

 // Initialization
 // --
 for(int i=0;i<24;i++){
   zPlane[i]=0;
   rInner[i]=0;
   rOuter[i]=0;

   xIn[i]=0;
   yOuter[i]=0;
   //rInner1[i]=0;
   //rOuter1[i]=0;
  }

 // Z_plane
 // --
 zPlane[0]=-InCondHalfLength;
 for(int i=1;i<=8;i++){
  zPlane[i]=zPlane[i-1]+(r3/8);
  }
 zPlane[9]=-(InCondHalfLength-r3-L1);
 zPlane[10]=-(InCondHalfLength-r3-L1-L2);  ////modifié
 zPlane[11]=(InCondHalfLength-L4-L5-R4);
 zPlane[12]=(InCondHalfLength-L5-R4);
 zPlane[13]=(InCondHalfLength-R4);

 for(int i=14;i<=23;i++){
  zPlane[i]=zPlane[i-1]+(R4)/10;
 }

 G4cout <<"zPlane[0]= "<<zPlane[0]<<G4endl;
 G4cout <<"zPlane[1]= "<<zPlane[1]<<G4endl;
 G4cout <<"zPlane[2]= "<<zPlane[2]<<G4endl;
 G4cout <<"zPlane[3]= "<<zPlane[3]<<G4endl;
 G4cout <<"zPlane[4]= "<<zPlane[4]<<G4endl;
 G4cout <<"zPlane[5]= "<<zPlane[5]<<G4endl;
 G4cout <<"zPlane[6]= "<<zPlane[6]<<G4endl;
 G4cout <<"zPlane[7]= "<<zPlane[7]<<G4endl;
 G4cout <<"zPlane[8]= "<<zPlane[8]<<G4endl;
 G4cout <<"zPlane[9]= "<<zPlane[9]<<G4endl;
 G4cout <<"zPlane[10]= "<<zPlane[10]<<G4endl;
 G4cout <<"zPlane[11]= "<<zPlane[11]<<G4endl;
 G4cout <<"zPlane[12]= "<<zPlane[12]<<G4endl;
 G4cout <<"zPlane[13]= "<<zPlane[13]<<G4endl;
 G4cout <<"zPlane[14]= "<<zPlane[14]<<G4endl;
 G4cout <<"zPlane[15]= "<<zPlane[15]<<G4endl;
 G4cout <<"zPlane[16]= "<<zPlane[16]<<G4endl;
 G4cout <<"zPlane[17]= "<<zPlane[17]<<G4endl;
 G4cout <<"zPlane[18]= "<<zPlane[18]<<G4endl;
 G4cout <<"zPlane[19]= "<<zPlane[19]<<G4endl;
 G4cout <<"zPlane[20]= "<<zPlane[20]<<G4endl;
 G4cout <<"zPlane[21]= "<<zPlane[21]<<G4endl;
 G4cout <<"zPlane[22]= "<<zPlane[22]<<G4endl;
 G4cout <<"zPlane[23]= "<<zPlane[23]<<G4endl;

 G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;
 
 // R_inner 
 // --
 rInner[0]=t1+r3+R;
 for(int i=1;i<=8;i++){
  rInner[i]=rInner[i-1]-(r3)/8;
 }
 rInner[9]=R+t1;
 rInner[10]=R+R2+t1;
 rInner[11]=R+R2+t1;
 rInner[12]=R+t1;
 rInner[13]=R+t1;

 //for(int i=14;i<=23;i++){
 //rInner[i]=rInner[i-1]+(R2-t3)/10;
 //}
 
 /////////////////////////////////////////////////////////////////////////////////
 //rInner1[13]=R+t1;
 
 xIn[13]=(R4)/10;
 
 for(int i=14;i<=23;i++){
 xIn[i]=xIn[i-1]+(R4)/10;
 }
 for(int i=13;i<=23;i++){
 yInner[i]=sqrt((1-(pow(xIn[i],2)/pow(R4,2)))*pow(R2-t1,2));
 }

 for(int i=14;i<=23;i++){
 rInner[i]=R+t1+(R2-t1-yInner[i-1])-0.5;
 }
 /////////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////////
 //rOuter1[13]=R+R2+R3;
  
 for(int i=13;i<=23;i++){
 yOuter[i]=sqrt((1-(pow(xIn[i],2)/pow(R4,2)))*pow(R3,2));
 }

 for(int i=14;i<=23;i++){
 rOuter[i]=R+R2+R3-(R3-yOuter[i-1]);
 }
 /////////////////////////////////////////////////////////////////////////////////

/*
 G4cout <<"rInner1[13]= "<<rInner1[13]<<G4endl;
 G4cout <<"rInner1[14]= "<<rInner1[14]<<G4endl;
 G4cout <<"rInner1[15]= "<<rInner1[15]<<G4endl;
 G4cout <<"rInner1[16]= "<<rInner1[16]<<G4endl;
 G4cout <<"rInner1[17]= "<<rInner1[17]<<G4endl;
 G4cout <<"rInner1[18]= "<<rInner1[18]<<G4endl;
 G4cout <<"rInner1[19]= "<<rInner1[19]<<G4endl;
 G4cout <<"rInner1[20]= "<<rInner1[20]<<G4endl;
 G4cout <<"rInner1[21]= "<<rInner1[21]<<G4endl;
 G4cout <<"rInner1[22]= "<<rInner1[22]<<G4endl;
 G4cout <<"rInner1[23]= "<<rInner1[23]<<G4endl;
 */
 G4cout <<"rInner[0]= "<<rInner[0]<<G4endl;
 G4cout <<"rInner[1]= "<<rInner[1]<<G4endl;
 G4cout <<"rInner[2]= "<<rInner[2]<<G4endl;
 G4cout <<"rInner[3]= "<<rInner[3]<<G4endl;
 G4cout <<"rInner[4]= "<<rInner[4]<<G4endl;
 G4cout <<"rInner[5]= "<<rInner[5]<<G4endl;
 G4cout <<"rInner[6]= "<<rInner[6]<<G4endl;
 G4cout <<"rInner[7]= "<<rInner[7]<<G4endl;
 G4cout <<"rInner[8]= "<<rInner[8]<<G4endl;
 G4cout <<"rInner[9]= "<<rInner[9]<<G4endl;
 G4cout <<"rInner[10]= "<<rInner[10]<<G4endl;
 G4cout <<"rInner[11]= "<<rInner[11]<<G4endl;
 G4cout <<"rInner[12]= "<<rInner[12]<<G4endl;
 G4cout <<"rInner[13]= "<<rInner[13]<<G4endl;
 G4cout <<"rInner[14]= "<<rInner[14]<<G4endl;
 G4cout <<"rInner[15]= "<<rInner[15]<<G4endl;
 G4cout <<"rInner[16]= "<<rInner[16]<<G4endl;
 G4cout <<"rInner[17]= "<<rInner[17]<<G4endl;
 G4cout <<"rInner[18]= "<<rInner[18]<<G4endl;
 G4cout <<"rInner[19]= "<<rInner[19]<<G4endl;
 G4cout <<"rInner[20]= "<<rInner[20]<<G4endl;
 G4cout <<"rInner[21]= "<<rInner[21]<<G4endl;
 G4cout <<"rInner[22]= "<<rInner[22]<<G4endl;
 G4cout <<"rInner[23]= "<<rInner[23]<<G4endl;
 
 G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;

 // R_outer
 // --
 rOuter[0]=R+R2+R3-r3;  ///rOuterOut[0]=R+R2+R3-r3;
 for(int i=1;i<=8;i++){
  rOuter[i]=rOuter[i-1]+(r3)/8;
  }
 for(int i=9;i<=13;i++){
  rOuter[i]=R+R2+R3;   ///
  }
 //for(int i=14;i<=23;i++){
  //rOuter[i]=rOuter[i-1]-(R3)/10;   ///
  //}

/////////////////////////////////////////////////////////////////////////////////
 //rOuter1[13]=R+R2+R3;
  
 for(int i=13;i<=23;i++){
 yOuter[i]=sqrt((1-(pow(xIn[i],2)/pow(R4,2)))*pow(R3,2));
 }

 for(int i=14;i<=23;i++){
 rOuter[i]=R+R2+R3-(R3-yOuter[i-1]);
 }
 /////////////////////////////////////////////////////////////////////////////////
/*
 G4cout <<"rOuter1[13]= "<<rOuter1[13]<<G4endl;
 G4cout <<"rOuter1[14]= "<<rOuter1[14]<<G4endl;
 G4cout <<"rOuter1[15]= "<<rOuter1[15]<<G4endl;
 G4cout <<"rOuter1[16]= "<<rOuter1[16]<<G4endl;
 G4cout <<"rOuter1[17]= "<<rOuter1[17]<<G4endl;
 G4cout <<"rOuter1[18]= "<<rOuter1[18]<<G4endl;
 G4cout <<"rOuter1[19]= "<<rOuter1[19]<<G4endl;
 G4cout <<"rOuter1[20]= "<<rOuter1[20]<<G4endl;
 G4cout <<"rOuter1[21]= "<<rOuter1[21]<<G4endl;
 G4cout <<"rOuter1[22]= "<<rOuter1[22]<<G4endl;
 G4cout <<"rOuter1[23]= "<<rOuter1[23]<<G4endl;
*/
 
 G4cout <<"rOuter[0]= "<<rOuter[0]<<G4endl;
 G4cout <<"rOuter[1]= "<<rOuter[1]<<G4endl;
 G4cout <<"rOuter[2]= "<<rOuter[2]<<G4endl;
 G4cout <<"rOuter[3]= "<<rOuter[3]<<G4endl;
 G4cout <<"rOuter[4]= "<<rOuter[4]<<G4endl;
 G4cout <<"rOuter[5]= "<<rOuter[5]<<G4endl;
 G4cout <<"rOuter[6]= "<<rOuter[6]<<G4endl;
 G4cout <<"rOuter[7]= "<<rOuter[7]<<G4endl;
 G4cout <<"rOuter[8]= "<<rOuter[8]<<G4endl;
 G4cout <<"rOuter[9]= "<<rOuter[9]<<G4endl;
 G4cout <<"rOuter[10]= "<<rOuter[10]<<G4endl;
 G4cout <<"rOuter[11]= "<<rOuter[11]<<G4endl;
 G4cout <<"rOuter[12]= "<<rOuter[12]<<G4endl;
 G4cout <<"rOuter[13]= "<<rOuter[13]<<G4endl;
 G4cout <<"rOuter[14]= "<<rOuter[14]<<G4endl;
 G4cout <<"rOuter[15]= "<<rOuter[15]<<G4endl;
 G4cout <<"rOuter[16]= "<<rOuter[16]<<G4endl;
 G4cout <<"rOuter[17]= "<<rOuter[17]<<G4endl;
 G4cout <<"rOuter[18]= "<<rOuter[18]<<G4endl;
 G4cout <<"rOuter[19]= "<<rOuter[19]<<G4endl;
 G4cout <<"rOuter[20]= "<<rOuter[20]<<G4endl;
 G4cout <<"rOuter[21]= "<<rOuter[21]<<G4endl;
 G4cout <<"rOuter[22]= "<<rOuter[22]<<G4endl;
 G4cout <<"rOuter[23]= "<<rOuter[23]<<G4endl;

G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;

 G4cout << " Before " << G4endl;
 solidInnerConductor=new G4Polycone("INCO",0.*deg,360.*deg,numZPlanes=23,zPlane,rInner,rOuter);
 //solidInnerConductor=new G4Polycone("INCO",0.*deg,360.*deg,numZPlanes,zPlane,rInner,rOuter);    ///à verifier "(à modifier)"
 G4cout << " After  " << G4endl;
 logicInnerConductor=new G4LogicalVolume(solidInnerConductor,HornMaterial,"INCO");
 
 if(place){
 physiInnerConductor[0]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,Horn_ypos,Horn_zpos),logicInnerConductor,"INCO",logicWorld,false,0); 
 if(place)G4cout << " created.physiInnerConductor[0]"<<G4endl;
 physiInnerConductor[1]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,Horn_ypos,Horn_zpos),logicInnerConductor,"INCO",logicWorld,false,0); 
 if(place)G4cout << " created.physiInnerConductor[1]"<<G4endl;
 physiInnerConductor[2]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,-Horn_ypos,Horn_zpos),logicInnerConductor,"INCO",logicWorld,false,0); 
 if(place)G4cout << " created.physiInnerConductor[2]"<<G4endl;
 physiInnerConductor[3]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,-Horn_ypos,Horn_zpos),logicInnerConductor,"INCO",logicWorld,false,0); 
 if(place)G4cout << " created.physiInnerConductor[3]"<<G4endl;
 }
G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::DoOuterConductor(bool place)
{
  G4cout << "SBDetectorConstruction::DoOuterConductor "<< G4endl; 
/////warning:l'origine du systeme de coordonnées globales est au centre du world volume 
  numZPlanesOut=23;
//initialization
  for(int i=0;i<23;i++){
    zPlaneOut[i]=0;
    rInnerOut[i]=0;
    rOuterOut[i]=0;
    
    //rInnerOut1[i]=0;
    //rOuterOut1[i]=0;
    yInnerOut[i]=0;
    xOut[i]=0;
    yOuterOut[i]=0;
    }
//Z_plane
 zPlaneOut[0]=-OutCondHalfLength;
 for(int i=1;i<=8;i++){
  zPlaneOut[i]=zPlaneOut[i-1]+(t2+r3)/8;
  }
 zPlaneOut[9]=-(OutCondHalfLength-L1-r3-t2);
 zPlaneOut[10]=-(OutCondHalfLength-r3-L1-L2-t2);       ////modifié
 zPlaneOut[11]=(OutCondHalfLength-L4-L5-R4-t3); //(InCondHalfLength-L4-L5-R4)
 zPlaneOut[12]=(OutCondHalfLength-L5-R4-t3);
 zPlaneOut[13]=(OutCondHalfLength-R4-t3);
 for(int i=14;i<=23;i++){
  zPlaneOut[i]=zPlaneOut[i-1]+(R4+t3)/10;
 }

G4cout <<"zPlaneOut[0]= "<<zPlaneOut[0]<<G4endl;
 G4cout <<"zPlaneOut[1]= "<<zPlaneOut[1]<<G4endl;
 G4cout <<"zPlaneOut[2]= "<<zPlaneOut[2]<<G4endl;
 G4cout <<"zPlaneOut[3]= "<<zPlaneOut[3]<<G4endl;
 G4cout <<"zPlaneOut[4]= "<<zPlaneOut[4]<<G4endl;
 G4cout <<"zPlaneOut[5]= "<<zPlaneOut[5]<<G4endl;
 G4cout <<"zPlaneOut[6]= "<<zPlaneOut[6]<<G4endl;
 G4cout <<"zPlaneOut[7]= "<<zPlaneOut[7]<<G4endl;
 G4cout <<"zPlaneOut[8]= "<<zPlaneOut[8]<<G4endl;
 G4cout <<"zPlaneOut[9]= "<<zPlaneOut[9]<<G4endl;
 G4cout <<"zPlaneOut[10]= "<<zPlaneOut[10]<<G4endl;
 G4cout <<"zPlaneOut[11]= "<<zPlaneOut[11]<<G4endl;
 G4cout <<"zPlaneOut[12]= "<<zPlaneOut[12]<<G4endl;
 G4cout <<"zPlaneOut[13]= "<<zPlaneOut[13]<<G4endl;
 G4cout <<"zPlaneOut[14]= "<<zPlaneOut[14]<<G4endl;
 G4cout <<"zPlaneOut[15]= "<<zPlaneOut[15]<<G4endl;
 G4cout <<"zPlaneOut[16]= "<<zPlaneOut[16]<<G4endl;
 G4cout <<"zPlaneOut[17]= "<<zPlaneOut[17]<<G4endl;
 G4cout <<"zPlaneOut[18]= "<<zPlaneOut[18]<<G4endl;
 G4cout <<"zPlaneOut[19]= "<<zPlaneOut[19]<<G4endl;
 G4cout <<"zPlaneOut[20]= "<<zPlaneOut[20]<<G4endl;
 G4cout <<"zPlaneOut[21]= "<<zPlaneOut[21]<<G4endl;
 G4cout <<"zPlaneOut[22]= "<<zPlaneOut[22]<<G4endl;
 G4cout <<"zPlaneOut[23]= "<<zPlaneOut[23]<<G4endl;

G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;
//R_inner 
 rInnerOut[0]=t1+r3+R;
 for(int i=1;i<=8;i++){
  rInnerOut[i]=rInnerOut[i-1]-(t2+r3)/8;
  }
 rInnerOut[9]=R;
 rInnerOut[10]=R+R2;
 rInnerOut[11]=R+R2;
 rInnerOut[12]=R;
 rInnerOut[13]=R;
 //for(int i=14;i<=23;i++){
  //rInnerOut[i]=rInnerOut[i-1]+(R2)/10;
  //}

 /////////////////////////////////////////////////////////////////////////////////
 //rInnerOut1[13]=R;
 
 xOut[13]=(R4+t3)/10;
 
 for(int i=14;i<=23;i++){
 xOut[i]=xOut[i-1]+(R4+t3)/10;
 }
 for(int i=13;i<=23;i++){
 yInnerOut[i]=sqrt((1-(pow(xOut[i],2)/pow(R4+t3,2)))*pow(R2,2));
 }

 for(int i=14;i<=23;i++){
 rInnerOut[i]=R+(R2-yInnerOut[i-1])-0.5;        //R2-t1
 }
 /////////////////////////////////////////////////////////////////////////////////
 

 G4cout <<"rInnerOut[0]= "<<rInnerOut[0]<<G4endl;
 G4cout <<"rInnerOut[1]= "<<rInnerOut[1]<<G4endl;
 G4cout <<"rInnerOut[2]= "<<rInnerOut[2]<<G4endl;
 G4cout <<"rInnerOut[3]= "<<rInnerOut[3]<<G4endl;
 G4cout <<"rInnerOut[4]= "<<rInnerOut[4]<<G4endl;
 G4cout <<"rInnerOut[5]= "<<rInnerOut[5]<<G4endl;
 G4cout <<"rInnerOut[6]= "<<rInnerOut[6]<<G4endl;
 G4cout <<"rInnerOut[7]= "<<rInnerOut[7]<<G4endl;
 G4cout <<"rInnerOut[8]= "<<rInnerOut[8]<<G4endl;
 G4cout <<"rInnerOut[9]= "<<rInnerOut[9]<<G4endl;
 G4cout <<"rInnerOut[10]= "<<rInnerOut[10]<<G4endl;
 G4cout <<"rInnerOut[11]= "<<rInnerOut[11]<<G4endl;
 G4cout <<"rInnerOut[12]= "<<rInnerOut[12]<<G4endl;
 G4cout <<"rInnerOut[13]= "<<rInnerOut[13]<<G4endl;
 G4cout <<"rInnerOut[14]= "<<rInnerOut[14]<<G4endl;
 G4cout <<"rInnerOut[15]= "<<rInnerOut[15]<<G4endl;
 G4cout <<"rInnerOut[16]= "<<rInnerOut[16]<<G4endl;
 G4cout <<"rInnerOut[17]= "<<rInnerOut[17]<<G4endl;
 G4cout <<"rInnerOut[18]= "<<rInnerOut[18]<<G4endl;
 G4cout <<"rInnerOut[19]= "<<rInnerOut[19]<<G4endl;
 G4cout <<"rInnerOut[20]= "<<rInnerOut[20]<<G4endl;
 G4cout <<"rInnerOut[21]= "<<rInnerOut[21]<<G4endl;
 G4cout <<"rInnerOut[22]= "<<rInnerOut[22]<<G4endl;
 G4cout <<"rInnerOut[23]= "<<rInnerOut[23]<<G4endl;


G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;
//R_outer
//G4cout <<"R= "<<R<<G4endl;
//G4cout <<"R2= "<<R2<<G4endl;
//G4cout <<"R3= "<<R3<<G4endl;
//G4cout <<"r3= "<<r3<<G4endl;

 rOuterOut[0]=R+R2+R3-r3;        //rOuter[0]=R+R2+R3-r3;  //////////pb =511.2
 for(int i=1;i<=7;i++){
  rOuterOut[i]=rOuterOut[i-1]+(r3+t4)/8;     //rOuter[i]=rOuter[i-1]+(r3)/8;
  }
 rOuterOut[8]=R+R2+R3+t4;
 for(int i=9;i<=13;i++){
 rOuterOut[i]=R+R2+R3+t4;      //rOuter[i]=R+R2+R3-t4;
 }
 //for(int i=14;i<=23;i++){
 // rOuterOut[i]=rOuterOut[i-1]-(R3+t4)/10;      ///rOuter[i]=rOuter[i-1]-(R3)/10;
 // }

 /////////////////////////////////////////////////////////////////////////////////
 //rOuterOut1[13]=R+R2+R3+t4;
 
 //xInnerOut[13]=R4/10;
 
 //for(int i=14;i<=23;i++){
 //xInnerOut[i]=xInnerOut[i-1]+R4/10;
 //}
 for(int i=13;i<=23;i++){
 yOuterOut[i]=sqrt((1-(pow(xOut[i],2)/pow(R4+t3,2)))*pow(R3+t4,2));
 }

 for(int i=14;i<=23;i++){
 rOuterOut[i]=R+R2+R3+t4-(R3+t4-yOuterOut[i-1]);
 }
 /////////////////////////////////////////////////////////////////////////////////
 
 
G4cout <<"rOuterOut[0]= "<<rOuterOut[0]<<G4endl;
G4cout <<"rOuterOut[1]= "<<rOuterOut[1]<<G4endl;
G4cout <<"rOuterOut[2]= "<<rOuterOut[2]<<G4endl;
G4cout <<"rOuterOut[3]= "<<rOuterOut[3]<<G4endl;
G4cout <<"rOuterOut[4]= "<<rOuterOut[4]<<G4endl;
G4cout <<"rOuterOut[5]= "<<rOuterOut[5]<<G4endl;
G4cout <<"rOuterOut[6]= "<<rOuterOut[6]<<G4endl;
G4cout <<"rOuterOut[7]= "<<rOuterOut[7]<<G4endl;
G4cout <<"rOuterOut[8]= "<<rOuterOut[8]<<G4endl;
G4cout <<"rOuterOut[9]= "<<rOuterOut[9]<<G4endl;
G4cout <<"rOuterOut[10]= "<<rOuterOut[10]<<G4endl;
G4cout <<"rOuterOut[11]= "<<rOuterOut[11]<<G4endl;
G4cout <<"rOuterOut[12]= "<<rOuterOut[12]<<G4endl;
G4cout <<"rOuterOut[13]= "<<rOuterOut[13]<<G4endl;
G4cout <<"rOuterOut[14]= "<<rOuterOut[14]<<G4endl;
G4cout <<"rOuterOut[15]= "<<rOuterOut[15]<<G4endl;
G4cout <<"rOuterOut[16]= "<<rOuterOut[16]<<G4endl;
G4cout <<"rOuterOut[17]= "<<rOuterOut[17]<<G4endl;
G4cout <<"rOuterOut[18]= "<<rOuterOut[18]<<G4endl;
G4cout <<"rOuterOut[19]= "<<rOuterOut[19]<<G4endl;
G4cout <<"rOuterOut[20]= "<<rOuterOut[20]<<G4endl;
G4cout <<"rOuterOut[21]= "<<rOuterOut[21]<<G4endl;
G4cout <<"rOuterOut[22]= "<<rOuterOut[22]<<G4endl;
G4cout <<"rOuterOut[23]= "<<rOuterOut[23]<<G4endl;

G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;

 G4cout << " Before " << G4endl;
 solidVirtualOuterConductor=new G4Polycone("OUTC",0.*deg,360.*deg,numZPlanesOut=23,zPlaneOut,rInnerOut,rOuterOut); 
 solidOuterConductor=new G4SubtractionSolid("OUTC-INCO",solidVirtualOuterConductor,solidInnerConductor,0,G4ThreeVector(0,0,0));
 logicOuterConductor=new G4LogicalVolume(solidOuterConductor,HornMaterial,"OUTC-INCO"); //////à verifier
 G4cout << " After  " << G4endl; 

 if(place){
 physiOuterConductor[0]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,Horn_ypos,Horn_zpos),logicOuterConductor,"OUTC-INCO",logicWorld,false,0); 
 if(place)G4cout <<" created.physiOuterConductor[0]"<<G4endl;
 physiOuterConductor[1]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,Horn_ypos,Horn_zpos),logicOuterConductor,"OUTC-INCO",logicWorld,false,0); 
 if(place)G4cout <<" created.physiOuterConductor[1]"<<G4endl;
 physiOuterConductor[2]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,-Horn_ypos,Horn_zpos),logicOuterConductor,"OUTC-INCO",logicWorld,false,0); 
 if(place)G4cout <<" created.physiOuterConductor[2]"<<G4endl;
 physiOuterConductor[3]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,-Horn_ypos,Horn_zpos),logicOuterConductor,"OUTC-INCO",logicWorld,false,0); 
 if(place)G4cout <<" created.physiOuterConductor[0]"<<G4endl;
 }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::DoTarget(bool place)
{
  G4cout << "SBDetectorConstruction::DoTarget "<< G4endl;           
  G4cout << " Target Thickness " << TargetThickness << G4endl;
  TargetZetaPos=Horn_zpos-OutCondHalfLength+TargetHalfThickness;         /////position cible ok
  solidTarget=new G4Tubs("TARG",0.*cm,TargetDiameter/2.,TargetThickness/2.,0.*deg,360.*deg);
  logicTarget=new G4LogicalVolume(solidTarget,TargetMaterial,"TARG");

  if(place){
     physiTarget[0]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,Horn_ypos,TargetZetaPos),logicTarget,"TARG",logicWorld,false,0);
     G4cout << physiTarget[0]->GetName() <<"[0] created."<<G4endl;
     physiTarget[1]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,-Horn_ypos,TargetZetaPos),logicTarget,"TARG",logicWorld,false,0);
     G4cout << physiTarget[1]->GetName() <<"[1] created."<<G4endl;
     physiTarget[2]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,Horn_ypos,TargetZetaPos),logicTarget,"TARG",logicWorld,false,0);
     G4cout << physiTarget[2]->GetName() <<"[2] created."<<G4endl;
     physiTarget[3]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,-Horn_ypos,TargetZetaPos),logicTarget,"TARG",logicWorld,false,0);
     G4cout << physiTarget[3]->GetName() <<"[3] created."<<G4endl;
     }
 
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::DoTunnel(bool place)
{
  G4cout << "SBDetectorConstruction::DoTunnel "<< G4endl;  
  //Tunnel_zpos=HalfMotherVoluLength;
  Tunnel_zpos=HalfTunnelLength+(Horn_zpos+HalfHornLength)+500;     ///500*mm par rapport horn
  G4cout <<"Tunnel_zpos= "<<Tunnel_zpos<<G4endl;
  solidTunnel=new G4Tubs("TUNL",0.*cm,TunnelRadius,0.5*TunnelLength,0.*deg,360.*deg);
  logicTunnel=new G4LogicalVolume(solidTunnel,TunnelMaterial,"TUNL");
  if(place){
    physiTunnel=new G4PVPlacement(0,G4ThreeVector(0,0,Tunnel_zpos),logicTunnel,"TUNL",logicWorld,false,0);
    G4cout << physiTunnel->GetName() <<" created."<<G4endl;
  }

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::DoMagField1(bool place)
{
 //for the inner conductor
G4cout <<"/////////////////////////////////////////////////////////////"<<G4endl;
 G4cout << "SBDetectorConstruction::DoMagField1 "<< G4endl;  
 int HornNumber=4;
 //initialization
 for(int i=0;i<24;i++){
     rInnerB[i]=0;
     rOuterB[i]=0;
     zPlaneB[i]=0;    
     }
//Z_plane,R_inner,R_outer
 for(int i=0;i<24;i++){ 
    zPlaneB[i]=zPlane[i];
    rInnerB[i]=rInner[i];
    rOuterB[i]=rOuter[i];
    }

 G4double stepMinimum1=1.0e-3*mm;
 SBField* myField1[4];
 G4Mag_UsualEqRhs* iEquation1[4];
 G4MagIntegratorStepper* iStepper1[4];
 G4ChordFinder* iChordFinder1[4];
 G4FieldManager* mfieldMgr1[4];

 for(int i=0;i<HornNumber;i++){
    myField1[i]=new SBField(current1,i,this);                 /////////////////SBField redefinir val magB
    iEquation1[i]=new G4Mag_UsualEqRhs(myField1[i]);
    iStepper1[i]=new G4ClassicalRK4(iEquation1[i]);
    iChordFinder1[i]=new G4ChordFinder(myField1[i],stepMinimum1,iStepper1[i]);
    //mfieldMgr1[i]=new G4FieldManager(myField1[i],iChordFinder1[i]);
    mfieldMgr1[i]=new G4FieldManager(myField1[i],iChordFinder1[i],true);
    }
 G4cout << " Before " << G4endl;
 solidBField1=new G4Polycone("BFL1",0.*deg,360.*deg,numZPlanes=23,zPlaneB,rInnerB,rOuterB);
 G4cout << " After " << G4endl;
 for(int i=0;i<HornNumber;i++){
    logicBField1[i]=new G4LogicalVolume(solidBField1,FillingMaterial,Form("BFL1_%d",i),mfieldMgr1[i],0,0);
    }
 if(place){
    physiBField1[0]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,Horn_ypos,Horn_zpos),logicBField1[0],"BFL1_0",logicWorld,false,0);
    G4cout << physiBField1[0]->GetName() <<"[0] created."<<G4endl;
    physiBField1[1]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,Horn_ypos,Horn_zpos),logicBField1[1],"BFL1_1",logicWorld,false,0); //logicBField1[1]
    G4cout << physiBField1[1]->GetName() <<"[1] created."<<G4endl;
    physiBField1[2]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,-Horn_ypos,Horn_zpos),logicBField1[2],"BFL1_2",logicWorld,false,0);  //logicBField1[2]
    G4cout << physiBField1[2]->GetName() <<"[2] created."<<G4endl;
    physiBField1[3]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,-Horn_ypos,Horn_zpos),logicBField1[3],"BFL1_3",logicWorld,false,0); //logicBField1[3]
    G4cout << physiBField1[3]->GetName() <<"[3] created."<<G4endl;
    }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::DoMagField2(bool place)
{
  //for the outer conductor
 G4cout << "SBDetectorConstruction::DoMagField2 "<< G4endl;  
  int HornNumber=4;
//initialization
 for(int i=0;i<24;i++){
    rInnerBOut[i]=0;
    rOuterBOut[i]=0;
    zPlaneBOut[i]=0;    
    }
//Z_plane,R_inner,R_outer
 for(int i=0;i<24;i++){ 
    zPlaneBOut[i]=zPlaneOut[i];
    rInnerBOut[i]=rInnerOut[i];
    rOuterBOut[i]=rOuterOut[i];
    }

 G4double stepMinimum2=1.0e-3*mm;
 SBField* myField2[4];
 G4Mag_UsualEqRhs* iEquation2[4];
 G4MagIntegratorStepper* iStepper2[4];
 G4ChordFinder* iChordFinder2[4];
 G4FieldManager* mfieldMgr2[4];

 for(int i=0;i<HornNumber;i++){
    myField2[i]=new SBField(current2,i,this);
    iEquation2[i]=new G4Mag_UsualEqRhs(myField2[i]);
    iStepper2[i]=new G4ClassicalRK4(iEquation2[i]);
    iChordFinder2[i]=new G4ChordFinder(myField2[i],stepMinimum2,iStepper2[i]);
    mfieldMgr2[i]=new G4FieldManager(myField2[i],iChordFinder2[i],true);
    }
                      
 solidVirtualBField2=new G4Polycone("BFL2",0.*deg,360.*deg,numZPlanesOut=23,zPlaneBOut,rInnerBOut,rOuterBOut); 
 solidBField2=new G4SubtractionSolid("BFL2-BFL1",solidVirtualBField2,solidBField1,0,G4ThreeVector(0,0,0));
 for(int i=0;i<HornNumber;i++){
    logicBField2[i]=new G4LogicalVolume(solidBField2,FillingMaterial,Form("BFL2_%d",i),mfieldMgr2[i],0,0);
    }
  
 if(place){
    physiBField2[0]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,Horn_ypos,Horn_zpos),logicBField2[0],"BFL2_0",logicWorld,false,0);
    G4cout << physiBField1[0]->GetName() <<"[0] created."<<G4endl;
    physiBField2[1]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,Horn_ypos,Horn_zpos),logicBField2[1],"BFL2_1",logicWorld,false,0);
    G4cout << physiBField1[1]->GetName() <<"[1] created."<<G4endl;
    physiBField2[2]=new G4PVPlacement(0,G4ThreeVector(Horn_xpos,-Horn_ypos,Horn_zpos),logicBField2[2],"BFL2_2",logicWorld,false,0);
    G4cout << physiBField1[2]->GetName() <<"[2] created."<<G4endl;
    physiBField2[3]=new G4PVPlacement(0,G4ThreeVector(-Horn_xpos,-Horn_ypos,Horn_zpos),logicBField2[3],"BFL2_3",logicWorld,false,0);
    G4cout << physiBField1[3]->GetName() <<"[3] created."<<G4endl;
    }
}
 
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBDetectorConstruction::SetVolumesVisibility()   
{
  G4cout << "SBDetectorConstruction::SetVolumesVisibility "<< G4endl;
      
  G4VisAttributes* targetcol= new G4VisAttributes(G4Colour(1.0,0.0,0.0));
  targetcol->SetForceAuxEdgeVisible(true);
  targetcol->SetVisibility(true);
  if(logicTarget)logicTarget->SetVisAttributes(targetcol);

  G4VisAttributes* InnerConductorcol= new G4VisAttributes(G4Colour(0.85,0.5,0.));
  InnerConductorcol->SetForceAuxEdgeVisible(true);
  InnerConductorcol->SetVisibility(true);
  if(logicInnerConductor)logicInnerConductor->SetVisAttributes(InnerConductorcol);

  G4VisAttributes* OuterConductorcol= new G4VisAttributes(G4Colour(0.85,0.5,0.));
  OuterConductorcol->SetForceAuxEdgeVisible(true);
  OuterConductorcol->SetVisibility(true);
  if(logicOuterConductor)logicOuterConductor->SetVisAttributes(OuterConductorcol);

  G4VisAttributes* Tunnelcol= new G4VisAttributes(G4Colour(0.0,1.0,0.0));
  Tunnelcol->SetForceAuxEdgeVisible(true);
  Tunnelcol->SetVisibility(true);
  if(logicTunnel)logicTunnel->SetVisAttributes(Tunnelcol);
  /*
  G4VisAttributes* BField1col= new G4VisAttributes(G4Colour(0.5,0.5,0.5));   //G4Colour(1.0,0.0,0.0)
  //BField1col->SetForceAuxEdgeVisible(true);
  //BField1col->SetVisibility(true);
  for(int i=0;i<HornNumber;i++){
    if(logicBField1[i])logicBField1[i]->SetVisAttributes(BField1col);
    }

  G4VisAttributes* BField2col= new G4VisAttributes(G4Colour(0.5,0.5,0.5));
  //BField2col->SetForceAuxEdgeVisible(true);
  //BField2col->SetVisibility(true);
  for(int i=0;i<HornNumber;i++){
    if(logicBField2[i])logicBField2[i]->SetVisAttributes(BField2col);
    }
  */

}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

#include "SBDetectorConstructionMessenger.hh"

// *********************************************************************************************************

SBDetectorConstructionMessenger::SBDetectorConstructionMessenger (SBDetectorConstruction* aSBDetectorConstruction)
{

	fSBDetectorConstruction = aSBDetectorConstruction ; 

	fHornDistanceToXAxis_command    = new G4UIcmdWithADoubleAndUnit ("/SB/geometry/horn/distanceToXAxis",this) ;
	fHornDistanceToRAxis_command    = new G4UIcmdWithADoubleAndUnit ("/SB/geometry/horn/distanceToRAxis",this) ;
        fHornDistanceToYAxis_command    = new G4UIcmdWithADoubleAndUnit ("/SB/geometry/horn/distanceToYAxis",this) ;
        fHorncurrent1_command           = new G4UIcmdWithADoubleAndUnit ("/SB/geometry/horn/current1",this) ;
        fHorncurrent2_command           = new G4UIcmdWithADoubleAndUnit ("/SB/geometry/horn/current2",this) ;
	fUpdate_command                 = new G4UIcmdWithoutParameter   ("/SB/geometry/update"              ,this) ;

}


// *********************************************************************************************************


SBDetectorConstructionMessenger::~SBDetectorConstructionMessenger ()
{
	delete fHornDistanceToXAxis_command ; fHornDistanceToXAxis_command = NULL ; 
	delete fHornDistanceToRAxis_command ; fHornDistanceToRAxis_command = NULL ;
        delete fHornDistanceToYAxis_command ; fHornDistanceToYAxis_command = NULL ; 
        delete fHorncurrent1_command        ; fHorncurrent1_command        = NULL ;
        delete fHorncurrent2_command        ; fHorncurrent2_command        = NULL ;
	delete fUpdate_command              ; fUpdate_command              = NULL ; 
}


// *********************************************************************************************************


void SBDetectorConstructionMessenger::SetNewValue (G4UIcommand* command, G4String newValue)
{ 	
	if ( command == fHornDistanceToXAxis_command ) 
    { fSBDetectorConstruction->SetHornDistanceToXAxis(fHornDistanceToXAxis_command->GetNewDoubleValue(newValue)) ; } 
	if ( command == fHornDistanceToYAxis_command ) 
    { fSBDetectorConstruction->SetHornDistanceToYAxis(fHornDistanceToYAxis_command->GetNewDoubleValue(newValue)) ; } 
	if ( command == fHornDistanceToRAxis_command ) 
    { fSBDetectorConstruction->SetHornDistanceToRAxis(fHornDistanceToRAxis_command->GetNewDoubleValue(newValue)) ; }
        if ( command == fHorncurrent1_command ) 
    { fSBDetectorConstruction->SetHorncurrent1(fHorncurrent1_command->GetNewDoubleValue(newValue)) ; }
        if ( command == fHorncurrent2_command ) 
    { fSBDetectorConstruction->SetHorncurrent2(fHorncurrent2_command->GetNewDoubleValue(newValue)) ; }
        if ( command == fUpdate_command                   ) { fSBDetectorConstruction->UpdateGeometry() ; } 

	return ; 	
}
#include "SBEventAction.hh"

#include "SBRunAction.hh"
#include "SBProba.hh"
#include "SBEventActionMessenger.hh"

#include "G4Event.hh"
#include "G4TrajectoryContainer.hh"
#include "G4VTrajectory.hh"
#include "G4VVisManager.hh"
#include "G4UnitsTable.hh"

#include "G4KaonPlus.hh"
#include "G4PionPlus.hh"

#include "Randomize.hh"
#include <iomanip>

SBEventAction::SBEventAction(SBRunAction* run, SBProba* proba) :runAct(run),Probability(proba),printModulo(1),eventMessenger(0)
{
  eventMessenger = new SBEventActionMessenger(this);

  // can be overridden with macro file
  PowerMW = 4.;//MW
  EKinProt = 4.5*CLHEP::GeV;

  G4cout<<"CALL SBEventAction::SBEventAction "<<G4endl;

}

SBEventAction::~SBEventAction()
{
  G4cout<<"CALL SBEventAction::~SBEventAction "<<G4endl;
  delete eventMessenger;
}

void SBEventAction::BeginOfEventAction(const G4Event* evt)
{  
  G4cout<<"CALL SBEventAction::BeginOfEventAction "<<G4endl;
  G4int evtNb = evt->GetEventID();

  //check if input file end has been reached
  //in that case end run.
  runAct->CheckEOF();

  if (evtNb%printModulo == 0) { 
    G4cout << "\n---> Begin of event: " << evtNb << G4endl;
    CLHEP::HepRandom::showEngineStatus();
  }
 
 // initialisation per event
  EnergyTarg = EnergyGap = 0.;
  TrackLTarg = TrackLGap = 0.;

  PIPLUS_TRACKID = 0;
  PIMINUS_TRACKID = 0;
  KPLUS_TRACKID = 0;
  KMINUS_TRACKID = 0;
  KZEROS_TRACKID = 0;
  KZEROL_TRACKID = 0;

  p_muplus_PI=-99999.;
  p_muminus_PI=-99999.;
  p_muplus_K=-99999.;
  p_muminus_K=-99999.;

  E_numu_PI=-99999.;
  E_anumu_PI=-99999.;
  E_numu_K=-99999.;
  E_anumu_K=-99999.;

  EForw_numu_PI=-99999.;
  EForw_anumu_PI=-99999.;
  EForw_numu_K=-99999.;
  EForw_anumu_K=-99999.;

  W_numu_PI=-99999.;
  W_anumu_PI=-99999.;

  W_numu_K=-99999.;
  W_anumu_K=-99999.;

  NDIF_piplus=0;
  NDIF_piminus=0;
  NDIF_Kplus=0;
  NDIF_Kminus=0;
  NDIF_KzeroS=0;
  NDIF_KzeroL=0;

  p_DIF_PI_piplus=G4ThreeVector(0,0,0);
  p_DIF_PI_piminus=G4ThreeVector(0,0,0);
  p_DIF_K_kplus=G4ThreeVector(0,0,0);
  p_DIF_K_kminus=G4ThreeVector(0,0,0);

  p_DIF_PI_numu=G4ThreeVector(0,0,0);
  p_DIF_PI_anumu=G4ThreeVector(0,0,0);
  p_DIF_K_numu=G4ThreeVector(0,0,0);
  p_DIF_K_anumu=G4ThreeVector(0,0,0);

  p_DIF_PI_muplus=G4ThreeVector(0,0,0);
  p_DIF_PI_muminus=G4ThreeVector(0,0,0);
  p_DIF_K_muplus=G4ThreeVector(0,0,0);
  p_DIF_K_muminus=G4ThreeVector(0,0,0);

  p_DIF_K_kzeroL=G4ThreeVector(0,0,0);
  p_DIF_K_kzeroS=G4ThreeVector(0,0,0);

  x_DIF_PI_piplus=G4ThreeVector(0,0,0);
  x_DIF_PI_piminus=G4ThreeVector(0,0,0);
  x_DIF_K_kplus=G4ThreeVector(0,0,0);
  x_DIF_K_kminus=G4ThreeVector(0,0,0);

  x_DIF_K_kzeroL=G4ThreeVector(0,0,0);
  x_DIF_K_kzeroS=G4ThreeVector(0,0,0);

  x_DIF_PI_numu=G4ThreeVector(0,0,0);
  x_DIF_PI_anumu=G4ThreeVector(0,0,0);
  x_DIF_K_numu=G4ThreeVector(0,0,0);
  x_DIF_K_anumu=G4ThreeVector(0,0,0);

  x_DIF_PI_muplus=G4ThreeVector(0,0,0);
  x_DIF_PI_muminus=G4ThreeVector(0,0,0);
  x_DIF_K_muplus=G4ThreeVector(0,0,0);
  x_DIF_K_muminus=G4ThreeVector(0,0,0);
  
  ParLevel_piplus=-1;
  ParLevel_piminus=-1;
  ParLevel_muplus=-1;
  ParLevel_muminus=-1;

  MAXIND=10000;// must be equal to the one in SBSteppingAction.hh ...
  for(int i=0;i<MAXIND;i++){
    vPDG_ID[i]=0;
    vPDG_PAR_ID[i]=0;
    vPDG_PARPAR_ID[i]=0;
  }

  NBody=0;
  pich2B=false;
  kch2B=false;
  kch3B=false;
  kzero3B=false;
  decflag=0;
  p_K_3B=G4ThreeVector(0,0,0);
  enuLAB_K_3B=0;

  n1=0;
  n2=0;
  n3=0;
  n4=0;
  n5=0;
  n6=0;
  n7=0;
  n8=0;
  n9=0;
  n10=0;
  n11=0;
  n12=0;
  n13=0;
  n14=0;
  n15=0;
  n16=0;
  n17=0;
  n18=0;
  n19=0;
  n20=0;
  n30=0;
  n31=0;
  for(int i=0;i<20;i++){
    p_nu1[i]=G4ThreeVector(0,0,0);
    p_nu2[i]=G4ThreeVector(0,0,0);
    p_nu3[i]=G4ThreeVector(0,0,0);
    p_nu4[i]=G4ThreeVector(0,0,0);
    p_nu5[i]=G4ThreeVector(0,0,0);
    p_nu6[i]=G4ThreeVector(0,0,0);
    p_nu7[i]=G4ThreeVector(0,0,0);
    p_nu8[i]=G4ThreeVector(0,0,0);
    p_nu9[i]=G4ThreeVector(0,0,0);
    p_nu10[i]=G4ThreeVector(0,0,0);
    p_nu11[i]=G4ThreeVector(0,0,0);
    p_nu12[i]=G4ThreeVector(0,0,0);
    p_nu13[i]=G4ThreeVector(0,0,0);
    p_nu14[i]=G4ThreeVector(0,0,0);
    p_nu15[i]=G4ThreeVector(0,0,0);
    p_nu16[i]=G4ThreeVector(0,0,0);
    p_nu17[i]=G4ThreeVector(0,0,0);
    p_nu18[i]=G4ThreeVector(0,0,0);
    p_nu19[i]=G4ThreeVector(0,0,0);
    p_nu20[i]=G4ThreeVector(0,0,0);
    p_nu30[i]=G4ThreeVector(0,0,0);
    p_nu31[i]=G4ThreeVector(0,0,0);

    p_mu1[i]=G4ThreeVector(0,0,0);
    p_mu2[i]=G4ThreeVector(0,0,0);
    p_mu3[i]=G4ThreeVector(0,0,0);
    p_mu4[i]=G4ThreeVector(0,0,0);
    p_mu5[i]=G4ThreeVector(0,0,0);
    p_mu6[i]=G4ThreeVector(0,0,0);
    p_mu7[i]=G4ThreeVector(0,0,0);
    p_mu8[i]=G4ThreeVector(0,0,0);
    p_mu9[i]=G4ThreeVector(0,0,0);
    p_mu10[i]=G4ThreeVector(0,0,0);
    p_mu11[i]=G4ThreeVector(0,0,0);
    p_mu12[i]=G4ThreeVector(0,0,0);
    p_mu13[i]=G4ThreeVector(0,0,0);
    p_mu14[i]=G4ThreeVector(0,0,0);
    p_mu15[i]=G4ThreeVector(0,0,0);
    p_mu16[i]=G4ThreeVector(0,0,0);
    p_mu17[i]=G4ThreeVector(0,0,0);
    p_mu18[i]=G4ThreeVector(0,0,0);
    p_mu19[i]=G4ThreeVector(0,0,0);
    p_mu20[i]=G4ThreeVector(0,0,0);
    p_mu30[i]=G4ThreeVector(0,0,0);
    p_mu31[i]=G4ThreeVector(0,0,0);

    x_mu1[i]=G4ThreeVector(0,0,0);
    x_mu2[i]=G4ThreeVector(0,0,0);
    x_mu3[i]=G4ThreeVector(0,0,0);
    x_mu4[i]=G4ThreeVector(0,0,0);
    x_mu5[i]=G4ThreeVector(0,0,0);
    x_mu6[i]=G4ThreeVector(0,0,0);
    x_mu7[i]=G4ThreeVector(0,0,0);
    x_mu8[i]=G4ThreeVector(0,0,0);
    x_mu9[i]=G4ThreeVector(0,0,0);
    x_mu10[i]=G4ThreeVector(0,0,0);
    x_mu11[i]=G4ThreeVector(0,0,0);
    x_mu12[i]=G4ThreeVector(0,0,0);
    x_mu13[i]=G4ThreeVector(0,0,0);
    x_mu14[i]=G4ThreeVector(0,0,0);
    x_mu15[i]=G4ThreeVector(0,0,0);
    x_mu16[i]=G4ThreeVector(0,0,0);
    x_mu17[i]=G4ThreeVector(0,0,0);
    x_mu18[i]=G4ThreeVector(0,0,0);
    x_mu19[i]=G4ThreeVector(0,0,0);
    x_mu20[i]=G4ThreeVector(0,0,0);
    x_mu30[i]=G4ThreeVector(0,0,0);
    x_mu31[i]=G4ThreeVector(0,0,0);
    
    p_par1[i]=G4ThreeVector(0,0,0);
    p_par2[i]=G4ThreeVector(0,0,0);
    p_par3[i]=G4ThreeVector(0,0,0);
    p_par4[i]=G4ThreeVector(0,0,0);
    p_par5[i]=G4ThreeVector(0,0,0);
    p_par6[i]=G4ThreeVector(0,0,0);
    p_par7[i]=G4ThreeVector(0,0,0);
    p_par8[i]=G4ThreeVector(0,0,0);
    p_par9[i]=G4ThreeVector(0,0,0);
    p_par10[i]=G4ThreeVector(0,0,0);
    p_par11[i]=G4ThreeVector(0,0,0);
    p_par12[i]=G4ThreeVector(0,0,0);
    p_par13[i]=G4ThreeVector(0,0,0);
    p_par14[i]=G4ThreeVector(0,0,0);
    p_par15[i]=G4ThreeVector(0,0,0);
    p_par16[i]=G4ThreeVector(0,0,0);
    p_par17[i]=G4ThreeVector(0,0,0);
    p_par18[i]=G4ThreeVector(0,0,0);
    p_par19[i]=G4ThreeVector(0,0,0);
    p_par20[i]=G4ThreeVector(0,0,0);
    p_par30[i]=G4ThreeVector(0,0,0);
    p_par31[i]=G4ThreeVector(0,0,0);

    id1[i]=0;
    id2[i]=0;
    id3[i]=0;
    id4[i]=0;
    id5[i]=0;
    id6[i]=0;
    id7[i]=0;
    id8[i]=0;
    id9[i]=0;
    id10[i]=0;
    id11[i]=0;
    id12[i]=0;
    id13[i]=0;
    id14[i]=0;
    id15[i]=0;
    id16[i]=0;
    id17[i]=0;
    id18[i]=0;
    id19[i]=0;
    id20[i]=0;  
    id30[i]=0;
    id31[i]=0;

    id_par1[i]=0;
    id_par2[i]=0;
    id_par3[i]=0;
    id_par4[i]=0;
    id_par5[i]=0;
    id_par6[i]=0;
    id_par7[i]=0;
    id_par8[i]=0;
    id_par9[i]=0;
    id_par10[i]=0;
    id_par11[i]=0;
    id_par12[i]=0;
    id_par13[i]=0;
    id_par14[i]=0;
    id_par15[i]=0;
    id_par16[i]=0;
    id_par17[i]=0;
    id_par18[i]=0;
    id_par19[i]=0;
    id_par20[i]=0;  
    id_par30[i]=0;
    id_par31[i]=0;

    class_par30[i]=0;
    class_par31[i]=0;
    
  }
  //

  x_EXI_piplus=G4ThreeVector(0,0,0);
  p_EXI_piplus=G4ThreeVector(0,0,0);

  x_EXI_piminus=G4ThreeVector(0,0,0);
  p_EXI_piminus=G4ThreeVector(0,0,0);

  x_EXI_kplus=G4ThreeVector(0,0,0);
  p_EXI_kplus=G4ThreeVector(0,0,0);

  x_EXI_kminus=G4ThreeVector(0,0,0);
  p_EXI_kminus=G4ThreeVector(0,0,0);

  x_EXI_muplus=G4ThreeVector(0,0,0);
  p_EXI_muplus=G4ThreeVector(0,0,0);

  x_EXI_muminus=G4ThreeVector(0,0,0);
  p_EXI_muminus=G4ThreeVector(0,0,0);

  x_EXI_k0L=G4ThreeVector(0,0,0);
  p_EXI_k0L=G4ThreeVector(0,0,0);

  angnue0OLD = -999;
  angnumu0OLD = -999;
  anganue0OLD = -999;
  anganumu0OLD = -999;

}

void SBEventAction::EndOfEventAction(const G4Event* evt)
{
  G4cout<<"CALL SBEventAction::EndOfEventAction "<<G4endl;
  //accumulates statistic
  //
  runAct->fillPerEvent(EnergyTarg, EnergyGap, TrackLTarg, TrackLGap);

  //G4cout <<"PROVA "<< p_muplus_PI/CLHEP::GeV << G4endl=0;

  E_numu_PI=p_DIF_PI_numu.mag();
  E_anumu_PI=p_DIF_PI_anumu.mag();
  E_numu_K=p_DIF_K_numu.mag();
  E_anumu_K=p_DIF_K_anumu.mag();

  p_muplus_PI=p_DIF_PI_muplus.mag();
  p_muminus_PI=p_DIF_PI_muminus.mag();
  p_muplus_K=p_DIF_K_muplus.mag();
  p_muminus_K=p_DIF_K_muminus.mag();

  //G4cout << "ciccio K " << E_numu_K << " PI " << E_numu_PI <<G4endl;

  runAct->fillPerEvent1(p_muplus_PI,
			p_muminus_PI,
			p_muplus_K,
			p_muminus_K,
			E_numu_PI,
			E_anumu_PI,
			E_numu_K,
			E_anumu_K);

  //G4cout << "E_numu_PI "<< E_numu_PI << G4endl;
  G4double mpi = G4PionPlus::PionPlus()->GetPDGMass();
  G4double mK = G4KaonPlus::KaonPlus()->GetPDGMass();

  EForw_numu_PI=Probability->EnuForward(p_DIF_PI_piplus,mpi);
  EForw_anumu_PI=Probability->EnuForward(p_DIF_PI_piminus,mpi);
  EForw_numu_K=Probability->EnuForward(p_DIF_K_kplus,mK);
  EForw_anumu_K=Probability->EnuForward(p_DIF_K_kminus,mK);

  G4double PWN = Probability->PowerNorm(EKinProt,PowerMW);       

  if(evt->GetEventID()==0) G4cout <<"SBEventAction: Ek(p) "<< EKinProt << " GeV. Power " << PowerMW << " (MW). Norm fact.: "<< PWN << G4endl;

  if(SBVerbosity>0)G4cout <<"SBEventAction: PROBABS "<< W_numu_PI << " " << W_anumu_PI <<" "<< W_numu_K << " " << W_anumu_K << G4endl;

  //G4cout<<"PROVA "<< ParLevel_piminus<<" "<<ParLevel_piplus<<G4endl;

  if((ParLevel_piminus!=-1)||
     (ParLevel_piplus!=-1)||
     (ParLevel_muminus!=-1)||
     (ParLevel_muplus!=-1)
     ) G4cout<<"SBEventAction hierarchy ";
  if(ParLevel_piminus!=-1)G4cout<<" pi- "<<ParLevel_piminus;
  if(ParLevel_piplus!=-1)G4cout<<" pi+ "<<ParLevel_piplus;
  if(ParLevel_muminus!=-1)G4cout<<" mu- "<<ParLevel_muminus;
  if(ParLevel_muplus!=-1)G4cout<<" mu+ "<<ParLevel_muplus;
  G4cout<<G4endl;

  DumpChannelsInfo();

  //======================================

  for(int j=0;j<n1;j++){
    Probability->proba2(p_par1[j],"kaon",0,1,PWN);
  }
  for(int j=0;j<n2;j++){
    Probability->proba2(p_par2[j],"kaon",0,-1,PWN);
  }
  //-----------------------

  for(int j=0;j<n30;j++){
    Probability->proba2(p_par30[j],"pion",class_par30[j],1,PWN);
  }
  for(int j=0;j<n31;j++){
    Probability->proba2(p_par31[j],"pion",class_par31[j],-1,PWN);
  }

  //-----------------------
  for(int j=0;j<n7;j++){
    Probability->proba3K(p_par7[j],p_nu7[j].mag(),PWN,7);
  }
  for(int j=0;j<n8;j++){
    Probability->proba3K(p_par8[j],p_nu8[j].mag(),PWN,8);
  }
  for(int j=0;j<n9;j++){
    Probability->proba3K(p_par9[j],p_nu9[j].mag(),PWN,9);
  }
  for(int j=0;j<n10;j++){
    Probability->proba3K(p_par10[j],p_nu10[j].mag(),PWN,10);
  }
  for(int j=0;j<n13;j++){
    Probability->proba3K(p_par13[j],p_nu13[j].mag(),PWN,13);
  }
  for(int j=0;j<n14;j++){
    Probability->proba3K(p_par14[j],p_nu14[j].mag(),PWN,14);
  }
  for(int j=0;j<n15;j++){
    Probability->proba3K(p_par15[j],p_nu15[j].mag(),PWN,15);
  }
  for(int j=0;j<n16;j++){
    Probability->proba3K(p_par16[j],p_nu16[j].mag(),PWN,16);
  }
  //-----------------------
  // decay channels producing muons
  for(int j=0;j<n1;j++){
    Probability->probaMu(x_mu1[j],p_mu1[j],p_par1[j],mK,1,2,PWN);
  }
  for(int j=0;j<n2;j++){
    Probability->probaMu(x_mu2[j],p_mu2[j],p_par2[j],mK,-1,2,PWN);
  }
  for(int j=0;j<n9;j++){
    Probability->probaMu(x_mu9[j],p_mu9[j],p_par9[j],mK,1,2,PWN);
  }
  for(int j=0;j<n10;j++){
    Probability->probaMu(x_mu10[j],p_mu10[j],p_par10[j],mK,-1,2,PWN);
  }
  for(int j=0;j<n15;j++){
    Probability->probaMu(x_mu15[j],p_mu15[j],p_par15[j],mK,1,3,PWN);
  }
  for(int j=0;j<n16;j++){
    Probability->probaMu(x_mu16[j],p_mu16[j],p_par16[j],mK,-1,3,PWN);
  }
  //----
  for(int j=0;j<n30;j++){
    if(class_par30[j]==0)Probability->probaMu(x_mu30[j],p_mu30[j],p_par30[j],mpi,1,1,PWN);
    if(class_par30[j]==1)Probability->probaMu(x_mu30[j],p_mu30[j],p_par30[j],mpi,1,2,PWN);
    if(class_par30[j]==2)Probability->probaMu(x_mu30[j],p_mu30[j],p_par30[j],mpi,1,3,PWN);
  }
  for(int j=0;j<n31;j++){
    if(class_par31[j]==0)Probability->probaMu(x_mu31[j],p_mu31[j],p_par31[j],mpi,-1,1,PWN);
    if(class_par31[j]==1)Probability->probaMu(x_mu31[j],p_mu31[j],p_par31[j],mpi,-1,2,PWN);
    if(class_par31[j]==2)Probability->probaMu(x_mu31[j],p_mu31[j],p_par31[j],mpi,-1,3,PWN);
  }
  //-----------------------

  G4int moth=0,chargeDIF=0;
  G4double xx=0,yy=0,zz=0;
  G4double pxx=0,pyy=0,pzz=0;
  G4double pxnu=0,pynu=0,pznu=0;

  if(x_DIF_PI_piplus!=G4ThreeVector(0,0,0)){
    moth=1;
    chargeDIF=1;
    xx = x_DIF_PI_piplus.x();
    yy = x_DIF_PI_piplus.y();
    zz = x_DIF_PI_piplus.z();
    pxx = p_DIF_PI_piplus.x();
    pyy = p_DIF_PI_piplus.y();
    pzz = p_DIF_PI_piplus.z();
    pxnu = p_DIF_PI_numu.x();
    pynu = p_DIF_PI_numu.y();
    pznu = p_DIF_PI_numu.z();
  }
  if(x_DIF_K_kplus!=G4ThreeVector(0,0,0)){
    moth=2;
    chargeDIF=1;
    xx = x_DIF_K_kplus.x();
    yy = x_DIF_K_kplus.y();
    zz = x_DIF_K_kplus.z();
    pxx = p_DIF_K_kplus.x();
    pyy = p_DIF_K_kplus.y();
    pzz = p_DIF_K_kplus.z();
    pxnu = p_DIF_K_numu.x();
    pynu = p_DIF_K_numu.y();
    pznu = p_DIF_K_numu.z();
  }

  if(x_DIF_PI_piminus!=G4ThreeVector(0,0,0)){
    moth=1;
    chargeDIF=-1;
    xx = x_DIF_PI_piminus.x();
    yy = x_DIF_PI_piminus.y();
    zz = x_DIF_PI_piminus.z();
    pxx = p_DIF_PI_piminus.x();
    pyy = p_DIF_PI_piminus.y();
    pzz = p_DIF_PI_piminus.z();
    pxnu = p_DIF_PI_anumu.x();
    pynu = p_DIF_PI_anumu.y();
    pznu = p_DIF_PI_anumu.z();
  }
  if(x_DIF_K_kminus!=G4ThreeVector(0,0,0)){
    moth=2;
    chargeDIF=-1;
    xx = x_DIF_K_kminus.x();
    yy = x_DIF_K_kminus.y();
    zz = x_DIF_K_kminus.z();
    pxx = p_DIF_K_kminus.x();
    pyy = p_DIF_K_kminus.y();
    pzz = p_DIF_K_kminus.z();
    pxnu = p_DIF_K_anumu.x();
    pynu = p_DIF_K_anumu.y();
    pznu = p_DIF_K_anumu.z();
  }

  if((NDIF_piplus+NDIF_piminus+NDIF_Kplus+NDIF_Kminus+NDIF_KzeroS+NDIF_KzeroL)>0)
    G4cout<<"SBEventAction: decays in flight observed for this input track: " <<
      " pi+ "<<NDIF_piplus<<
      " pi- "<<NDIF_piminus<<
      " K+ "<<NDIF_Kplus<<
      " K- "<<NDIF_Kminus<<
      " K0L "<<NDIF_KzeroL<<
      " K0S "<<NDIF_KzeroS<<G4endl;

  runAct->DIFStat(NDIF_piplus,
		  NDIF_piminus,
		  NDIF_Kplus,
		  NDIF_Kminus,
		  NDIF_KzeroS,
		  NDIF_KzeroL);

  if(moth)runAct->fillDIF(xx,yy,zz,
			  pxx,pyy,pzz,
			  pxnu,pynu,pznu,
			  moth,chargeDIF);

  /***********/
  xx = x_EXI_piplus.x();
  yy = x_EXI_piplus.y();
  zz = x_EXI_piplus.z();
  pxx = p_EXI_piplus.x();
  pyy = p_EXI_piplus.y();
  pzz = p_EXI_piplus.z();
  runAct->fillEXIT(xx,yy,zz,pxx,pyy,pzz,1);

  xx = x_EXI_piminus.x();
  yy = x_EXI_piminus.y();
  zz = x_EXI_piminus.z();
  pxx = p_EXI_piminus.x();
  pyy = p_EXI_piminus.y();
  pzz = p_EXI_piminus.z();
  runAct->fillEXIT(xx,yy,zz,pxx,pyy,pzz,2);

  // fill histo with tracks' parameters at target exit
  runAct->fillTARG(E_numu_PI);

  //print per event (modulo n)
  //
  G4int evtNb = evt->GetEventID();
  if (evtNb%printModulo == 0) {
    //G4cout<<"---> End of event: "<<evtNb<<G4endl;	
    if(SBVerbosity>0)
    G4cout<<"SBEventAction: Target: total energy: " <<std::setw(7)<<G4BestUnit(EnergyTarg,"Energy")<<" total track length: "<<std::setw(7)<<G4BestUnit(TrackLTarg,"Length")<<G4endl;
       //<< "        Gap: total energy: " << std::setw(7)
       //                                 << G4BestUnit(EnergyGap,"Energy")
       //<< "       total track length: " << std::setw(7)
       //                                 << G4BestUnit(TrackLGap,"Length")
       //<< G4endl;  
  }
  //m_hh->theta->Fill(EnergyTarg);

  //check if input file end has been reached
  //in that case end run.
  //runAct->CheckEOF();
}  


void SBEventAction::DumpChannelsInfo(){
  //======================================
  if(n1)G4cout << "Decay 1: K+ -> mu+ numu "<<n1<<G4endl;
  for(int j=0;j<n1;j++){
    if(n1)G4cout << j <<" p_par1 "<< p_par1[j]/CLHEP::GeV <<" p_mu1 "<<p_mu1[j]/CLHEP::GeV<<" x_mu1 "<<x_mu1[j]/CLHEP::m<<" p_nu1 "<<p_nu1[j]/CLHEP::GeV<<G4endl;
  }
  if(n2)G4cout << "Decay 2: "<<n2<<G4endl;
  for(int j=0;j<n2;j++){
    if(n2)G4cout << j <<" p_par2 "<< p_par2[j]/CLHEP::GeV <<" p_mu2 "<<p_mu2[j]/CLHEP::GeV<<" x_mu2 "<<x_mu2[j]/CLHEP::m<<" p_nu2 "<<p_nu2[j]/CLHEP::GeV<<G4endl;
  }
  if(n3)G4cout << "Decay 3: "<<n3<<G4endl;
  for(int j=0;j<n3;j++){
    if(n3)G4cout << j <<" p_par3 "<< p_par3[j]/CLHEP::GeV <<" p_mu3 "<<p_mu3[j]/CLHEP::GeV<<" x_mu3 "<<x_mu3[j]/CLHEP::m<<" p_nu3 "<<p_nu3[j]/CLHEP::GeV<<G4endl;
  }
  if(n4)G4cout << "Decay 4: "<<n4<<G4endl;
  for(int j=0;j<n4;j++){
    if(n4)G4cout << j <<" p_par4 "<< p_par4[j]/CLHEP::GeV <<" p_mu4 "<<p_mu4[j]/CLHEP::GeV<<" x_mu4 "<<x_mu4[j]/CLHEP::m<<" p_nu4 "<<p_nu4[j]/CLHEP::GeV<<G4endl;
  }
  if(n5)G4cout << "Decay 5: "<<n5<<G4endl;
  for(int j=0;j<n5;j++){
    if(n5)G4cout << j <<" p_par5 "<< p_par5[j]/CLHEP::GeV <<" p_mu5 "<<p_mu5[j]/CLHEP::GeV<<" x_mu5 "<<x_mu5[j]/CLHEP::m<<" p_nu5 "<<p_nu5[j]/CLHEP::GeV<<G4endl;
  }
  if(n6)G4cout << "Decay 6: "<<n6<<G4endl;
  for(int j=0;j<n6;j++){
    if(n6)G4cout << j <<" p_par6 "<< p_par6[j]/CLHEP::GeV <<" p_mu6 "<<p_mu6[j]/CLHEP::GeV<<" x_mu6 "<<x_mu6[j]/CLHEP::m<<" p_nu6 "<<p_nu6[j]/CLHEP::GeV<<G4endl;
  }
  if(n7)G4cout << "Decay 7: "<<n7<<G4endl;
  for(int j=0;j<n7;j++){
    if(n7)G4cout << j <<" p_par7 "<< p_par7[j]/CLHEP::GeV <<" p_mu7 "<<p_mu7[j]/CLHEP::GeV<<" x_mu7 "<<x_mu7[j]/CLHEP::m<<" p_nu7 "<<p_nu7[j]/CLHEP::GeV<<G4endl;
  }
  if(n8)G4cout << "Decay 8: "<<n8<<G4endl;
  for(int j=0;j<n8;j++){
    if(n8)G4cout << j <<" p_par8 "<< p_par8[j]/CLHEP::GeV <<" p_mu8 "<<p_mu8[j]/CLHEP::GeV<<" x_mu8 "<<x_mu8[j]/CLHEP::m<<" p_nu8 "<<p_nu8[j]/CLHEP::GeV<<G4endl;
  }
  if(n9)G4cout << "Decay 9: "<<n9<<G4endl;
  for(int j=0;j<n9;j++){
    if(n9)G4cout << j <<" p_par9 "<< p_par9[j]/CLHEP::GeV <<" p_mu9 "<<p_mu9[j]/CLHEP::GeV<<" x_mu9 "<<x_mu9[j]/CLHEP::m<<" p_nu9 "<<p_nu9[j]/CLHEP::GeV<<G4endl;
  }
  if(n10)G4cout << "Decay 10: "<<n10<<G4endl;
  for(int j=0;j<n10;j++){
    if(n10)G4cout << j <<" p_par10 "<< p_par10[j]/CLHEP::GeV <<" p_mu10 "<<p_mu10[j]/CLHEP::GeV<<" x_mu10 "<<x_mu10[j]/CLHEP::m<<" p_nu10 "<<p_nu10[j]/CLHEP::GeV<<G4endl;
  }
  if(n11)G4cout << "Decay 11: "<<n11<<G4endl;
  for(int j=0;j<n11;j++){
    if(n11)G4cout << j <<" p_par11 "<< p_par11[j]/CLHEP::GeV <<" p_mu11 "<<p_mu11[j]/CLHEP::GeV<<" x_mu11 "<<x_mu11[j]/CLHEP::m<<" p_nu11 "<<p_nu11[j]/CLHEP::GeV<<G4endl;
  }
  if(n12)G4cout << "Decay 12: "<<n12<<G4endl;
  for(int j=0;j<n12;j++){
    if(n12)G4cout << j <<" p_par12 "<< p_par12[j]/CLHEP::GeV <<" p_mu12 "<<p_mu12[j]/CLHEP::GeV<<" x_mu12 "<<x_mu12[j]/CLHEP::m<<" p_nu12 "<<p_nu12[j]/CLHEP::GeV<<G4endl;
  }
  if(n13)G4cout << "Decay 13: "<<n13<<G4endl;
  for(int j=0;j<n13;j++){
    if(n13)G4cout << j <<" p_par13 "<< p_par13[j]/CLHEP::GeV <<" p_mu13 "<<p_mu13[j]/CLHEP::GeV<<" x_mu13 "<<x_mu13[j]/CLHEP::m<<" p_nu13 "<<p_nu13[j]/CLHEP::GeV<<G4endl;
  }
  if(n14)G4cout << "Decay 14: "<<n14<<G4endl;
  for(int j=0;j<n14;j++){
    if(n14)G4cout << j <<" p_par14 "<< p_par14[j]/CLHEP::GeV <<" p_mu14 "<<p_mu14[j]/CLHEP::GeV<<" x_mu14 "<<x_mu14[j]/CLHEP::m<<" p_nu14 "<<p_nu14[j]/CLHEP::GeV<<G4endl;
  }
  if(n15)G4cout << "Decay 15: "<<n15<<G4endl;
  for(int j=0;j<n15;j++){
    if(n15)G4cout << j <<" p_par15 "<< p_par15[j]/CLHEP::GeV <<" p_mu15 "<<p_mu15[j]/CLHEP::GeV<<" x_mu15 "<<x_mu15[j]/CLHEP::m<<" p_nu15 "<<p_nu15[j]/CLHEP::GeV<<G4endl;
  }
  if(n16)G4cout << "Decay 16: "<<n16<<G4endl;
  for(int j=0;j<n16;j++){
    if(n16)G4cout << j <<" p_par16 "<< p_par16[j]/CLHEP::GeV <<" p_mu16 "<<p_mu16[j]/CLHEP::GeV<<" x_mu16 "<<x_mu16[j]/CLHEP::m<<" p_nu16 "<<p_nu16[j]/CLHEP::GeV<<G4endl;
  }
  if(n17)G4cout << "Decay 17: "<<n17<<G4endl;
  for(int j=0;j<n17;j++){
    if(n17)G4cout << j <<" p_par17 "<< p_par17[j]/CLHEP::GeV <<" p_mu17 "<<p_mu17[j]/CLHEP::GeV<<" x_mu17 "<<x_mu17[j]/CLHEP::m<<" p_nu17 "<<p_nu17[j]/CLHEP::GeV<<G4endl;
  }
  if(n18)G4cout << "Decay 18: "<<n18<<G4endl;
  for(int j=0;j<n18;j++){
    if(n18)G4cout << j <<" p_par18 "<< p_par18[j]/CLHEP::GeV <<" p_mu18 "<<p_mu18[j]/CLHEP::GeV<<" x_mu18 "<<x_mu18[j]/CLHEP::m<<" p_nu18 "<<p_nu18[j]/CLHEP::GeV<<G4endl;
  }
  if(n19)G4cout << "Decay 19: K0S -> pi+ pi- "<<n19<<G4endl;
  for(int j=0;j<n19;j++){
    if(n19)G4cout << j <<" p_par19 "<< p_par19[j]/CLHEP::GeV <<" p_mu19 "<<p_mu19[j]/CLHEP::GeV<<" x_mu19 "<<x_mu19[j]/CLHEP::m<<" p_nu19 "<<p_nu19[j]/CLHEP::GeV<<
	     " id_sec_pip1 "<<id_sec_pip1_19[j]<<" id_sec_pim1 "<<id_sec_pim1_19[j]<<G4endl;
  }
  if(n20)G4cout << "Decay 20: "<<n20<<G4endl;
  for(int j=0;j<n20;j++){
    if(n20)G4cout << j <<" p_par20 "<< p_par20[j]/CLHEP::GeV <<" p_mu20 "<<p_mu20[j]/CLHEP::GeV<<" x_mu20 "<<x_mu20[j]/CLHEP::m<<" p_nu20 "<<p_nu20[j]/CLHEP::GeV<<G4endl;
  }


  //======================================

  // add the others
  if(n30)G4cout << "Decay 30: "<<n30<<G4endl;
  for(int j=0;j<n30;j++){
    if(n30)G4cout << j <<" p_par30 "<< p_par30[j]/CLHEP::GeV <<" p_mu30 "<<p_mu30[j]/CLHEP::GeV<<" x_mu30 "<<x_mu30[j]/CLHEP::m<<" p_nu30 "<<p_nu30[j]/CLHEP::GeV<<
	     " class "<<class_par30[j]<<" id_par30 "<<id_par30[j]<<G4endl;
  }
  if(n31)G4cout << "Decay 31: "<<n31<<G4endl;
  for(int j=0;j<n31;j++){
    if(n31)G4cout << j <<" p_par31 "<< p_par31[j]/CLHEP::GeV <<" p_mu31 "<<p_mu31[j]/CLHEP::GeV<<" x_mu31 "<<x_mu31[j]/CLHEP::m<<" p_nu31 "<<p_nu31[j]/CLHEP::GeV<<
	     " class "<<class_par31[j]<<" id_par31 "<<id_par31[j]<<G4endl;
  }
}
#include "SBEventActionMessenger.hh"

#include "SBEventAction.hh"
#include "G4UIdirectory.hh"
#include "G4UIcmdWithADouble.hh"
#include "G4UIcmdWithAnInteger.hh"

#include "globals.hh"

SBEventActionMessenger::SBEventActionMessenger(SBEventAction* EvAct)
:eventAction(EvAct)
{
  eventDir = new G4UIdirectory("/SB/event/");
  eventDir->SetGuidance("event control");
   
  PrintCmd = new G4UIcmdWithAnInteger("/SB/event/printModulo",this);
  PrintCmd->SetGuidance("Print events modulo n");
  PrintCmd->SetParameterName("EventNb",false);
  PrintCmd->SetRange("EventNb>0");

  EKinProtCmd = new G4UIcmdWithADouble("/SB/event/SetEKinProt",this);
  EKinProtCmd->SetGuidance("Set incoming protons kinetic energy (for normalization to power only)");
  EKinProtCmd->SetParameterName("EKinProt",false);
  EKinProtCmd->SetRange("EKinProt>0");

  PowerCmd = new G4UIcmdWithADouble("/SB/event/SetPower",this);
  PowerCmd->SetGuidance("Set proton power in MW (for fluxes normalization)");
  PowerCmd->SetParameterName("Power",false);
  PowerCmd->SetRange("Power>0");

  SBVerbosityCmd = new G4UIcmdWithAnInteger("/SB/event/verbosity",this);
  SBVerbosityCmd->SetGuidance("verbosity level");
  SBVerbosityCmd->SetParameterName("SBVerbosity",false);
  SBVerbosityCmd->SetRange("SBVerbosity>=0");

}

SBEventActionMessenger::~SBEventActionMessenger()
{
  delete PrintCmd;
  delete SBVerbosityCmd;
  delete EKinProtCmd;
  delete PowerCmd;
  delete eventDir;
}

void SBEventActionMessenger::SetNewValue(G4UIcommand* command,G4String newValue)
{
  if(command == PrintCmd)
    {eventAction->SetPrintModulo(PrintCmd->GetNewIntValue(newValue));}

  if(command == EKinProtCmd)
    {eventAction->SetEKinProt(EKinProtCmd->GetNewDoubleValue(newValue));}

  if(command == PowerCmd)
    {eventAction->SetPower(PowerCmd->GetNewDoubleValue(newValue));}

  if(command == SBVerbosityCmd)
    {eventAction->SetSBVerbosity(PrintCmd->GetNewIntValue(newValue));}
}
#include "G4UnitsTable.hh"
#include "CLHEP/Units/SystemOfUnits.h"
#include "SBField.hh"
#include "SBDetectorConstruction.hh"

//SBField::SBField(G4double I_OneHornIntensity, G4int hID, SBDetectorConstruction* SBDC):SBDetector(SBDC)
SBField::SBField(G4double I_OneHornIntensity, G4int hID, SBDetectorConstruction* SBDC)
{
  //I0 = 300000.*ampere;
  //R0 = 4.*cm;//InCondRad[0] + InCondDepth[1];
  I0=I_OneHornIntensity;
  G4double MU04PI = 1.e-7*(CLHEP::tesla*CLHEP::m)/CLHEP::ampere;      ///(µ0/4Pi)
  K0=MU04PI *2.*I0;

  G4cout << "I0 = " <<I0/CLHEP::ampere <<" A "<<G4endl; 

  x0 = SBDC->Horn_xpos;                                               ////(modif)
  y0 = SBDC->Horn_ypos;                                               ////(modif)

  G4cout << " Horn Id    = " << hID << G4endl ; 
  
  if(hID==0){x0*=1.;y0*=1.;}
  if(hID==1){x0*=-1.;y0*=1.;}                                                        //
  if(hID==2){x0*=1.;y0*=-1.;}                                                        //
  if(hID==3){x0*=-1.;y0*=-1.;}                                                //

  //G4cout << " Horn_xpos = " <<  x0 << " cm ; Horn_ypos = " << y0 << G4endl;
  G4cout <<"SBField: Horn position (x,y) cm "<< x0/CLHEP::cm <<" "<<y0/CLHEP::cm<<G4endl;
}

SBField::~SBField(){;}

void SBField::GetFieldValue(const G4double point[3],G4double *Bfield) const
{
  G4bool DEB=false;
  //G4bool DEB=true;
  G4double r = 0*CLHEP::cm;
  // COrrect value for r
  r=sqrt(((point[0]-x0)*(point[0]-x0))+((point[1]-y0)*(point[1]-y0)));
  
  // Test Value
  //r=sqrt((point[0]*point[0])+(point[1]*point[1]));
  
  //G4cout << " Get Field Value ; Horn_xpos = " <<  x0 << " cm ; Horn_ypos = " << y0 << G4endl;
  //G4cout << " Rayon r = " << r << G4endl;
  
  if(r>1*CLHEP::cm) //if((sqr(point[0])+sqr(point[1]))<rmax_sq)
  {
    Bfield[0] = -(K0/r)*((point[1]-y0)/r);
    Bfield[1] =  (K0/r)*((point[0]-x0)/r);
    Bfield[2] = 0;
        
  } else { 
    Bfield[0] = 0.;
    Bfield[1] = 0.;
    Bfield[2] = 0.;
     
  }

  if(DEB)G4cout <<"x "<<point[0]/CLHEP::cm<<" (cm) y "<<point[1]/CLHEP::cm<<" (cm) z "<<point[2]/CLHEP::cm<<" (cm) Bx " << Bfield[0]/CLHEP::tesla <<" (T) By "<<Bfield[1]/CLHEP::tesla<<" (T) Bz "<<Bfield[2]/CLHEP::tesla<<" (T)"<<G4endl;

}
#include "SBPhysicsList.hh"

#include "G4ProcessManager.hh"
#include "G4ParticleTypes.hh"

SBPhysicsList::SBPhysicsList():  G4VUserPhysicsList()
{
  defaultCutValue = 1.0*CLHEP::mm;
  SetVerboseLevel(1);
}

SBPhysicsList::~SBPhysicsList()
{}

void SBPhysicsList::ConstructParticle()
{
  // In this method, static member functions should be called
  // for all particles which you want to use.
  // This ensures that objects of these particle types will be
  // created in the program. 

  ConstructBosons();
  ConstructLeptons();
  ConstructMesons();
  ConstructBaryons();
}

void SBPhysicsList::ConstructBosons()
{
  // pseudo-particles
  G4Geantino::GeantinoDefinition();
  G4ChargedGeantino::ChargedGeantinoDefinition();

  // gamma
  G4Gamma::GammaDefinition();

  // optical photon
  G4OpticalPhoton::OpticalPhotonDefinition();
}

void SBPhysicsList::ConstructLeptons()
{
  // leptons
  G4Electron::ElectronDefinition();
  G4Positron::PositronDefinition();
  G4MuonPlus::MuonPlusDefinition();
  G4MuonMinus::MuonMinusDefinition();

  G4NeutrinoE::NeutrinoEDefinition();
  G4AntiNeutrinoE::AntiNeutrinoEDefinition();
  G4NeutrinoMu::NeutrinoMuDefinition();
  G4AntiNeutrinoMu::AntiNeutrinoMuDefinition();
}

void SBPhysicsList::ConstructMesons()
{
 //  mesons
  G4PionPlus::PionPlusDefinition();
  G4PionMinus::PionMinusDefinition();
  G4PionZero::PionZeroDefinition();
  G4Eta::EtaDefinition();
  G4EtaPrime::EtaPrimeDefinition();
  G4KaonPlus::KaonPlusDefinition();
  G4KaonMinus::KaonMinusDefinition();
  G4KaonZero::KaonZeroDefinition();
  G4AntiKaonZero::AntiKaonZeroDefinition();
  G4KaonZeroLong::KaonZeroLongDefinition();
  G4KaonZeroShort::KaonZeroShortDefinition();
}

void SBPhysicsList::ConstructBaryons()
{
  //  barions
  G4Proton::ProtonDefinition();
  G4AntiProton::AntiProtonDefinition();
  G4Neutron::NeutronDefinition();
  G4AntiNeutron::AntiNeutronDefinition();
}

void SBPhysicsList::ConstructProcess()
{
  AddTransportation();
  ConstructEM();
  ConstructDecay();
}

#include "G4ComptonScattering.hh"
#include "G4GammaConversion.hh"
#include "G4PhotoElectricEffect.hh"

#include "G4eMultipleScattering.hh"
#include "G4hMultipleScattering.hh"

#include "G4eIonisation.hh"
#include "G4eBremsstrahlung.hh"
#include "G4eplusAnnihilation.hh"

#include "G4MuIonisation.hh"
#include "G4MuBremsstrahlung.hh"
#include "G4MuPairProduction.hh"

#include "G4hIonisation.hh"
#include "G4hBremsstrahlung.hh"
#include "G4hPairProduction.hh"

#include "G4ionIonisation.hh"

void SBPhysicsList::ConstructEM()
{
  theParticleIterator->reset();
  while( (*theParticleIterator)() ){
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    G4String particleName = particle->GetParticleName();
    
    if (particleName == "gamma") {
      // gamma         
      pmanager->AddDiscreteProcess(new G4PhotoElectricEffect);
      pmanager->AddDiscreteProcess(new G4ComptonScattering);
      pmanager->AddDiscreteProcess(new G4GammaConversion);
      
    } else if (particleName == "e-") {
      //electron
      pmanager->AddProcess(new G4eMultipleScattering,-1, 1, 1);
      pmanager->AddProcess(new G4eIonisation,        -1, 2, 2);
      pmanager->AddProcess(new G4eBremsstrahlung,    -1, 3, 3);      

    } else if (particleName == "e+") {
      //positron
      pmanager->AddProcess(new G4eMultipleScattering,-1, 1, 1);
      pmanager->AddProcess(new G4eIonisation,        -1, 2, 2);
      pmanager->AddProcess(new G4eBremsstrahlung,    -1, 3, 3);
      pmanager->AddProcess(new G4eplusAnnihilation,   0,-1, 4);
    
    } else if( particleName == "mu+" || 
               particleName == "mu-"    ) {
      //muon  
      pmanager->AddProcess(new G4hMultipleScattering,-1, 1, 1);
      pmanager->AddProcess(new G4MuIonisation,       -1, 2, 2);
      pmanager->AddProcess(new G4MuBremsstrahlung,   -1, 3, 3);
      pmanager->AddProcess(new G4MuPairProduction,   -1, 4, 4);
             
    } else if( particleName == "proton" ||
               particleName == "pi-" ||
               particleName == "pi+"    ) {
      //proton  
      pmanager->AddProcess(new G4hMultipleScattering, -1, 1, 1);
      pmanager->AddProcess(new G4hIonisation,         -1, 2, 2);
      pmanager->AddProcess(new G4hBremsstrahlung,     -1, 3, 3);
      pmanager->AddProcess(new G4hPairProduction,     -1, 4, 4);       
     
    } else if( particleName == "alpha" || 
	       particleName == "He3" || 
	       particleName == "GenericIon" ) {
      //Ions 
      pmanager->AddProcess(new G4hMultipleScattering, -1, 1, 1);
      pmanager->AddProcess(new G4ionIonisation,       -1, 2, 2);
      
      } else if ((!particle->IsShortLived()) &&
	       (particle->GetPDGCharge() != 0.0) && 
	       (particle->GetParticleName() != "chargedgeantino")) {
      //all others charged particles except geantino
      pmanager->AddProcess(new G4hMultipleScattering,-1, 1, 1);
      pmanager->AddProcess(new G4hIonisation,        -1, 2, 2);        
    }     
  }
}

#include "G4Decay.hh"

void SBPhysicsList::ConstructDecay()
{
  // Add Decay Process
  G4Decay* theDecayProcess = new G4Decay();
  theParticleIterator->reset();
  while( (*theParticleIterator)() ){
    G4ParticleDefinition* particle = theParticleIterator->value();
    G4ProcessManager* pmanager = particle->GetProcessManager();
    if (theDecayProcess->IsApplicable(*particle)) { 
      pmanager ->AddProcess(theDecayProcess);
      // set ordering for PostStepDoIt and AtRestDoIt
      pmanager ->SetProcessOrdering(theDecayProcess, idxPostStep);
      pmanager ->SetProcessOrdering(theDecayProcess, idxAtRest);
    }
  }
}

void SBPhysicsList::SetCuts()
{
  if (verboseLevel >0){
    G4cout << "SBPhysicsList::SetCuts:";
    G4cout << "CutLength : " << G4BestUnit(defaultCutValue,"Length") << G4endl;
  }

  // set cut values for gamma at first and for e- second and next for e+,
  // because some processes for e+/e- need cut values for gamma
  //
  SetCutValue(defaultCutValue, "gamma");
  SetCutValue(defaultCutValue, "e-");
  SetCutValue(defaultCutValue, "e+");

// andrea prova ..
//SetCutValue(defaultCutValue, "pi-");
//SetCutValue(defaultCutValue, "pi+");
//

  if (verboseLevel>0) DumpCutValuesTable();
}

#include "SBPrimaryGeneratorAction.hh"

#include "SBDetectorConstruction.hh"
#include "SBPrimaryGeneratorMessenger.hh"
#include "SBRunAction.hh"

#include "G4Event.hh"
#include "G4HEPEvtInterface.hh"

#include "G4ParticleGun.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "G4KaonZero.hh"
#include "Randomize.hh"
#include "TMath.h"

using namespace TMath;

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

SBPrimaryGeneratorAction::SBPrimaryGeneratorAction(/*SBRunAction* run,*/SBDetectorConstruction* SBDC) 
  :/*runAct(run),*/ 
  SBDetector(SBDC),
  rndmFlag("off")
  /*,filenamein("FLUKAcard001_input_PIONSONLY.dat")*/
{
  G4cout<<"CALL SBPrimaryGeneratorAction::SBPrimaryGeneratorAction "<<G4endl;
   
  //create a messenger for this class
  gunMessenger = new SBPrimaryGeneratorMessenger(this);

  // temporary!!!
  //ExtGen=0;

  procEvts = 0;
  procTracks = 0;
  OLDidev = 0;

  K_REPL=1;//kaon replication

  //if(!externalGEN){
    
  G4int n_particle = 1;
  particleGun  = new G4ParticleGun(n_particle);
   
  
  // Default particle kinematic..................................................................
  G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
  //G4String particleName;
  G4ParticleDefinition* particle = particleTable->FindParticle(particleName="proton");
  //G4ParticleDefinition* particle = particleTable->FindParticle(particleName="chargedgeantino");  ////pi+
  particleGun->SetParticleDefinition(particle);
  
  x0 = 100.*CLHEP::cm;                                               
  y0 = 100.*CLHEP::cm;                                               
  G4double z0 = SBDetector->GetTargetZetaPos()-0.5*SBDetector->GetTargetThickness()-500;
  gunEKin = 4.5*CLHEP::GeV;

  particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
  particleGun->SetParticlePosition(G4ThreeVector(x0,y0,z0));  
  particleGun->SetParticleEnergy(gunEKin);        
    
  particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
  particleGun->SetParticlePosition(G4ThreeVector(-x0,y0,z0));  
  particleGun->SetParticleEnergy(gunEKin); 
     
  particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
  particleGun->SetParticlePosition(G4ThreeVector(x0,-y0,z0));  
  particleGun->SetParticleEnergy(gunEKin);
  
  particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
  particleGun->SetParticlePosition(G4ThreeVector(-x0,-y0,z0));  
  particleGun->SetParticleEnergy(gunEKin);
  
  G4cout <<"SBPrimaryGenerationAction::SBPrimaryGeneratorAction gun kinetic energy is "<< gunEKin/CLHEP::GeV <<" GeV. "<<G4endl;
  

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

SBPrimaryGeneratorAction::~SBPrimaryGeneratorAction()
{
  G4cout<<"CALL SBPrimaryGeneratorAction::~SBPrimaryGeneratorAction "<<G4endl;
  fin.close();

  G4cout<<"SBPrimaryGenerationAction: TOTAL processed events: "<<procEvts<<" (may be different from FLUKA pots if preselection is applied in the input file)"<<G4endl;
  G4cout<<"SBPrimaryGenerationAction: TOTAL processed single tracks: "<<procTracks<<G4endl;

  delete particleGun;
  delete gunMessenger;
  delete HEPEvt;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo

void SBPrimaryGeneratorAction::GeneratePrimaries(G4Event* anEvent)
{
  G4cout<<"========================================================"<<G4endl;
  G4cout<<"===============   S  T  A  R  T  ======================="<<G4endl;
  G4cout<<"========================================================"<<G4endl;

  G4cout<<"CALL SBPrimaryGeneratorAction::GeneratePrimaries "<<G4endl;
  //this function is called at the begining of event

  if(ExtGen==1)externalGEN=true;
  if(ExtGen==0)externalGEN=false;
  
  //externalGEN=true;

  myEOF=false;
  
  //G4cout <<"EVENTID "<< anEvent->GetEventID() << G4endl;
  G4int evid =anEvent->GetEventID();
  
  if(evid==0){
    G4cout << ExtGen <<" GENERATOR"<<G4endl;
    if(externalGEN)G4cout<<"SBPrimaryGeneratorAction USING EXTERNAL GENERATOR"<<G4endl;
    if(!externalGEN)G4cout<<"SBPrimaryGeneratorAction USING GEANT4 GENERATOR"<<G4endl;  
  }

  if(externalGEN){
    if(evid==0){
      InputFileOK=true;
      G4cout <<"SBPrimaryGenerationAction: Opening input ASCII file" << filenamein <<" " <<fin.fail()<<G4endl;
      fin.open(filenamein);
      if(fin.fail()){
	G4cout <<"SBPrimaryGenerationAction: Input ASCII file "<<filenamein <<" NOT found. Check name in control card (.mac). Exiting." << G4endl;
	InputFileOK=false;
	return;
      } else {
	G4cout <<"SBPrimaryGenerationAction: Opened input ASCII file" << filenamein <<" "<<fin.fail()<< G4endl;
      }
    }

    if(!InputFileOK){
      G4cout << "SBPrimaryGenerationAction: problem with input ASCII file "<< filenamein << G4endl;
      return;
    }

  }// externalGEN

   
  //G4double x0 = 100.*CLHEP::cm;                                               
  //G4double y0 = 100.*CLHEP::cm;                                               
  G4double z0 = SBDetector->GetTargetZetaPos()-0.5*SBDetector->GetTargetThickness()-500;
  //G4double gunEKin = 4.5*GeV; 

  //G4double z0=SBDetector->GetTargetZetaPos()-0.5*SBDetector->GetTargetThickness();                           //ok
  //G4double z0=SBDetector->GetTargetZetaPos();                    ///centre cible                                                           
  //G4cout <<"INPUT "<< rndmFlag << " " << filenamein << G4endl;

  if (rndmFlag == "on"){
    y0 = (SBDetector->GetTargetDiameter())*(G4UniformRand()-0.5);
    z0 = (SBDetector->GetTargetDiameter())*(G4UniformRand()-0.5);
  }  

  G4cout<<"0 "<<G4endl;

  //externalGEN=true;
  //externalGEN=false;
 
  if(!externalGEN){

    //SBEventAction* ea = new SBEventAction();
    if(evid==0)G4cout << "SBPrimaryGenerationAction: Using ParticleGun for primary generations"<< G4endl;

    //G4cout <<"externalgen"<<G4endl;

    G4ParticleTable* partTab = G4ParticleTable::GetParticleTable();
    G4ParticleDefinition* mypart;
    mypart = partTab->FindParticle("proton");
    //mypart = partTab->FindParticle("chargedgeantino");  //chargedgeantino                                                
    particleGun->SetParticleDefinition(mypart);
   

    //============================================================================
    //isotropic random....
    //G4double cosTheta = -1.0+2.0*G4UniformRand();                          
    //G4double phi = twopi*G4UniformRand();                                                                         
    //G4double sinTheta = sqrt(1-cosTheta*cosTheta);                                                                
    //particleGun -> SetParticleMomentumDirection(G4ThreeVector(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta));    

    //solid angle random....    
    //G4double sigangle1=30.0*deg;
    //G4double angle1=(G4UniformRand()-0.5)*sigangle1;
    //G4double sigangle2=30.0*deg;
    //G4double angle2=(G4UniformRand()-0.5)*sigangle2;
    //particleGun->SetParticleMomentumDirection(G4ThreeVector(sin(angle1),sin(angle2),1.));
    //============================================================================ 
 
    //particleGun->SetParticleMomentumDirection(G4ThreeVector(sin(angle1),sin(angle2),1.));
    particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
    particleGun->SetParticlePosition(G4ThreeVector(x0,y0,z0));
    particleGun->SetParticleEnergy(gunEKin);
    G4cout <<"SBPrimaryGenerationAction: gun kinetic energy is "<< gunEKin/CLHEP::GeV <<" GeV. "<<G4endl;
    particleGun->GeneratePrimaryVertex(anEvent);

    //particleGun->SetParticleMomentumDirection(G4ThreeVector(sin(angle1),sin(angle2),1.));
    particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
    particleGun->SetParticlePosition(G4ThreeVector(-x0,y0,z0));  
    G4cout <<"SBPrimaryGenerationAction: gun kinetic energy is "<< gunEKin/CLHEP::GeV <<" GeV. "<<G4endl;
    particleGun->SetParticleEnergy(gunEKin); 
    particleGun->GeneratePrimaryVertex(anEvent);
   
    particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
    //particleGun->SetParticleMomentumDirection(G4ThreeVector(sin(angle1),sin(angle2),1.));
    particleGun->SetParticlePosition(G4ThreeVector(x0,-y0,z0));  
    G4cout <<"SBPrimaryGenerationAction: gun kinetic energy is "<< gunEKin/CLHEP::GeV <<" GeV. "<<G4endl;
    particleGun->SetParticleEnergy(gunEKin);
    particleGun->GeneratePrimaryVertex(anEvent);

    particleGun->SetParticleMomentumDirection(G4ThreeVector(0.,0.,1.));
    //particleGun->SetParticleMomentumDirection(G4ThreeVector(sin(angle1),sin(angle2),1.));
    particleGun->SetParticlePosition(G4ThreeVector(-x0,-y0,z0));  
    G4cout <<"SBPrimaryGenerationAction: gun kinetic energy is "<< gunEKin/CLHEP::GeV <<" GeV. "<<G4endl;
    particleGun->SetParticleEnergy(gunEKin);
    particleGun->GeneratePrimaryVertex(anEvent);   
 

                                 
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    G4cout << "SBPrimaryGenerationAction: GEANT4 primary vtx =( "<<x0/CLHEP::cm<<", "<<y0/CLHEP::cm<<", "<<z0/CLHEP::cm<<" ) (cm)"<< G4endl;
    FLUKApots=FLUKApots+1.;

    G4cout << "SBPrimaryGenerationAction: nK+ "<<n_kplus_exit<<G4endl;
    G4cout << "SBPrimaryGenerationAction: nK- "<<n_kminus_exit<<G4endl;
    G4cout << "SBPrimaryGenerationAction: nK0S "<<n_k0s_exit<<G4endl;
    G4cout << "SBPrimaryGenerationAction: nK0L "<<n_k0l_exit<<G4endl;

    //G4int K_REPL=20;
    G4cout << "SBPrimaryGenerationAction: REPLICATE kaons "<<K_REPL-1<<" times."<<G4endl;

    G4double kekin=0;
    
    mypart = partTab->FindParticle("kaon+");
    particleGun->SetParticleDefinition(mypart);
    for(int ii=0;ii<n_kplus_exit;ii++){
      G4cout<<"k+ "<<x_kplus_exit[ii]<<" "<<y_kplus_exit[ii]<<" "<<z_kplus_exit[ii]<<" "<<px_kplus_exit[ii]<<" "<<py_kplus_exit[ii]<<" "<<pz_kplus_exit[ii]<<G4endl;
      particleGun->SetParticleMomentumDirection(G4ThreeVector(px_kplus_exit[ii],py_kplus_exit[ii],pz_kplus_exit[ii]));
      particleGun->SetParticlePosition(G4ThreeVector(x_kplus_exit[ii],y_kplus_exit[ii],z_kplus_exit[ii]));
      kekin = sqrt(pow(px_kplus_exit[ii],2)+pow(py_kplus_exit[ii],2)+pow(pz_kplus_exit[ii],2))-mypart->GetPDGMass();
      particleGun->SetParticleEnergy(kekin);
      for(int ll=0;ll<K_REPL-1;ll++){   
	particleGun->GeneratePrimaryVertex(anEvent);
      }
    }
    mypart = partTab->FindParticle("kaon-");
    particleGun->SetParticleDefinition(mypart);    
    for(int ii=0;ii<n_kminus_exit;ii++){
      G4cout<<"k- "<<x_kminus_exit[ii]<<" "<<y_kminus_exit[ii]<<" "<<z_kminus_exit[ii]<<" "<<px_kminus_exit[ii]<<" "<<py_kminus_exit[ii]<<" "<<pz_kminus_exit[ii]<<G4endl;
      particleGun->SetParticleMomentumDirection(G4ThreeVector(px_kminus_exit[ii],py_kminus_exit[ii],pz_kminus_exit[ii]));
      particleGun->SetParticlePosition(G4ThreeVector(x_kminus_exit[ii],y_kminus_exit[ii],z_kminus_exit[ii]));
      kekin = sqrt(pow(px_kminus_exit[ii],2)+pow(py_kminus_exit[ii],2)+pow(pz_kminus_exit[ii],2))-mypart->GetPDGMass();
      particleGun->SetParticleEnergy(kekin);
      for(int ll=0;ll<K_REPL-1;ll++){   
	particleGun->GeneratePrimaryVertex(anEvent);
      }
    }
    mypart = partTab->FindParticle("kaon0S");
    particleGun->SetParticleDefinition(mypart);    
    for(int ii=0;ii<n_k0s_exit;ii++){
      G4cout<<"k0s "<<x_k0s_exit[ii]<<" "<<y_k0s_exit[ii]<<" "<<z_k0s_exit[ii]<<" "<<px_k0s_exit[ii]<<" "<<py_k0s_exit[ii]<<" "<<pz_k0s_exit[ii]<<G4endl;
      particleGun->SetParticleMomentumDirection(G4ThreeVector(px_k0s_exit[ii],py_k0s_exit[ii],pz_k0s_exit[ii]));
      particleGun->SetParticlePosition(G4ThreeVector(x_k0s_exit[ii],y_k0s_exit[ii],z_k0s_exit[ii]));
      kekin = sqrt(pow(px_k0s_exit[ii],2)+pow(py_k0s_exit[ii],2)+pow(pz_k0s_exit[ii],2))-mypart->GetPDGMass();
      particleGun->SetParticleEnergy(kekin);
      for(int ll=0;ll<K_REPL-1;ll++){   
	particleGun->GeneratePrimaryVertex(anEvent);
      }
    }
    mypart = partTab->FindParticle("kaon0L");
    particleGun->SetParticleDefinition(mypart);    
    for(int ii=0;ii<n_k0l_exit;ii++){
      G4cout<<"k0l "<<x_k0l_exit[ii]<<" "<<y_k0l_exit[ii]<<" "<<z_k0l_exit[ii]<<" "<<px_k0l_exit[ii]<<" "<<py_k0l_exit[ii]<<" "<<pz_k0l_exit[ii]<<G4endl;
      particleGun->SetParticleMomentumDirection(G4ThreeVector(px_k0l_exit[ii],py_k0l_exit[ii],pz_k0l_exit[ii]));
      particleGun->SetParticlePosition(G4ThreeVector(x_k0l_exit[ii],y_k0l_exit[ii],z_k0l_exit[ii]));
      kekin = sqrt(pow(px_k0l_exit[ii],2)+pow(py_k0l_exit[ii],2)+pow(pz_k0l_exit[ii],2))-mypart->GetPDGMass();
      particleGun->SetParticleEnergy(kekin);
      for(int ll=0;ll<K_REPL-1;ll++){   
	particleGun->GeneratePrimaryVertex(anEvent);
      }
    }

    n_kplus_exit=0;
    n_kminus_exit=0;
    n_k0s_exit=0;
    n_k0l_exit=0;

    //////////////////////////////////////////////////////////////////////////////////////////////
  } else {
    if(evid==0)G4cout << "SBPrimaryGenerationAction: using ASCII file input for primary generations"<< G4endl;

    G4cout<<"1 "<<G4endl;

    //G4double Dz_a_mano=100*CLHEP::cm;
    double idev=0,pid=0,x=0*CLHEP::cm,y=0*CLHEP::cm,z=0*CLHEP::cm,px=0*CLHEP::GeV,py=0*CLHEP::GeV,pz=0*CLHEP::GeV,dum0=0,dum1=0,dum2=0;

    //while(!fin.eof()){
    //while(fin.good()){
    if(fin.eof())myEOF=true;
    fin >> idev >> pid >> x >> y >> z >> px >> py >> pz >> dum0 >> dum1 >> dum2;
    G4cout<<"2 "<<G4endl;
    //POT_id=idev;
    //G4cout <<" "<< idev <<" "<< pid <<" "<< x <<" "<< y <<" "<< z <<" "<< px <<" "<< py <<" "<< pz <<" "<< dum0 <<" "<< dum1 <<" "<< dum2<<G4endl;
    //mypid=translate_FLUKA_code(pid);
    //mymass=mass_from_FLUKA_code(pid);      
    //G4cout<<"ooo "<<idev<<" "<<OLDidev<<" "<<procEvts<<" "<<procTracks<<G4endl;      
    //if(sqrt(px*px+py*py+pz*pz)<0.24){
    //  G4cout <<"LOWEN "<< idev <<" "<< pid <<" "<< x <<" "<< y <<" "<< z <<" "<< px <<" "<< py <<" "<< pz <<" "<< dum0 <<" "<< dum1 <<" "<< dum2<<G4endl;
    //}

    if(idev!=0)FLUKApots = idev;// NB. here FLUKa evt ID is assumed to start from zero!!!
      
    if(idev!=OLDidev){
      procEvts++;
      OLDidev=idev;
    }
    procTracks++;
      
    // !!!! NB definire ogni volta che particella e'!!!!
    G4cout<<"3 "<<G4endl;
    particleName="pi-";
    G4double mass = 0.139*CLHEP::GeV;
      
    //particleName=Fluka2G4_part_name(pid);
      
    bool skip = false;
      
    //     translate the FLUKA pid into geant pid.
    /*
      InputPid -6 
      47          ! He4
      InputPid -5 
      49          ! He3
      InputPid -4 
      46          ! t
      InputPid -3 
      45          ! d
      InputPid -2 
      48
      write(6,*'GUKINE: unknow particle ',InputPid
      InputPid -1 
      1           ! photon
      InputPid 1 
      14          !proton
      InputPid 2 
      15          !antiproton
      InputPid 3 
      3           !electron
      InputPid 4 
      2           !positron
      InputPid 5 
      4           !antineutrino
      InputPid 6 
      4           !neutrino
      InputPid 7 
      1           !photon
      InputPid 8 
      13          !neutron
      InputPid 9 
      25          !antineutron
      InputPid 10 
      5           !mu+
      InputPid 11 
      6           !mu-
      InputPid 12 
      10          !K0 long
      isFromKaon = 2
      InputPid 13 
      8           !pi+
      InputPid 14 
      9           !pi-
      InputPid 15 
      11          !K+
      isFromKaon = 1
      InputPid 16 
      12          !K-
      isFromKaon = 1
      InputPid 17 
      18          !Lambda
      InputPid 18 
      16          ! K0 short
      isFromKaon = 2
      InputPid 20 
      21          !sigma-
      InputPid 21 
      19          !sigma+
      InputPid 22 
      20          !sigma0
      InputPid 23 
      7           !pi0
      InputPid 24 
      if(RNDM(DUMMY.gt.0.5 then
      10       !K0 long
      else
      16       !K0 short
      endif
      isFromKaon = 2
         
      write(6,*'GUKINE: ERROR unknow fluka particle ',InputPid
      ENDIF
    */
    G4bool Antoine = false;
    if(Antoine){
      if(pid==-3)particleName="deuteron";
      else if(pid==-4)particleName="triton";
      else if(pid==-6)particleName="alpha";
      else if(pid==1)particleName="proton";
      else if(pid==2)particleName="anti_proton";//check name
      else if(pid==3)particleName="e-";
      else if(pid==4)particleName="e+";
      else if(pid==7)particleName="gamma";
      else if(pid==8)particleName="neutron";
      else if(pid==9)particleName="anti_neutron";//check name
      else if(pid==10)particleName="mu+";
      else if(pid==11)particleName="mu-";
      else if(pid==12)particleName="kaon0L";
      else if(pid==13)particleName="pi+";
      else if(pid==14)particleName="pi-";
      else if(pid==15)particleName="kaon+";
      else if(pid==16)particleName="kaon-";
      else if(pid==17)particleName="lambda";//check name
      else if(pid==18)particleName="kaon0S";//? 18 in converison by Antoine gukine.F
      //else if(pid==19)particleName="kaon0S";//
      else if(pid==20)particleName="sigma-";//check name
      else if(pid==21)particleName="sigma+";//check name
      else if(pid==22)particleName="sigma0";//check name
      else if(pid==23)particleName="pi0";
      else if(pid==24)particleName="kaon0";
      //else if(pid==25)particleName="anti_kaon0";
      else {
	G4cout << "SBPrimaryGenerationAction: FLUKA track with pid " << pid <<" will not be not tracked by GEANT4 " << G4endl;
	skip=true;
      }
    }else{
      if(pid==-3)particleName="deuteron";
      else if(pid==-4)particleName="triton";
      else if(pid==-6)particleName="alpha";
      else if(pid==1)particleName="proton";
      else if(pid==2)particleName="anti_proton";//check name
      else if(pid==3)particleName="e-";
      else if(pid==4)particleName="e+";
      else if(pid==7)particleName="gamma";
      else if(pid==8)particleName="neutron";
      else if(pid==9)particleName="anti_neutron";//check name
      else if(pid==10)particleName="mu+";
      else if(pid==11)particleName="mu-";
      else if(pid==12)particleName="kaon0L";
      else if(pid==13)particleName="pi+";
      else if(pid==14)particleName="pi-";
      else if(pid==15)particleName="kaon+";
      else if(pid==16)particleName="kaon-";
      else if(pid==17)particleName="lambda";//check name
      else if(pid==18)particleName="anti_lambda";//check name
      else if(pid==19)particleName="kaon0S";//? check 18 in converison by Antoine gukine.F
      else if(pid==20)particleName="sigma-";//check name
      else if(pid==21)particleName="sigma+";//check name
      else if(pid==22)particleName="sigma0";//check name
      else if(pid==23)particleName="pi0";
      else if(pid==24)particleName="kaon0";
      else if(pid==25)particleName="anti_kaon0";
      else {
	G4cout << "SBPrimaryGenerationAction: FLUKA track with pid " << pid <<" will not be not tracked by GEANT4 " << G4endl;
	skip=true;
      }
    }
 
    G4cout<<"4 "<<particleName<<G4endl;
    //if(particleName=="kaon0")particleName="anti_kaon0";//TMP 

    G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
    G4ParticleDefinition* particle = particleTable->FindParticle(particleName);

    G4cout<<"4a "<<particle<<G4endl;
    if(particleName=="kaon0")G4cout<<"kaon0 shoot"<<G4endl;

    //if(particleName=="kaon0")particle=G4KaonZero::KaonZero();

    particleGun->SetParticleDefinition(particle);

    //particleGun->SetParticleDefinition(G4ParticleTable::GetParticleTable()->->FindParticle(particleName));
      
    mass=particle->GetPDGMass();
    G4cout<<"5 "<<G4endl;

    //tmp! shoot only muons =========
    //G4cout <<"MUON SHOOTING"<<G4endl;
    //particle = particleTable->FindParticle("mu+");
    //particleGun->SetParticleDefinition(particle);
    //mass=0.105*CLHEP::GeV;
    //px=0;
    //py=0;
    //pz=0.001*CLHEP::GeV*G4UniformRand();
    //===============================      

    px*=1000;
    py*=1000;
    pz*=1000;
      
    x*=10;
    y*=10;
    z*=10;
      
    XPrimary=x;
    YPrimary=y;
    ZPrimary=z;
    PXPrimary=px;
    PYPrimary=py;
    PZPrimary=pz;
      
    ZPrimary_G4frame=z+z0;
      
    G4double En = sqrt((mass*mass)+(px*px)+(py*py)+(pz*pz));
    G4double Ekin = En - mass;
      
    //z=z+z0+Dz_a_mano;
      
    G4cout << "FLUKA ID evt "<< idev <<" "<< particleName << G4endl;
    G4cout << "ASCII: x "<< x/CLHEP::cm <<
      " y "<< y/CLHEP::cm <<
      " z "<< z/CLHEP::cm <<" cm"<<G4endl; 
      

    //G4double xsam=G4UniformRand()-0.5;
    //G4double ysam=G4UniformRand()-0.5;

    //G4cout << "gigio x: " << x/CLHEP::cm << " x0: "<< x0/CLHEP::cm <<" r: "<<sqrt((x*x)+(y*y))/CLHEP::cm<<" cm"<<G4endl;
      
/*
    if(SBDetector->GetInj()==0){//just one horn at a time
      x=x+x0;
      y=y+y0;	
    } else if(SBDetector->GetInj()==1){// all horns simultaneously
      x=x+((Abs(xsam)/xsam)*x0);
      y=y+((Abs(ysam)/ysam)*y0);
    }

    z=z+z0;
*/

    G4cout << "DETECTOR COORD: x "<< x/CLHEP::cm <<
      " y "<< y/CLHEP::cm <<
      " z "<< z/CLHEP::cm <<" cm"<<G4endl; 

    //G4cout << "z0 "<< z0/CLHEP::cm <<" cm"<< G4endl;
    G4cout << "z detector "<< z/CLHEP::cm <<" cm"<< G4endl;
    G4cout << "m "<< mass/CLHEP::GeV <<" GeV"<< G4endl;
    G4cout << "px "<< px/CLHEP::GeV <<" GeV"<< G4endl;
    G4cout << "py "<< py/CLHEP::GeV <<" GeV"<< G4endl;
    G4cout << "pz "<< pz/CLHEP::GeV <<" GeV"<< G4endl;
    G4cout << "p "<< sqrt((px*px)+(py*py)+(pz*pz))/CLHEP::GeV <<" GeV"<< G4endl;
    G4cout << "Etot "<< En/CLHEP::GeV <<" GeV"<< G4endl;
    G4cout << "Ekin "<< Ekin/CLHEP::GeV <<" GeV"<< G4endl;
      
    if(evid==0)G4cout << "SBPrimaryGenerationAction: z start of target at generation level "<< z0/CLHEP::m <<" m"<< G4endl;
      
    if(!skip){
      //if(particleName=="pi+")runAct->fillTARG(x/CLHEP::cm,y/CLHEP::cm,z/CLHEP::cm,px/GeV,py/GeV,pz/GeV,1);
      //if(particleName=="pi-")runAct->fillTARG(x/CLHEP::cm,y/CLHEP::cm,z/CLHEP::cm,px/GeV,py/GeV,pz/GeV,2);
      //if(sqrt(px*px+py*py+pz*pz)>0.24){//prova
      particleGun->SetParticleMomentumDirection(G4ThreeVector(px,py,pz));
      //particleGun->SetParticleMomentumDirection(G4ThreeVector(0,0,1));
      //particleGun->SetParticlePosition(G4ThreeVector(x*CLHEP::cm,y*CLHEP::cm,-1060*CLHEP::cm));
      particleGun->SetParticlePosition(G4ThreeVector(x,y,z));
      //particleGun->SetParticlePosition(G4ThreeVector(0*CLHEP::cm,0*CLHEP::cm,z*CLHEP::cm));
      //particleGun->SetParticleEnergy(En);
      particleGun->SetParticleEnergy(Ekin);
	

      particleGun->GeneratePrimaryVertex(anEvent);


      //
      // kaon duplication
      //
	
      //G4int K_REPL = 1;
      
      if((particleName=="kaon0")||
	 (particleName=="anti_kaon0")||
	 (particleName=="kaon+")||
	 (particleName=="kaon-")	   
	 ){
	G4cout <<"SBPrimaryGeneratorAction: "<<particleName<<" will be replicated "<<K_REPL-1<<" times."<<G4endl;
	for(int ll=0;ll<K_REPL-1;ll++){
	  G4cout<<"ciao "<<ll<<G4endl;	    
	  particleGun->GeneratePrimaryVertex(anEvent);
	}	  
      }
 

      //}
      //HEPEvt->SetParticlePosition(G4ThreeVector(x0,y0,z0+Dz_a_mano));
      //HEPEvt->GeneratePrimaryVertex(anEvent);
    }//skip
    //}//eof
  }//external generator
  
}
#include "SBPrimaryGeneratorMessenger.hh"
#include "SBPrimaryGeneratorAction.hh"
#include "G4UIdirectory.hh"
#include "G4UIcmdWithAString.hh"
#include "G4UIcmdWithAnInteger.hh"
#include "G4UIcmdWithADoubleAndUnit.hh"

SBPrimaryGeneratorMessenger::SBPrimaryGeneratorMessenger(SBPrimaryGeneratorAction* SBGun)
:SBAction(SBGun)
{
  gunDir = new G4UIdirectory("/SB/gun/");
  gunDir->SetGuidance("PrimaryGenerator control");
   
  RndmCmd = new G4UIcmdWithAString("/SB/gun/rndm",this);
  RndmCmd->SetGuidance("Shoot randomly the incident particle.");
  RndmCmd->SetGuidance("  Choice : on(default), off");
  RndmCmd->SetParameterName("choice",true);
  RndmCmd->SetDefaultValue("on");
  RndmCmd->SetCandidates("on off");
  RndmCmd->AvailableForStates(G4State_PreInit,G4State_Idle);

  ExtGenCmd = new G4UIcmdWithAnInteger("/SB/det/ExtGen",this);
  ExtGenCmd->SetGuidance("Use external generator if par is 1");
  ExtGenCmd->SetParameterName("ExtGen",true);
  ExtGenCmd->AvailableForStates(G4State_PreInit,G4State_Idle);

  gunDir1 = new G4UIdirectory("/SB/file/");
  gunDir1->SetGuidance("PrimaryGenerator input file");
   
  FileInCmd = new G4UIcmdWithAString("/SB/file/myinput",this);
  FileInCmd->SetGuidance("Input file in FLUKA style.");
  FileInCmd->SetGuidance("  Choice : FLUKAcard001_input.dat(default)");
  //FileInCmd->SetParameterName("choice",true);
  FileInCmd->SetDefaultValue("FLUKAcard001_input.dat");
  //FileInCmd->SetCandidates("pippo.dat FLUKAcard001_input.dat");
  FileInCmd->AvailableForStates(G4State_PreInit,G4State_Idle,G4State_Idle,G4State_GeomClosed,G4State_EventProc);

  x0_command = new G4UIcmdWithADoubleAndUnit("/SB/gun/Setx0",this);
  x0_command->SetGuidance("Set gun position x");
  x0_command->SetParameterName("x0",true);
  x0_command->SetUnitCategory("Length");
  x0_command->AvailableForStates(G4State_PreInit,G4State_Idle);

  y0_command = new G4UIcmdWithADoubleAndUnit("/SB/gun/Sety0",this);
  y0_command->SetGuidance("Set gun position y");
  y0_command->SetParameterName("y0",true);
  y0_command->SetUnitCategory("Length");
  y0_command->AvailableForStates(G4State_PreInit,G4State_Idle);

  EKinCmd = new G4UIcmdWithADoubleAndUnit("/SB/gun/SetEKin",this);
  EKinCmd->SetGuidance("Set kinetic energy and unit");
  EKinCmd->SetParameterName("gunEKin",true);
  EKinCmd->SetRange("gunEKin>=0.");
  EKinCmd->SetUnitCategory("Energy");
  EKinCmd->AvailableForStates(G4State_PreInit,G4State_Idle);

  JOBIDCmd = new G4UIcmdWithAnInteger("/SB/det/JOBID",this);
  JOBIDCmd->SetGuidance("Job ID");
  JOBIDCmd->SetParameterName("JOBID",true);
  JOBIDCmd->AvailableForStates(G4State_PreInit,G4State_Idle);
}

SBPrimaryGeneratorMessenger::~SBPrimaryGeneratorMessenger()
{
  delete ExtGenCmd;
  delete RndmCmd;
  delete gunDir;
  delete FileInCmd;
  delete gunDir1;
  delete EKinCmd;
  delete JOBIDCmd;
  delete x0_command;
  delete y0_command;
}

void SBPrimaryGeneratorMessenger::SetNewValue(G4UIcommand* command, G4String newValue)
{ 
  if( command == ExtGenCmd )
    { 
      G4cout << "ciccio GENERATOR "<<ExtGenCmd->GetNewIntValue(newValue)<<G4endl;
      SBAction->SetExtGen(ExtGenCmd->GetNewIntValue(newValue));}

  if( command == RndmCmd )
   { SBAction->SetRndmFlag(newValue);}
  if( command == FileInCmd )
   {
     G4cout << "pippo SetInputFileName("<<newValue<<")"<<G4endl;
     //SBAction->SetInputFileName(FileInCmd->GetNewStringValue(newValue));
     SBAction->SetInputFileName(newValue);
   }
  if( command == EKinCmd )
   {
     SBAction->SetGunEKin(EKinCmd->GetNewDoubleValue(newValue));
   }
  if( command == x0_command )
   {
     SBAction->Setx0(x0_command->GetNewDoubleValue(newValue));
   }
  if( command == y0_command )
   {
     SBAction->Sety0(y0_command->GetNewDoubleValue(newValue));
   }
  if(command == JOBIDCmd)
    {SBAction->SetJOBID(JOBIDCmd->GetNewIntValue(newValue));}
}
#include "SBProba.hh"
#include "SBDetectorConstruction.hh"
#include "SBRunAction.hh"
#include "SBEventAction.hh"
#include "SBAnalysisManager.hh"

#include "TF1.h"
#include "G4PionPlus.hh"
#include "G4PionZero.hh"
#include "G4KaonZero.hh"
#include "G4MuonPlus.hh"
#include "G4KaonPlus.hh"
#include "G4Electron.hh"

#include "Randomize.hh"

//to make it a ROOT class
//ClassImp(SBProba)

SBProba::SBProba(SBDetectorConstruction* SBDC, SBRunAction* SBRA/*,SBEventAction* SBEA*/):SBDetector(SBDC),runAct(SBRA)/*,evtAct(SBEA)*/
{
  NBINE=100;
  surf = 100.*CLHEP::m*CLHEP::m; // 100m^2
  dist = 100.*CLHEP::km;  // 100 10^3 m
  multiplicity=1;
  
  mmu = G4MuonPlus::MuonPlus()->GetPDGMass();
  mK0 = G4KaonZero::KaonZero()->GetPDGMass();
  mK = G4KaonPlus::KaonPlus()->GetPDGMass();
  me = G4Electron::Electron()->GetPDGMass();
  mpi = G4PionPlus::PionPlus()->GetPDGMass();
  mpi0 = G4PionZero::PionZero()->GetPDGMass();

  ctmu = 658.654*CLHEP::m;//
  G4cout << "SBProba::SBProba " << surf/(CLHEP::m*CLHEP::m) << " m2 " <<dist/CLHEP::km << " km " << multiplicity <<" "<< G4endl;
}

SBProba::~SBProba(){;}
// PWN=probability

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

//   2 Body decay:  pi -> mu numu
//                   K -> mu numu

void SBProba::proba2(G4ThreeVector vP, 
		     G4String partyp,
		     G4int parfl,
		     G4int q,
		     G4double PWN)
{
  G4double M=0;
  G4double norm=0, weight=0, weightIDEAL=0, E=0;
  G4double beta=0, gamma=0;
  G4double P = vP.mag();
  G4double cth = 0;

  G4double OffAxisAngle=SBDetector->GetOffAxisAngle();
  G4double OffAxisPhi=SBDetector->GetOffAxisPhi();

  G4double eOME[3]={0.,0.,0.};
  eOME[0]=sin(OffAxisAngle)*cos(OffAxisPhi);
  eOME[1]=sin(OffAxisAngle)*sin(OffAxisPhi);
  eOME[2]=cos(OffAxisAngle);

  if(P)cth=((eOME[0]*vP.x())+(eOME[1]*vP.y())+(eOME[2]*vP.z()))/P;
  
  if(partyp=="kaon")M=mK;
  if(partyp=="pion")M=mpi;

  if(P){
    E=sqrt(P*P+M*M);
    beta = P/E;
    gamma = E/M;
    norm = 1.e17*surf/(dist*dist)/(4.*acos(-1.))/multiplicity;
    weight = norm*PWN*(1.-beta*beta)/pow(1.-beta*cth,2);
    weightIDEAL = norm*PWN*(1.-beta*beta)/pow(1.-beta*1.,2);

    G4double enuCM = (M*M-mmu*mmu)/(2.*M);
    G4double enuLAB = 1.+beta*(beta-cth)/(beta*cth-1.);
    enuLAB = enuCM*gamma*enuLAB;
    
    SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
    analysis->FillProba2(q,partyp,parfl,enuLAB,weight,weightIDEAL);
    
    G4cout << "SBProba::proba2 "
	   <<surf/(CLHEP::m*CLHEP::m)<<" m2 " 
	   <<dist/CLHEP::km<<" km " 
	   <<multiplicity<<" "
	   <<weight<<" m(GeV) "
	   <<M/CLHEP::GeV<<" beta "
	   <<beta<<" gamma "
	   <<gamma
	   <<G4endl;
  }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double SBProba::PowerNorm(G4double Ek,G4double PowerMW){
  G4double year =1.e7;//s convention
  G4double eV_J = 1.602176*1.e-19;
  G4double pot_s = PowerMW*1.e6/(Ek*1.e9*eV_J);
  G4double pot_y = pot_s*year;
  G4double Pw = pot_y/1.e23;
  return Pw;  
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....
//////////////////////////////////////////////////////////////////////////////////////////////inutile
G4double SBProba::EnuForward(G4ThreeVector vP, G4double M){
  //   2 Body decay:  pi -> mu numu
  //                   K -> mu numu
  G4double E=0, beta=0, gamma=0, enuCM=0, enuLAB=0;
  G4double P = vP.mag();
  G4double cth = 0;

  //if(P)cth = vP.z()/P;// check ...

  G4double OffAxisAngle=SBDetector->GetOffAxisAngle();
  G4double OffAxisPhi=SBDetector->GetOffAxisPhi();
  G4double eOME[3]={0.,0.,0.};
  eOME[0]=sin(OffAxisAngle)*cos(OffAxisPhi);
  eOME[1]=sin(OffAxisAngle)*sin(OffAxisPhi);
  eOME[2]=cos(OffAxisAngle);
  if(P)cth=((eOME[0]*vP.x())+(eOME[1]*vP.y())+(eOME[2]*vP.z()))/P;


  //if(P>0.000001){
  if(P>0.000001){
    E=sqrt(P*P+M*M);
    beta = P/E;
    gamma = E/M;
    enuCM = (M*M-mmu*mmu)/(2.*M);
    enuLAB = 1.+beta*(beta-cth)/(beta*cth-1.);
    enuLAB = enuCM*gamma*enuLAB;
  }
  //      G4cout << "exit proba2" << ipart << G4endl;  
  return enuLAB;
}
///////////////////////////////////////////////////////////////////////////////////////////
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBProba::proba3K(G4ThreeVector pK, 
		      G4double enuLAB,
		      G4double PWN,
		      G4int decflag=7){

  // 3 body kaon decays

  G4cout << "SBProba::proba3K: pK(GeV) "<<pK/CLHEP::GeV<<" enuLAB(GeV) "<<enuLAB/CLHEP::GeV<<" PWN "<<PWN<<" decflag "<<decflag<<G4endl;
  G4cout << "SBProba::proba3K: surf " << surf/(CLHEP::m*CLHEP::m) << " m2 dist " <<dist/CLHEP::km << " km " << multiplicity <<" "<< G4endl;

  G4double cthK=0,leptM=0,piM=0;

  if((decflag==7)||(decflag==8)){leptM=me; piM=mpi0;}
  if((decflag==9)||(decflag==10)){leptM=mmu; piM=mpi0;}  
  if((decflag==13)||(decflag==14)){leptM=me; piM=mpi;}
  if((decflag==15)||(decflag==16)){leptM=mmu; piM=mpi;}

  G4cout << "SBProba::proba3K: lepton M: "<<leptM/CLHEP::MeV<<
    " (MeV). pion M: "<<piM/CLHEP::MeV<<" (MeV)."<<G4endl;

  G4double PK = pK.mag();
  //if(PK)cthK=pK.z()/PK;    

  G4double OffAxisAngle=SBDetector->GetOffAxisAngle();
  G4double OffAxisPhi=SBDetector->GetOffAxisPhi();
  G4double eOME[3]={0.,0.,0.};
  eOME[0]=sin(OffAxisAngle)*cos(OffAxisPhi);
  eOME[1]=sin(OffAxisAngle)*sin(OffAxisPhi);
  eOME[2]=cos(OffAxisAngle);
  if(PK)cthK=((eOME[0]*pK.x())+(eOME[1]*pK.y())+(eOME[2]*pK.z()))/PK;

  G4double EK = sqrt(PK*PK+mK0*mK0);
  G4double betaK = PK/EK;
  G4double gammaK = EK/mK0;
  
  G4double norm = (1e17*surf)/(pow(dist,2)*4.*acos(-1.)*multiplicity);
  G4double cthstr = (betaK-cthK)/((betaK*cthK)-1.);//cos(nu) in K r.f.
  G4double fact = ((1.-(betaK*betaK))/pow(1.-betaK*cthK,2));
  G4double fact1=(1./(gammaK*(1.+(betaK*cthstr))));

  G4cout << "SBProba::proba3K: norm "<<norm << " fact "<<fact<<" cthstr "<<cthstr<<G4endl;

  G4double weight = (norm*fact*fact1)*2./(mK0-leptM-piM);//? mumble mumble
  weight*=PWN;

  G4double weight2 = norm*fact;
  weight2*=PWN;

  G4cout << "SBProba::proba3K:"<<
    " EK (GeV): "<<EK/CLHEP::GeV<<
    " pK (GeV): "<<pK/CLHEP::GeV<<
    " betaK: "<<betaK<<
    " gammaK: "<<gammaK<<
    " cthstr: "<<cthstr<<
    " mult: "<<multiplicity<<
    " Enulab (GeV): "<<enuLAB/CLHEP::GeV<<
    " norm: "<<norm<<
    " fact: "<<fact<<
    " fact1: "<<fact1<<
    " weight: "<<weight<<
    " weight2: "<<weight2<<G4endl;
 
  //G4double de=1;//MeV
  de=1;//MeV
  //G4double enuzero = G4UniformRand();
  //G4double E0=EK-leptM-piM;
  //G4double E0=mK-leptM-piM;
  G4double E0=200;//MeV
  G4int nsampl = int(E0/de);
  G4double e_nu=0;
  G4cout <<"EK-mpi-mlept "<<EK-leptM-piM<<" de "<<de <<" NSAMPL " << nsampl <<G4endl;

  TF1 *f = new TF1("f","2.47459e-5-7.44997e-06*x+5.43311e-07*x*x-2.51867e-09*x*x*x",0,200);
  
  //double ww=0;
  double enustar=0;
  weight=weight*de*gammaK*(1+betaK*cthstr);
  for(int j=0;j<nsampl;j++){
    //enustar = E0 - (j+1-enuzero)*de;
    /*  if(enustar<200){
      ww=2.47459e-5
	-7.44997e-06*enustar
	+5.43311e-07*pow(enustar,2)
	-2.51867e-09*pow(enustar,3);
    */

    enustar=f->GetRandom();
    e_nu = enustar*gammaK*(1+betaK*cthstr);//transform to lab

    //G4cout <<"check "<<e_nu<<" "<<ww<<G4endl;
    

    //////////////////////////////////////////////////////////////
    SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
    analysis->FillProba3K(decflag,e_nu,weight);

    /*
    if(decflag==7)runAct->kaons_nue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==8)runAct->kaons_anue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==9)runAct->kaons_numu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==10)runAct->kaons_anumu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    
    if(decflag==13)runAct->kzeros_nue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==14)runAct->kzeros_anue_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==15)runAct->kzeros_numu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    if(decflag==16)runAct->kzeros_anumu_du_3->Fill(e_nu/CLHEP::GeV,weight);
    */
  }

  return;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

/***************************************/
/***************************************/
/***************************************/

void SBProba::probaMu(
		      G4ThreeVector xmu, 
		      G4ThreeVector pmu,
		      G4ThreeVector ppar, 
		      G4double mpar = 139.,
		      G4int iipart=-1,
		      G4int parflag=0,
		      G4double PWN=1.
		      ){
  // muon decay
  ipart=iipart;
  G4double Emu=0, Epar=0, betaMu=0;
  betaPar=0;
  G4double gammaMu=0, norm=0, weight=0, weight0=0;
  gammaPar=0;
  G4double polaT=0, polaL=0, func=0, fact=0, weightnue=0, weightnue0=0;
  G4double threshold=0, e_nu=0, a=0, probaDKmu=0,cthMu=0,cthMu0=0;
  G4int nsampl=0;
  
  //G4cout <<"enter probaMu " << ipart << G4endl;

  G4double Pmu=pmu.mag();
  G4double Ppar=ppar.mag();

  G4double OffAxisAngle=SBDetector->GetOffAxisAngle();
  G4double OffAxisPhi=SBDetector->GetOffAxisPhi();
  G4double eOME[3]={0.,0.,0.};
  eOME[0]=sin(OffAxisAngle)*cos(OffAxisPhi);
  eOME[1]=sin(OffAxisAngle)*sin(OffAxisPhi);
  eOME[2]=cos(OffAxisAngle);
  if(Pmu)cthMu=((eOME[0]*pmu.x())+(eOME[1]*pmu.y())+(eOME[2]*pmu.z()))/Pmu;
  if(Pmu)cthMu0=pmu.z()/Pmu;

  //G4cout << "brius Ppar "<< Ppar << " Pmu "<< Pmu << G4endl;

  //if(Pmu<0.000001){
  //G4cout << "ProbaMu: P tooo small. return. Pmu = "<< Pmu << G4endl;
  //return;
  //}

  Emu = sqrt(Pmu*Pmu+mmu*mmu);
  betaMu = Pmu/Emu;
  gammaMu = Emu/mmu;

  Epar = sqrt(Ppar*Ppar+mpar*mpar);
  betaPar = Ppar/Epar;
  gammaPar = Epar/mpar;

  runAct->h_MUDEC_pmupar->Fill(Pmu/CLHEP::GeV,Ppar/CLHEP::GeV);

  if((betaMu>=1)&&(cthMu>=1)){
    G4cout <<"SBproba::probaMu ERROR, costheta = "<<cthMu<<" beta = " << betaMu << G4endl;
    return;
  }
  
  // temp!
  //G4int itra=0,itrackSav=0,ievent=0,ieventSav=0;

  G4double pstar = (mpar*mpar-mmu*mmu)/(2.*mpar);
  //G4cout <<"pstar "<< pstar << G4endl;

  //G4double thmu=acos(pmu.z()/Pmu);
  //G4double thpar=acos(ppar.z()/Ppar);
  //thpar=0;
  G4double thpimu = acos((pmu.x()*ppar.x()+pmu.y()*ppar.y()+pmu.z()*ppar.z())/(Pmu*Ppar));

  runAct->h_MUDEC_thpimu_lab->Fill(thpimu);

  //G4cout << "zero "<<Pmu<<" "<<Emu<<" "<<gammaPar<<" "<<betaPar<<" "<<gammaPar*Epar-betaPar*gammaPar*Ppar*cos(thpar)<<" thpimu "<<thpimu<<G4endl;
  //cthstarMu=sin(thpar)*(gammaPar/pstar)*(P*cos(thmu-thpar)-betaPar*Emu);
  //cthstarMu=gammaPar*(Pmu*cos(thmu)-betaPar*Emu)/sqrt(pow(gammaPar*(Pmu*cos(thmu)-betaPar*Emu),2)+pow(Pmu*sin(thmu),2));

  cthstarMu=(gammaPar*(Pmu*cos(thpimu)-betaPar*Emu))/pstar;

  //G4cout <<"cthstarMu "<< cthstarMu << G4endl;

  if(pow(cthstarMu,2)<1.){
    polaT = gammaPar*betaPar*sqrt(1.-pow(cthstarMu,2))/(gammaMu*betaMu);
  }else{
    G4cout << "SBProba::probaMu error: abs(cthstarMu)>1 " << G4endl;
    return;
  }

  if(polaT>1){
    G4cout <<"SBProba::probaMu ERROR, polaT = " << polaT << G4endl;
    G4cout <<"SBProba::probaMu ERROR, pi info = " << gammaPar << " "  << betaPar << G4endl;
    G4cout <<"SBProba::probaMu ERROR, mu info = " << gammaMu <<" "<<betaMu<<" "<<cthstarMu<<G4endl;
    return;
  }

  polaL = sqrt(1.-pow(polaT,2));

  mpi = G4PionPlus::PionPlus()->GetPDGMass();

  threshold = ((mpi*mpi)-(mmu*mmu))/((mpi*mpi)+(mmu*mmu));
  threshold = -threshold/betaPar;

  if(ipart==(-1)) polaL = -polaL;//muminus
  if(cthstarMu>threshold) polaL = -polaL;
      
  if(ipart==1)   runAct->h_MUDEC_polaL_muplus->Fill(polaL);
  if(ipart==(-1))runAct->h_MUDEC_polaL_muminus->Fill(polaL);

  //if((ieventSav!=ievent)||(itrackSav!=itra)){ 
  // no information about the polarization...
  //polaL = 0;
  //}
  
  //G4cout <<"TESTPROBA1 "<< pmu << " " << xmu <<G4endl;

  probaDKmu=dkproba(pmu,xmu);

  //G4cout <<"TESTPROBA "<< probaDKmu <<G4endl;

  //100  FORMAT('probaMu',E14.6,E14.6,E14.6,E14.6,E14.6,E14.6,E14.6,E14.6);

  de = 1;//MeV (G4 standard unit)
  //de = 200;//MeV (G4 standard unit)

  //norm = (de/1000.)*1.e17*surf/pow(dist,2)/(2.*acos(-1.))*probaDKmu/multiplicity;// is dividing by 1/2pi correct ? check factor 2 ins in "fact"
  norm = (de)*1.e17*surf/pow(dist,2)/(4.*acos(-1.))*probaDKmu/multiplicity;

  //cthstarNu = (betaMu-cthMu0)/(betaMu*cthMu0-1.);//of neutrino BUG ?
  cthstarNu = (betaMu-cthMu)/(betaMu*cthMu-1.);//of neutrino BUG ?
  //cthstarNu = (betaMu-cos(thpimu))/(betaMu*cos(thpimu)-1.);//of neutrino
 
  G4cout <<"costh* nu "<<cthstarNu<<G4endl;

  func = (1.-betaMu*betaMu)/pow(1.-betaMu*cthMu,2);
  fact = 2./(Emu*(1.+betaMu*cthstarNu));

  runAct->h_MUDEC_cthstarMu->Fill(cthstarMu);
  runAct->h_MUDEC_cthstarNu->Fill(cthstarNu);

  //     call a random number to avoid systematic effect
  //CALL GRNDM(enuzero,1);
  G4double enuzero = G4UniformRand();// temp
  nsampl = int(Emu/de);

  G4cout <<"Emu "<<Emu<<" de "<<de <<" NSAMPL " << nsampl <<" weight "<<norm*func*fact*PWN<<G4endl;
 
  //G4cout << "CICCIO "<<cthstarMu <<" "<<cthstarNu << G4endl;
  //G4cout << "probaMu power normalization "<<PWN<< G4endl;

  G4double succ_samples =0;
  for(int j=0;j<nsampl;j++){
    // sample neutrino energy in the lab frame from its max value (~Emu) to zero
    e_nu = Emu - (j+1-enuzero)*de;

    //Enu* = Enu/ [gammamu ( 1 + betamu Costhstar)]
    // a is 2Enu*/mmu
    a = fact*e_nu;

    //G4cout << "CICCIO1 "<<Emu <<" "<<e_nu <<" "<<a<<" "<<fact<<" "<<betaMu<<" "<<cthstarNu<<G4endl;
    if((a>=0)&&(a<=1)){
      succ_samples++;

      G4double f0m = 2.*pow(a,2)*(3.-2.*a);
      G4double f1m = 2.*pow(a,2)*(1.-2.*a);

      G4double f0e = 12.*pow(a,2)*(1.-a);
      G4double f1e = f0e;

      //polaL=1;//temp

      //weight = pow(a,2)*( (3.-2.*a) - polaL*cthstarNu*(1.-2.*a) );
      weight0 = f0m - polaL*cthstarNu*f1m;
      weight = (norm*func*fact*PWN)*weight0;

      //weightnue = (pow(a,2)-pow(a,3)) - polaL*cthstarNu*(pow(a,2)-pow(a,3));
      //weightnue = 6.*norm*func*fact*PWN*weightnue; 
      weightnue0 = f0e - polaL*cthstarNu*f1e;
      weightnue = (norm*func*fact*PWN)*weightnue0;
      /*     
	     if((weight<0)||(weightnue<0))
	     G4cout << "probaMu brius "
	     <<ipart<<" "
	     <<e_nu<<" "
	     <<weight<<" "
	     <<weightnue<<" "
	     <<weight0<<" "
	     <<weightnue0<<" "
	     <<norm<<" "
	     <<probaDKmu<<" "
	     <<func<<" "
	     <<fact<<" "
	     <<G4endl;
      */
      G4double Enustar = mmu*a/2.;

      if(ipart==(-1)){//muminus
	runAct->h_MUDEC_Enumustar->Fill(Enustar,weight0);
	runAct->h_MUDEC_Eanuestar->Fill(Enustar,weightnue0);
	//runAct->h_MUDEC_Enumustar->Fill(Enustar);
	//runAct->h_MUDEC_Eanuestar->Fill(Enustar);
      } else if (ipart==1){// muplus
	runAct->h_MUDEC_Eanumustar->Fill(Enustar,weight0);
	runAct->h_MUDEC_Enuestar->Fill(Enustar,weightnue0);
	//runAct->h_MUDEC_Eanumustar->Fill(Enustar);
	//runAct->h_MUDEC_Enuestar->Fill(Enustar);
      }

      //G4cout << "brius " << Enustar << " " << weight <<" "<<weightnue<< G4endl;
      ///////////////////////////////////////////////////////////////////////////////////////////////

      SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
      analysis->FillprobaMu(ipart,parflag,e_nu,weight,weightnue);
      
      ////////////////////////////////////////////////////////////////////////////////////////////////////
      
    } else {// a in [0,1]
      //G4cout <<"SBProba::probaMu WARNING (sampling ineff.), a = " << a << G4endl;
    } // a in [0,1]
  }// loop
  

  G4cout <<"SBProba::probaMu successful samplings: "<< succ_samples<<" over "<<nsampl<<G4endl;
  //      if(ipart==6) G4cout <<"exit probaMu " << Probae(5)<<" " <<Probnm(5) << G4endl;
  //      G4cout <<" exit proba " << ipart << G4endl


  G4double rmu =sqrt(pow(xmu.x(),2)+pow(xmu.y(),2));

  runAct->h_MUDEC_probaTunnel->Fill(probaDKmu);

  runAct->h_MUDEC_probaTunnel_pmu->Fill(Pmu/CLHEP::GeV,probaDKmu);
  runAct->h_MUDEC_probaTunnel_thmu->Fill(acos(cthMu0),probaDKmu);
  runAct->h_MUDEC_probaTunnel_rmu->Fill(rmu/CLHEP::m,probaDKmu);

  runAct->h_MUDEC_muxy->Fill(xmu.x()/CLHEP::m,xmu.y()/CLHEP::m);
  runAct->h_MUDEC_muzr->Fill(xmu.z()/CLHEP::m,rmu/CLHEP::m);

  return;

}

/***************************************/
/***************************************/
/***************************************/

G4double SBProba::dkproba(G4ThreeVector pmu, G4ThreeVector xmuon){


  //G4int vbl = evtAct->GetSBVerbosity();
  G4int vbl = 1;
  G4ThreeVector xmu,umu;
  G4double r0=SBDetector->GetTunnelRadius();
  //G4double z0=0.5*SBDetector->GetHallSizeZ()-SBDetector->GetTunnelLength();
  G4double z0=SBDetector->GetHallSizeZ();
  
  if(vbl>0)
    G4cout << "dkproba pmu "<< pmu/CLHEP::GeV << " (GeV) r0 "<< r0/CLHEP::m <<" (m) z0 "<<z0/CLHEP::m<<" (m) xmuon "<< xmuon/CLHEP::m<<" (m)"<< G4endl;

  // put the origin at the beginning of the tunnel (correctly of all the volume indeed!)
  xmu.setX(xmuon.x());
  xmu.setY(xmuon.y());
  //xmu.setZ(xmuon.z()-z0);
  xmu.setZ(xmuon.z()+0.5*z0);
  
  G4double pathmu=0,probmu=0,param=0;
  G4double apmu=pmu.mag();
  if(!apmu){
    G4cout << " dkproba ERROR pmu = 0 "<< G4endl;
    probmu = 0;
    return probmu;
  }
  G4double path0mu = ctmu*apmu/mmu;
  if(vbl>0)
    G4cout << "dkproba xmu "<< xmu/CLHEP::m <<  " (m) ctmu "<< ctmu/CLHEP::m << " (m) pmu " << apmu/CLHEP::GeV <<" (GeV) mmu "<< mmu/CLHEP::GeV <<" (GeV) path0mu "<<path0mu/CLHEP::m<<" (m) "<< G4endl;

  umu.setX(pmu.x()/pmu.mag());
  umu.setY(pmu.y()/pmu.mag());
  umu.setZ(pmu.z()/pmu.mag());

  //dvdot(umu,umu,2,ap);
  G4double ap=(umu.x()*umu.x())+(umu.y()*umu.y());

  if(ap==0.){
    G4cout <<" dkproba:: ap = 0. axis parallel muon!"<<G4endl;
    param=z0/umu.z();
    pathmu=z0;
    probmu=1.-exp(-pathmu/path0mu);
    return probmu;
  }
  
  //dvdot(umu,xmu,2,bp);
  //dvdot(xmu,xmu,2,cp);
  G4double bp = (umu.x()*xmu.x())+(umu.y()*xmu.y());
  G4double cp = (xmu.x()*xmu.x())+(xmu.y()*xmu.y())-pow(r0,2);

  if((bp*bp-ap*cp)<0.){
    probmu = 0.;
    G4cout <<" dkproba ERROR sqrt < 0 ! a "<<ap<<" b "<<bp<<" c "<<cp<<G4endl;
    return probmu;
  }

  param = (-bp+sqrt(bp*bp-ap*cp))/ap;
  G4ThreeVector posfin = G4ThreeVector(0,0,0);

  // Pion on the wall
  if (param*umu.z()<=(z0-xmu.z())) {
    if(vbl>0)
      G4cout << "dkproba: mu exit on the wall" <<G4endl;
    posfin.setX(umu.x()*param+xmu.x());
    posfin.setY(umu.y()*param+xmu.y());
    posfin.setZ(umu.z()*param+xmu.z());
  } else {
    // Pion on the end plate
    if(vbl>0)
      G4cout << "dkproba: mu exit on the end-plate" <<G4endl;
    param = (z0-xmu.z())/umu.z();
    posfin.setX(umu.x()*param+xmu.x());
    posfin.setY(umu.y()*param+xmu.y());
    posfin.setZ(z0);
  }
  
  // the path available for decay
  G4ThreeVector vdiff = posfin-xmu;
  pathmu = vdiff.mag();

  if(pathmu<=0.){
    probmu = 0.;
    G4cout <<" dkproba: pathmu <= 0 ! posfin "<< posfin <<
      " param "<<param<<
      " a "<<ap<<
      " b "<<bp<<
      " c "<<cp<<
      G4endl;
  }

  runAct->h_MUDEC_pathTunnel->Fill(pathmu/CLHEP::m);

  // the probability is

  probmu=1.-exp(-pathmu/path0mu);
  if(vbl>0)
    G4cout << " dkproba: probmu " << probmu << " pathmu " <<pathmu/CLHEP::m <<" (m) path0mu "<<path0mu/CLHEP::m<<" (m) "<< G4endl;
  
  return probmu;
}
#include "SBRunAction.hh"
#include "SBRunActionMessenger.hh"
#include "SBAnalysisManager.hh"
#include "TH1F.h"
#include "TFile.h"
#include "G4Run.hh"
#include "G4RunManager.hh"
#include "G4UnitsTable.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

SBRunAction::SBRunAction(SBPrimaryGeneratorAction* primGen):primaryGen(primGen)
{
  //create a messenger for this class
  runActMessenger = new SBRunActionMessenger(this);
  //============================================================  
  EnuMAX=1.5;// SPL standard
  ENbins=75;//SPL standard  (75)

  //EnuMAX=1.5;// SPL prova
  //ENbins=20;//SPL prova

  //EnuMAX=10.;// PS2
  //ENbins=50;//PS2
  //EnuMAX=50.;// CNGS
  //ENbins=50;// CNGS

  //EnuMAX=50.;// NOVA
  //ENbins=1000;// NOVA
  //=============================================================
  rMAX=250;

  xMAX=2.5;
  yMAX=2.5;

  zMIN=-30.;//tunnel make this depend on tunnel parameters!!
  zMAX=30.;//tunnel

  NENB=9;
  for(int j=0;j<NENB;j++){
    ENULIMS[j]=0.8*((double)j/(double)NENB);
  }
  ENULIMS[NENB]=0.8;
 
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

SBRunAction::~SBRunAction()
{
  G4cout<<"CALL SBRunAction::~SBRunAction "<<G4endl;
  //delete histoManager;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::BeginOfRunAction(const G4Run* aRun)
{ 
  G4cout << "### Run " << aRun->GetRunID() << " start." << G4endl;
  
  G4cout<<"CALL SBRunAction::BeginOfRunAction "<<G4endl;
  G4cout<<"CALL SBRunAction::BeginOfRunAction Nbins = "<<ENbins<<G4endl;
  G4cout<<"CALL SBRunAction::BeginOfRunAction EnuMIN = "<<EnuMIN/CLHEP::GeV<<" (GeV)"<<G4endl;
  G4cout<<"CALL SBRunAction::BeginOfRunAction EnuMAX = "<<EnuMAX/CLHEP::GeV<<" (GeV)"<<G4endl;

  //inform the runManager to save random number seed
  G4RunManager::GetRunManager()->SetRandomNumberStore(true);
    
  //initialize cumulative quantities
  //
  sumETarg = sum2ETarg =sumEGap = sum2EGap = 0.;
  sumLTarg = sum2LTarg =sumLGap = sum2LGap = 0.; 

  NDIF_piplus_TOT = 0;
  NDIF_piminus_TOT = 0;
  NDIF_Kplus_TOT = 0;
  NDIF_Kminus_TOT = 0;
  NDIF_KzeroL_TOT = 0;
  NDIF_KzeroS_TOT = 0;
  
  if(primaryGen->GetJOBID()>=0){
    fROOT = new TFile(Form("output_%06d.root",primaryGen->GetJOBID()),"recreate");
  }else{
    fROOT = new TFile(Form("output_-%06d.root",-primaryGen->GetJOBID()),"recreate");    
  }

 
  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
  G4double pmax = 1.5;

  h_pt_exit_piplus = new TH1F("h_pt_exit_piplus","h_pt_exit_piplus",100,0,1.);
  h_p_exit_piplus = new TH1F("h_p_exit_piplus","h_p_exit_piplus",100,0,pmax);
  //h_p_exit_piplus_W = new TH1F("h_p_exit_piplus_W","h_p_exit_piplus_W",100,0,pmax);
  h_xy_exit_piplus = new TH2F("h_xy_exit_piplus","h_xy_exit_piplus",100,-100,100,100,-100,100);
  h_z_exit_piplus = new TH1F("h_z_exit_piplus","h_z_exit_piplus",500,zMIN,zMAX);
  h_r_exit_piplus = new TH1F("h_r_exit_piplus","h_r_exit_piplus",208,0,rMAX);
  h_pVSr_exit_piplus = new TH2F("h_pVSr_exit_piplus","h_pVSr_exit_piplus",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_piplus = new TH2F("h_thetaVSr_exit_piplus","h_thetaVSr_exit_piplus",208,0,rMAX,100,0,1);
  h_theta_exit_piplus = new TH1F("h_theta_exit_piplus","h_theta_exit_piplus",100,0,1.);
  //h_theta_exit_piplus_W = new TH1F("h_theta_exit_piplus_W","h_theta_exit_piplus_W",100,0,1.);
  h_pVStheta_exit_piplus = new TH2F("h_pVStheta_exit_piplus","h_pVStheta_exit_piplus",100,0.,1.,100,0,pmax);
  //h_pVStheta_exit_piplus_W = new TH2F("h_pVStheta_exit_piplus_W","h_pVStheta_exit_piplus_W",100,0.,1.,100,0,pmax);
  
  h_pt_exit_piminus = new TH1F("h_pt_exit_piminus","h_pt_exit_piminus",100,0,1.);
  h_p_exit_piminus = new TH1F("h_p_exit_piminus","h_p_exit_piminus",100,0,pmax);
  //h_p_exit_piminus_W = new TH1F("h_p_exit_piminus_W","h_p_exit_piminus_W",100,0,pmax);
  h_xy_exit_piminus = new TH2F("h_xy_exit_piminus","h_xy_exit_piminus",100,-100,100,100,-100,100);
  h_z_exit_piminus = new TH1F("h_z_exit_piminus","h_z_exit_piminus",500,zMIN,zMAX);
  h_r_exit_piminus = new TH1F("h_r_exit_piminus","h_r_exit_piminus",208,0,rMAX);
  h_pVSr_exit_piminus = new TH2F("h_pVSr_exit_piminus","h_pVSr_exit_piminus",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_piminus = new TH2F("h_thetaVSr_exit_piminus","h_thetaVSr_exit_piminus",208,0,rMAX,100,0,1);
  h_theta_exit_piminus = new TH1F("h_theta_exit_piminus","h_theta_exit_piminus",100,0,1.);
  //h_theta_exit_piminus_W = new TH1F("h_theta_exit_piminus_W","h_theta_exit_piminus_W",100,0,1.);
  h_pVStheta_exit_piminus = new TH2F("h_pVStheta_exit_piminus","h_pVStheta_exit_piminus",100,0.,1.,100,0,pmax);
  //h_pVStheta_exit_piminus_W = new TH2F("h_pVStheta_exit_piminus_W","h_pVStheta_exit_piminus_W",100,0.,1.,100,0,pmax);
  
  h_pt_exit_kplus = new TH1F("h_pt_exit_kplus","h_pt_exit_kplus",100,0,1.);
  h_p_exit_kplus = new TH1F("h_p_exit_kplus","h_p_exit_kplus",100,0,pmax);
  //h_p_exit_kplus_W = new TH1F("h_p_exit_kplus_W","h_p_exit_kplus_W",100,0,pmax);
  h_xy_exit_kplus = new TH2F("h_xy_exit_kplus","h_xy_exit_kplus",100,-100,100,100,-100,100);
  h_z_exit_kplus = new TH1F("h_z_exit_kplus","h_z_exit_kplus",500,zMIN,zMAX);
  h_r_exit_kplus = new TH1F("h_r_exit_kplus","h_r_exit_kplus",208,0,rMAX);
  h_pVSr_exit_kplus = new TH2F("h_pVSr_exit_kplus","h_pVSr_exit_kplus",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_kplus = new TH2F("h_thetaVSr_exit_kplus","h_thetaVSr_exit_kplus",208,0,rMAX,100,0,1);
  h_theta_exit_kplus = new TH1F("h_theta_exit_kplus","h_theta_exit_kplus",100,0,1.);
  //h_theta_exit_kplus_W = new TH1F("h_theta_exit_kplus_W","h_theta_exit_kplus_W",100,0,1.);
  h_pVStheta_exit_kplus = new TH2F("h_pVStheta_exit_kplus","h_pVStheta_exit_kplus",100,0.,1.,100,0,pmax);
  
  h_pt_exit_kminus = new TH1F("h_pt_exit_kminus","h_pt_exit_kminus",100,0,1.);
  h_p_exit_kminus = new TH1F("h_p_exit_kminus","h_p_exit_kminus",100,0,pmax);
  //h_p_exit_kminus_W = new TH1F("h_p_exit_kminus_W","h_p_exit_kminus_W",100,0,pmax);
  h_xy_exit_kminus = new TH2F("h_xy_exit_kminus","h_xy_exit_kminus",100,-100,100,100,-100,100);
  h_z_exit_kminus = new TH1F("h_z_exit_kminus","h_z_exit_kminus",500,zMIN,zMAX);
  h_r_exit_kminus = new TH1F("h_r_exit_kminus","h_r_exit_kminus",208,0,rMAX);
  h_pVSr_exit_kminus = new TH2F("h_pVSr_exit_kminus","h_pVSr_exit_kminus",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_kminus = new TH2F("h_thetaVSr_exit_kminus","h_thetaVSr_exit_kminus",208,0,rMAX,100,0,1);
  h_theta_exit_kminus = new TH1F("h_theta_exit_kminus","h_theta_exit_kminus",100,0,1.);
  //h_theta_exit_kminus_W = new TH1F("h_theta_exit_kminus_W","h_theta_exit_kminus_W",100,0,1.);
  h_pVStheta_exit_kminus = new TH2F("h_pVStheta_exit_kminus","h_pVStheta_exit_kminus",100,0.,1.,100,0,pmax);
  
  h_pt_exit_muplus = new TH1F("h_pt_exit_muplus","h_pt_exit_muplus",100,0,1.);
  h_p_exit_muplus = new TH1F("h_p_exit_muplus","h_p_exit_muplus",100,0,pmax);
  //h_p_exit_muplus_W = new TH1F("h_p_exit_muplus_W","h_p_exit_muplus_W",100,0,pmax);
  h_xy_exit_muplus = new TH2F("h_xy_exit_muplus","h_xy_exit_muplus",100,-100,100,100,-100,100);
  h_z_exit_muplus = new TH1F("h_z_exit_muplus","h_z_exit_muplus",500,zMIN,zMAX);
  h_r_exit_muplus = new TH1F("h_r_exit_muplus","h_r_exit_muplus",208,0,rMAX);
  h_pVSr_exit_muplus = new TH2F("h_pVSr_exit_muplus","h_pVSr_exit_muplus",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_muplus = new TH2F("h_thetaVSr_exit_muplus","h_thetaVSr_exit_muplus",208,0,rMAX,100,0,1);
  h_theta_exit_muplus = new TH1F("h_theta_exit_muplus","h_theta_exit_muplus",100,0,1.);
  //h_theta_exit_muplus_W = new TH1F("h_theta_exit_muplus_W","h_theta_exit_muplus_W",100,0,1.);
  h_pVStheta_exit_muplus = new TH2F("h_pVStheta_exit_muplus","h_pVStheta_exit_muplus",100,0.,1.,100,0,pmax);
  
  h_pt_exit_muminus = new TH1F("h_pt_exit_muminus","h_pt_exit_muminus",100,0,1.);
  h_p_exit_muminus = new TH1F("h_p_exit_muminus","h_p_exit_muminus",100,0,pmax);
  //h_p_exit_muminus_W = new TH1F("h_p_exit_muminus_W","h_p_exit_muminus_W",100,0,pmax);
  h_xy_exit_muminus = new TH2F("h_xy_exit_muminus","h_xy_exit_muminus",100,-100,100,100,-100,100);
  h_z_exit_muminus = new TH1F("h_z_exit_muminus","h_z_exit_muminus",500,zMIN,zMAX);
  h_r_exit_muminus = new TH1F("h_r_exit_muminus","h_r_exit_muminus",208,0,rMAX);
  h_pVSr_exit_muminus = new TH2F("h_pVSr_exit_muminus","h_pVSr_exit_muminus",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_muminus = new TH2F("h_thetaVSr_exit_muminus","h_thetaVSr_exit_muminus",208,0,rMAX,100,0,1);
  h_theta_exit_muminus = new TH1F("h_theta_exit_muminus","h_theta_exit_muminus",100,0,1.);
  //h_theta_exit_muminus_W = new TH1F("h_theta_exit_muminus_W","h_theta_exit_muminus_W",100,0,1.);
  h_pVStheta_exit_muminus = new TH2F("h_pVStheta_exit_muminus","h_pVStheta_exit_muminus",100,0.,1.,100,0,pmax);
  
  h_pt_exit_k0L = new TH1F("h_pt_exit_k0L","h_pt_exit_k0L",100,0,1.);
  h_p_exit_k0L = new TH1F("h_p_exit_k0L","h_p_exit_k0L",100,0,pmax);
  //h_p_exit_k0L_W = new TH1F("h_p_exit_k0L_W","h_p_exit_k0L_W",100,0,pmax);
  h_xy_exit_k0L = new TH2F("h_xy_exit_k0L","h_xy_exit_k0L",100,-100,100,100,-100,100);
  h_z_exit_k0L = new TH1F("h_z_exit_k0L","h_z_exit_k0L",500,zMIN,zMAX);
  h_r_exit_k0L = new TH1F("h_r_exit_k0L","h_r_exit_k0L",208,0,rMAX);
  h_pVSr_exit_k0L = new TH2F("h_pVSr_exit_k0L","h_pVSr_exit_k0L",208,0,rMAX,100,0,1);
  h_thetaVSr_exit_k0L = new TH2F("h_thetaVSr_exit_k0L","h_thetaVSr_exit_k0L",208,0,rMAX,100,0,1);
  h_theta_exit_k0L = new TH1F("h_theta_exit_k0L","h_theta_exit_k0L",100,0,1.);
  //h_theta_exit_k0L_W = new TH1F("h_theta_exit_k0L_W","h_theta_exit_k0L_W",100,0,1.);
  h_pVStheta_exit_k0L = new TH2F("h_pVStheta_exit_k0L","h_pVStheta_exit_k0L",100,0.,1.,100,0,pmax);

  // at target level

  h_pt_targ_piplus = new TH1F("h_pt_targ_piplus","h_pt_targ_piplus",100,0,1.);
  h_p_targ_piplus = new TH1F("h_p_targ_piplus","h_p_targ_piplus",100,0,pmax);
  h_z_targ_piplus = new TH1F("h_z_targ_piplus","h_z_targ_piplus",100,0,90);
  h_zabs_targ_piplus = new TH1F("h_zabs_targ_piplus","h_zabs_targ_piplus",500,zMIN,zMAX);
  h_theta_targ_piplus = new TH1F("h_theta_targ_piplus","h_theta_targ_piplus",100,0,1.);
  h_pVStheta_targ_piplus = new TH2F("h_pVStheta_targ_piplus","h_pVStheta_targ_piplus",100,0.,1.,100,0,pmax);

  for(int i=0;i<NENB;i++){
    h_pVStheta_targ_piplus_Enubins[i] = new TH2F(Form("h_pVStheta_targ_piplus_Enubins%d",i),
						 Form("h_pVStheta_targ_piplus_Enubins%d",i),100,0.,1.,100,0,3.);
    h_p_targ_piplus_Enubins[i] = new TH1F(Form("h_p_targ_piplus_Enubins%d",i),
					  Form("h_p_targ_piplus_Enubins%d",i),100,0,3.);
    h_theta_targ_piplus_Enubins[i] = new TH1F(Form("h_theta_targ_piplus_Enubins%d",i),
					       Form("h_theta_targ_piplus_Enubins%d",i),100,0,1.);
  }

  h_pt_targ_piminus = new TH1F("h_pt_targ_piminus","h_pt_targ_piminus",100,0,1.);
  h_p_targ_piminus = new TH1F("h_p_targ_piminus","h_p_targ_piminus",100,0,pmax);
  h_z_targ_piminus = new TH1F("h_z_targ_piminus","h_z_targ_piminus",100,0,90);
  h_zabs_targ_piminus = new TH1F("h_zabs_targ_piminus","h_zabs_targ_piminus",500,zMIN,zMAX);
  h_theta_targ_piminus = new TH1F("h_theta_targ_piminus","h_theta_targ_piminus",100,0,1.);
  h_pVStheta_targ_piminus = new TH2F("h_pVStheta_targ_piminus","h_pVStheta_targ_piminus",100,0.,1.,100,0,pmax);
  for(int i=0;i<NENB;i++){
    h_pVStheta_targ_piminus_Enubins[i] = new TH2F(Form("h_pVStheta_targ_piminus_Enubins%d",i),
						  Form("h_pVStheta_targ_piminus_Enubins%d",i),100,0.,1.,100,0,3.);
    h_p_targ_piminus_Enubins[i] = new TH1F(Form("h_p_targ_piminus_Enubins%d",i),
					   Form("h_p_targ_piminus_Enubins%d",i),100,0,3.);
    h_theta_targ_piminus_Enubins[i] = new TH1F(Form("h_theta_targ_piminus_Enubins%d",i),
					       Form("h_theta_targ_piminus_Enubins%d",i),100,0,1.);
  }
  // muon decay

  h_MUDEC_Enumustar = new TH1F("h_MUDEC_Enumustar","h_MUDEC_Enumustar",100,0.,55.);//MeV
  h_MUDEC_Enuestar = new TH1F("h_MUDEC_Enuestar","h_MUDEC_Enuestar",100,0.,55.);//MeV
  h_MUDEC_Eanumustar = new TH1F("h_MUDEC_Eanumustar","h_MUDEC_Eanumustar",100,0.,55.);//MeV
  h_MUDEC_Eanuestar = new TH1F("h_MUDEC_Eanuestar","h_MUDEC_Eanuestar",100,0.,55.);//MeV

  h_MUDEC_cthstarMu = new TH1F("h_MUDEC_cthstarMu","h_MUDEC_cthstarMu",100,-1.,1.);
  h_MUDEC_cthstarNu = new TH1F("h_MUDEC_cthstarNu","h_MUDEC_cthstarNu",100,-1.,1.);

  h_MUDEC_probaTunnel = new TH1F("h_MUDEC_probaTunnel","h_MUDEC_probaTunnel",100,0,0.05);
  h_MUDEC_pathTunnel = new TH1F("h_MUDEC_pathTunnel","h_MUDEC_pathTunnel",100,0,50);

  h_MUDEC_probaTunnel_pmu = new TH2F("h_MUDEC_probaTunnel_pmu","h_MUDEC_probaTunnel_pmu",100,0,3,100,0,0.05);
  h_MUDEC_probaTunnel_thmu = new TH2F("h_MUDEC_probaTunnel_thmu","h_MUDEC_probaTunnel_thmu",100,0,2,100,0,0.05);
  h_MUDEC_probaTunnel_rmu = new TH2F("h_MUDEC_probaTunnel_rmu","h_MUDEC_probaTunnel_rmu",100,0,2.5,100,0,0.05);

  h_MUDEC_muxy = new TH2F("h_MUDEC_muxy","h_MUDEC_muxy",100,-3.,3.,100,-3.,3.);//m
  h_MUDEC_muzr = new TH2F("h_MUDEC_muzr","h_MUDEC_muzr",100,zMIN,zMAX,100,0.,3.);//m

  h_MUDEC_polaL_muplus = new TH1F("h_MUDEC_polaL_muplus","h_MUDEC_polaL_muplus",100,-1.,1.);
  h_MUDEC_polaL_muminus = new TH1F("h_MUDEC_polaL_muminus","h_MUDEC_polaL_muminus",100,-1.,1.);
  h_MUDEC_thpimu_lab = new TH1F("h_MUDEC_thpimu_lab","h_MUDEC_thpimu_lab",100,0,1.);

  h_MUDEC_pmupar = new TH2F("h_MUDEC_pmupar","h_MUDEC_pmupar",100,0.,3.,100,0.,3.);//GeV

  // to check the geometry and comare to g3 through hits map
  h_geom_g4 = new TH2F("h_geom_g4","h_geom_g4",2000,-22,-18,2000,0,2.1);
  //h_geom_g4 = new TH2F("h_geom_g4","h_geom_g4",2000,-23,-18,2000,0,2.5);
  //h_geom_g4 = new TH2F("h_geom_g4","h_geom_g4",2000,-23,23,2000,0,2.5);

  //h_decay_flags = new TH1F("h_decay_flags","h_decay_flags",23,-1.5,20.5);
  h_decay_flags = new TH1F("h_decay_flags","h_decay_flags",200,0,32);
  h_decay_NUM = new TH1F("h_decay_NUM","h_decay_NUM",200,0,32);
  h_decay_BR = new TH1F("h_decay_BR","h_decay_BR",200,0,32);
  h_decay_BR_PDG = new TH1F("h_decay_BR_PDG","h_decay_BR_PDG",200,0,32);

  h_decay_BR_PDG->Fill(30,99.9877);  
  h_decay_BR_PDG->Fill(31,99.9877);  
  h_decay_BR_PDG->Fill(1,63.51);  
  h_decay_BR_PDG->Fill(2,63.51);  
  h_decay_BR_PDG->Fill(3,21.17);  
  h_decay_BR_PDG->Fill(4,21.17);  
  h_decay_BR_PDG->Fill(5,5.59);  
  h_decay_BR_PDG->Fill(6,5.59);  
  h_decay_BR_PDG->Fill(7,4.82);  
  h_decay_BR_PDG->Fill(8,4.82);  
  h_decay_BR_PDG->Fill(9,3.18);  
  h_decay_BR_PDG->Fill(10,3.18);  
  h_decay_BR_PDG->Fill(11,1.73);  
  h_decay_BR_PDG->Fill(12,1.73);  
  h_decay_BR_PDG->Fill(13,19.35);  
  h_decay_BR_PDG->Fill(14,19.35);  
  h_decay_BR_PDG->Fill(15,13.5);  
  h_decay_BR_PDG->Fill(16,13.5);  
  h_decay_BR_PDG->Fill(17,21.5);  
  h_decay_BR_PDG->Fill(18,12.38);  
  h_decay_BR_PDG->Fill(19,68.61);  
  h_decay_BR_PDG->Fill(20,31.39);  

  //h_prim_match_pi = new TH2F("h_prim_match_pi","h_prim_match_pi",200,0.,3.,200,0.,3.);
  //h_prim_match_ka = new TH2F("h_prim_match_ka","h_prim_match_ka",200,0.,3.,200,0.,3.);
  //h_prim_match_k0 = new TH2F("h_prim_match_k0","h_prim_match_k0",200,0.,3.,200,0.,3.);

  h_prim_match_pi = new TH2F("h_prim_match_pi","h_prim_match_pi",200,-0.05,0.05,200,0.98,1.02);
  h_prim_match_ka = new TH2F("h_prim_match_ka","h_prim_match_ka",200,-0.05,0.05,200,0.98,1.02);
  h_prim_match_k0 = new TH2F("h_prim_match_k0","h_prim_match_k0",200,-0.05,0.05,200,0.98,1.02);

  
  SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
  analysis->BeginOfRun();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::CheckEOF(){
  if(primaryGen->myEOF){
    G4cout << "********************************************************" << G4endl;
    G4cout << "SBRunAction::CheckEOF() : EOF detected. Run will finish." << G4endl;
    G4cout << "********************************************************" << G4endl;
    
    G4RunManager::GetRunManager()->AbortRun();
  }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::fillPerEvent(G4double ETarg,
			       G4double EGap,
			       G4double LTarg,
			       G4double LGap)
{

  G4cout<<"CALL SBRunAction::fillPerEvent "<<G4endl;
  //accumulate statistic
  //
  sumETarg += ETarg;  sum2ETarg += ETarg*ETarg;
  sumEGap += EGap;  sum2EGap += EGap*EGap;
  
  sumLTarg += LTarg;  sum2LTarg += LTarg*LTarg;
  sumLGap += LGap;  sum2LGap += LGap*LGap;  

  SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
  analysis->FillHisto(ETarg,LTarg);

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::DIFStat(G4double ndifpiplus,
			  G4double ndifpiminus,
			  G4double ndifkplus,
			  G4double ndifkminus,
			  G4double ndifk0S,
			  G4double ndifk0L)
{

  G4cout<<"CALL SBRunAction::DIFStat "<<G4endl;
  //accumulate statistic
  //
  NDIF_piplus_TOT += ndifpiplus;
  NDIF_piminus_TOT += ndifpiminus;
  NDIF_Kplus_TOT += ndifkplus;
  NDIF_Kminus_TOT += ndifkminus;
  NDIF_KzeroS_TOT += ndifk0S;
  NDIF_KzeroL_TOT += ndifk0L;

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::fillPerEvent1(G4double p_muplus_PI,
			        G4double p_muminus_PI,
			        G4double p_muplus_K,
			        G4double p_muminus_K,
			        G4double E_numu_PI,
			        G4double E_anumu_PI,
			        G4double E_numu_K,
			        G4double E_anumu_K)
{
  G4cout<<"CALL SBRunAction::fillPerEvent1 "<<G4endl;
 
  SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
  analysis->FillHisto2(p_muplus_PI,p_muminus_PI,p_muplus_K,p_muminus_K,E_numu_PI,E_anumu_PI,E_numu_K,E_anumu_K);

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::fillDIF(G4double x,
			  G4double y,
			  G4double z,
			  G4double px,
			  G4double py,
			  G4double pz,
			  G4double pxnu,
			  G4double pynu,
			  G4double pznu,
			  G4int moth,
			  G4int q)
{
  G4cout<<"CALL SBRunAction::fillDIF "<<G4endl;
 
  SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
  analysis->FillGeometryDecay(x,y,z,px,py,pz,pxnu,pynu,pznu,moth,q);

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::fillEXIT(G4double x,
			   G4double y,
			   G4double z,
			   G4double px,
			   G4double py,
			   G4double pz,
			   G4int moth)
{
  G4cout<<"CALL SBRunAction::fillEXIT "<<G4endl;
  G4double r = sqrt(x*x+y*y);
  G4double p = sqrt(px*px+py*py+pz*pz);
  G4double pt = sqrt(px*px+py*py);
  G4double th = 0;
  if(p)th=acos(pz/p);

  if((p!=0.)&&(x!=0.)&&(y!=0.)&&(z!=0.)){

    if(r<3/CLHEP::cm)G4cout <<"SBRunAction: EXIT POINT x "<< 
	     x/CLHEP::cm <<" y "<< y/CLHEP::cm <<" r "<< r/CLHEP::cm<<" (cm) "
		  <<" p "<<p/CLHEP::GeV<<" (GeV) z "<<z/CLHEP::m<< " (m) "
		  <<G4endl;

/////////////////////////////////////////////////

    if(moth==1){//piplus
      h_pt_exit_piplus->Fill(pt/CLHEP::GeV);
      h_p_exit_piplus->Fill(p/CLHEP::GeV);
      h_xy_exit_piplus->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_piplus->Fill(z/CLHEP::m);
      //G4cout <<" crash " <<z/m <<G4endl;
      h_r_exit_piplus->Fill(r/CLHEP::cm);
      h_pVSr_exit_piplus->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_piplus->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_piplus->Fill(th,r/CLHEP::cm);
      h_theta_exit_piplus->Fill(th);
    } else if (moth==2){//piminus
      h_pt_exit_piminus->Fill(pt/CLHEP::GeV);
      h_p_exit_piminus->Fill(p/CLHEP::GeV);
      h_xy_exit_piminus->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_piminus->Fill(z/CLHEP::m);
      h_r_exit_piminus->Fill(r/CLHEP::cm);
      h_pVSr_exit_piminus->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_piminus->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_piminus->Fill(th,r/CLHEP::cm);
      h_theta_exit_piminus->Fill(th);
    }else if(moth==3){//muplus
      h_pt_exit_muplus->Fill(pt/CLHEP::GeV);
      h_p_exit_muplus->Fill(p/CLHEP::GeV);
      h_xy_exit_muplus->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_muplus->Fill(z/CLHEP::m);
      h_r_exit_muplus->Fill(r/CLHEP::cm);
      h_pVSr_exit_muplus->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_muplus->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_muplus->Fill(th,r/CLHEP::cm);
      h_theta_exit_muplus->Fill(th);    
    } else if (moth==4){//muminus
      h_pt_exit_muminus->Fill(pt/CLHEP::GeV);
      h_p_exit_muminus->Fill(p/CLHEP::GeV);
      h_xy_exit_muminus->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_muminus->Fill(z/CLHEP::m);
      h_r_exit_muminus->Fill(r/CLHEP::cm);
      h_pVSr_exit_muminus->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_muminus->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_muminus->Fill(th,r/CLHEP::cm);
      h_theta_exit_muminus->Fill(th);    
    } else if(moth==5){//kplus
      h_pt_exit_kplus->Fill(pt/CLHEP::GeV);
      h_p_exit_kplus->Fill(p/CLHEP::GeV);
      h_xy_exit_kplus->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_kplus->Fill(z/CLHEP::m);
      h_r_exit_kplus->Fill(r/CLHEP::cm);
      h_pVSr_exit_kplus->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_kplus->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_kplus->Fill(th,r/CLHEP::cm);
      h_theta_exit_kplus->Fill(th);    
    } else if (moth==6){//kminus
      h_pt_exit_kminus->Fill(pt/CLHEP::GeV);
      h_p_exit_kminus->Fill(p/CLHEP::GeV);
      h_xy_exit_kminus->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_kminus->Fill(z/CLHEP::m);
      h_r_exit_kminus->Fill(r/CLHEP::cm);
      h_pVSr_exit_kminus->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_kminus->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_kminus->Fill(th,r/CLHEP::cm);
      h_theta_exit_kminus->Fill(th);    
    } else  if(moth==7){//k0L
      h_pt_exit_k0L->Fill(pt/CLHEP::GeV);
      h_p_exit_k0L->Fill(p/CLHEP::GeV);
      h_xy_exit_k0L->Fill(x/CLHEP::cm,y/CLHEP::cm);
      h_z_exit_k0L->Fill(z/CLHEP::m);
      h_r_exit_k0L->Fill(r/CLHEP::cm);
      h_pVSr_exit_k0L->Fill(p/CLHEP::GeV,r/CLHEP::cm);
      h_pVStheta_exit_k0L->Fill(th,p/CLHEP::GeV);
      h_thetaVSr_exit_k0L->Fill(th,r/CLHEP::cm);
      h_theta_exit_k0L->Fill(th);    
    }
  }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::fillTARG(/*G4double x,
			   G4double y,
			   G4double z,
			   G4double px,
			   G4double py,
			   G4double pz,
			   G4int moth*/
			   G4double enu=0)
{
  G4cout<<"CALL SBRunAction::fillTARG "<<G4endl;
  G4double x=primaryGen->XPrimary;
  G4double y=primaryGen->YPrimary;
  G4double z=primaryGen->ZPrimary;
  G4double zabs=primaryGen->ZPrimary_G4frame;
  G4double px=primaryGen->PXPrimary;
  G4double py=primaryGen->PYPrimary;
  G4double pz=primaryGen->PZPrimary;

  //G4int moth=1; // temp!!
  //G4double r = sqrt(x*x+y*y);

  G4double p = sqrt((px*px)+(py*py)+(pz*pz));
  G4double pt = sqrt((px*px)+(py*py));
  G4double th = 0;
  if(p)th=acos(pz/p);
  
  //G4cout <<" brius "<< th << " "<< p/GeV <<" "<<primaryGen->particleName<<G4endl;

  if((p!=0.)&&(x!=0.)&&(y!=0.)&&(z!=0.)){
    if(primaryGen->particleName=="pi+"){
      h_pt_targ_piplus->Fill(pt/CLHEP::GeV);
      h_p_targ_piplus->Fill(p/CLHEP::GeV);
      h_z_targ_piplus->Fill(z/CLHEP::cm);
      h_zabs_targ_piplus->Fill(zabs/CLHEP::m);
      h_pVStheta_targ_piplus->Fill(th,p/CLHEP::GeV);
      h_theta_targ_piplus->Fill(th);

      for(int j=0;j<NENB;j++){
	//G4cout << "pernice "<<enu/GeV<<" "<<ENULIMS[j]<<G4endl;
	if((enu/CLHEP::GeV>ENULIMS[j])&&(enu/CLHEP::GeV<ENULIMS[j+1])){
	  h_pVStheta_targ_piplus_Enubins[j]->Fill(th,p/CLHEP::GeV);
	  h_theta_targ_piplus_Enubins[j]->Fill(th);
	  h_p_targ_piplus_Enubins[j]->Fill(p/CLHEP::GeV);
	}
      }


    } else if(primaryGen->particleName=="pi-"){
      h_pt_targ_piminus->Fill(pt/CLHEP::GeV);
      h_p_targ_piminus->Fill(p/CLHEP::GeV);
      h_z_targ_piminus->Fill(z/CLHEP::cm);
      h_zabs_targ_piminus->Fill(zabs/CLHEP::m);
      h_pVStheta_targ_piminus->Fill(th,p/CLHEP::GeV);
      h_theta_targ_piminus->Fill(th);

      for(int j=0;j<NENB;j++){
	if((enu/CLHEP::GeV>ENULIMS[j])&&(enu/CLHEP::GeV<ENULIMS[j+1])){
	  h_pVStheta_targ_piminus_Enubins[j]->Fill(th,p/CLHEP::GeV);
	  h_theta_targ_piminus_Enubins[j]->Fill(th);
	  h_p_targ_piminus_Enubins[j]->Fill(p/CLHEP::GeV);
	}
      }

    }
  }
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::EndOfRunAction(const G4Run* aRun)
{
  G4cout<<"CALL SBRunAction::EndOfRunAction "<<G4endl;
  G4int NbOfEvents = aRun->GetNumberOfEvent();
  if (NbOfEvents == 0) return;
  
  DoFinalOps(NbOfEvents);

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::SumFluxesFlavours()
{
  SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
  analysis->FillSumFluxesFlavours();
  
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void SBRunAction::DoFinalOps(G4int NbOfEvents){
  
  G4cout<<"SBRunAction::DoFinalOps"<<G4endl;

  //compute statistics: mean and rms
  
  sumETarg /= NbOfEvents; sum2ETarg /= NbOfEvents;
  G4double rmsETarg = sum2ETarg - sumETarg*sumETarg;
  if (rmsETarg >0.) rmsETarg = std::sqrt(rmsETarg); else rmsETarg = 0.;
  
  sumEGap /= NbOfEvents; sum2EGap /= NbOfEvents;
  G4double rmsEGap = sum2EGap - sumEGap*sumEGap;
  if (rmsEGap >0.) rmsEGap = std::sqrt(rmsEGap); else rmsEGap = 0.;
  
  sumLTarg /= NbOfEvents; sum2LTarg /= NbOfEvents;
  G4double rmsLTarg = sum2LTarg - sumLTarg*sumLTarg;
  if (rmsLTarg >0.) rmsLTarg = std::sqrt(rmsLTarg); else rmsLTarg = 0.;
  
  sumLGap /= NbOfEvents; sum2LGap /= NbOfEvents;
  G4double rmsLGap = sum2LGap - sumLGap*sumLGap;
  if (rmsLGap >0.) rmsLGap = std::sqrt(rmsLGap); else rmsLGap = 0.;
  
  /**************************************/
  // normalize to number of processed pots !
  G4double ProcEvtsScale = 1.e6/primaryGen->GetFLUKAPOTs();
  G4double K_REP = primaryGen->K_REPL;

  G4cout << "SBRunAction: K replication factor used in fluxes scaling "<< K_REP << G4endl;
  /////////////
  SBAnalysisManager* analysis = SBAnalysisManager::getInstance();
  analysis->FillFinalOps(ProcEvtsScale,K_REP);
  ////////////
    
  G4cout << "Processed FLUKA events is " << primaryGen->GetFLUKAPOTs()<<"."<< G4endl;
  G4cout << "Normalization factor " << ProcEvtsScale <<" applied to fluxes."<< G4endl;  

  G4cout << "decay in flight summary: "<< 
    " pi+ "<<NDIF_piplus_TOT<<
    " pi- "<<NDIF_piminus_TOT<<
    " K+ "<<NDIF_Kplus_TOT<<
    " K- "<<NDIF_Kminus_TOT<<
    " K0L "<<NDIF_KzeroL_TOT<<
    " K0S "<<NDIF_KzeroS_TOT<<G4endl;

  G4cout << "    per/p.o.t.: "<< 
    " pi+ "<<NDIF_piplus_TOT/primaryGen->GetFLUKAPOTs()<<
    " pi- "<<NDIF_piminus_TOT/primaryGen->GetFLUKAPOTs()<<
    " K+ "<<NDIF_Kplus_TOT/primaryGen->GetFLUKAPOTs()<<
    " K- "<<NDIF_Kminus_TOT/primaryGen->GetFLUKAPOTs()<<G4endl;

  /********/

  h_pt_exit_piplus->Scale(ProcEvtsScale);
  h_p_exit_piplus->Scale(ProcEvtsScale);
  h_xy_exit_piplus->Scale(ProcEvtsScale);
  h_z_exit_piplus->Scale(ProcEvtsScale);
  h_r_exit_piplus->Scale(ProcEvtsScale);
  h_pVSr_exit_piplus->Scale(ProcEvtsScale);
  h_pVStheta_exit_piplus->Scale(ProcEvtsScale);
  h_thetaVSr_exit_piplus->Scale(ProcEvtsScale);
  h_theta_exit_piplus->Scale(ProcEvtsScale);
  
  h_pt_exit_piminus->Scale(ProcEvtsScale);
  h_p_exit_piminus->Scale(ProcEvtsScale);
  h_xy_exit_piminus->Scale(ProcEvtsScale);
  h_z_exit_piminus->Scale(ProcEvtsScale);
  h_r_exit_piminus->Scale(ProcEvtsScale);
  h_pVSr_exit_piminus->Scale(ProcEvtsScale);
  h_pVStheta_exit_piminus->Scale(ProcEvtsScale);
  h_thetaVSr_exit_piminus->Scale(ProcEvtsScale);
  h_theta_exit_piminus->Scale(ProcEvtsScale);
  
  h_pt_exit_kplus->Scale(ProcEvtsScale);
  h_p_exit_kplus->Scale(ProcEvtsScale);
  h_xy_exit_kplus->Scale(ProcEvtsScale);
  h_z_exit_kplus->Scale(ProcEvtsScale);
  h_r_exit_kplus->Scale(ProcEvtsScale);
  h_pVSr_exit_kplus->Scale(ProcEvtsScale);
  h_pVStheta_exit_kplus->Scale(ProcEvtsScale);
  h_thetaVSr_exit_kplus->Scale(ProcEvtsScale);
  h_theta_exit_kplus->Scale(ProcEvtsScale);

  h_pt_exit_kminus->Scale(ProcEvtsScale);
  h_p_exit_kminus->Scale(ProcEvtsScale);
  h_xy_exit_kminus->Scale(ProcEvtsScale);
  h_z_exit_kminus->Scale(ProcEvtsScale);
  h_r_exit_kminus->Scale(ProcEvtsScale);
  h_pVSr_exit_kminus->Scale(ProcEvtsScale);
  h_pVStheta_exit_kminus->Scale(ProcEvtsScale);
  h_thetaVSr_exit_kminus->Scale(ProcEvtsScale);
  h_theta_exit_kminus->Scale(ProcEvtsScale);
  
  h_pt_exit_muplus->Scale(ProcEvtsScale);
  h_p_exit_muplus->Scale(ProcEvtsScale);
  h_xy_exit_muplus->Scale(ProcEvtsScale);
  h_z_exit_muplus->Scale(ProcEvtsScale);
  h_r_exit_muplus->Scale(ProcEvtsScale);
  h_pVSr_exit_muplus->Scale(ProcEvtsScale);
  h_pVStheta_exit_muplus->Scale(ProcEvtsScale);
  h_thetaVSr_exit_muplus->Scale(ProcEvtsScale);
  h_theta_exit_muplus->Scale(ProcEvtsScale);
  
  h_pt_exit_muminus->Scale(ProcEvtsScale);
  h_p_exit_muminus->Scale(ProcEvtsScale);
  h_xy_exit_muminus->Scale(ProcEvtsScale);
  h_z_exit_muminus->Scale(ProcEvtsScale);
  h_r_exit_muminus->Scale(ProcEvtsScale);
  h_pVSr_exit_muminus->Scale(ProcEvtsScale);
  h_pVStheta_exit_muminus->Scale(ProcEvtsScale);
  h_thetaVSr_exit_muminus->Scale(ProcEvtsScale);
  h_theta_exit_muminus->Scale(ProcEvtsScale);
  
  h_pt_exit_k0L->Scale(ProcEvtsScale);
  h_p_exit_k0L->Scale(ProcEvtsScale);
  h_xy_exit_k0L->Scale(ProcEvtsScale);
  h_z_exit_k0L->Scale(ProcEvtsScale);
  h_r_exit_k0L->Scale(ProcEvtsScale);
  h_pVSr_exit_k0L->Scale(ProcEvtsScale);
  h_pVStheta_exit_k0L->Scale(ProcEvtsScale);
  h_thetaVSr_exit_k0L->Scale(ProcEvtsScale);
  h_theta_exit_k0L->Scale(ProcEvtsScale);

  // target level

  h_pt_targ_piplus->Scale(ProcEvtsScale);
  h_p_targ_piplus->Scale(ProcEvtsScale);
  h_z_targ_piplus->Scale(ProcEvtsScale);
  h_zabs_targ_piplus->Scale(ProcEvtsScale);
  h_pVStheta_targ_piplus->Scale(ProcEvtsScale);
  h_theta_targ_piplus->Scale(ProcEvtsScale);
  
  h_pt_targ_piminus->Scale(ProcEvtsScale);
  h_p_targ_piminus->Scale(ProcEvtsScale);
  h_z_targ_piminus->Scale(ProcEvtsScale);
  h_zabs_targ_piminus->Scale(ProcEvtsScale);
  h_pVStheta_targ_piminus->Scale(ProcEvtsScale);
  h_theta_targ_piminus->Scale(ProcEvtsScale);

  // DIF                                       //////////////////////////////////////////////////////////////////////////////////////////
/*
  h_piminus_DIF_r->Scale(ProcEvtsScale);
  h_piminus_DIF_z->Scale(ProcEvtsScale);
  h_piminus_DIF_xy->Scale(ProcEvtsScale);
  h_piminus_DIF_zr->Scale(ProcEvtsScale);
  
  h_Kminus_DIF_r->Scale(ProcEvtsScale);
  h_Kminus_DIF_z->Scale(ProcEvtsScale);
  h_Kminus_DIF_xy->Scale(ProcEvtsScale);
  h_Kminus_DIF_zr->Scale(ProcEvtsScale);
  
  h_piplus_DIF_r->Scale(ProcEvtsScale);
  h_piplus_DIF_z->Scale(ProcEvtsScale);
  h_piplus_DIF_xy->Scale(ProcEvtsScale);
  h_piplus_DIF_zr->Scale(ProcEvtsScale);
  
  h_Kplus_DIF_r->Scale(ProcEvtsScale);
  h_Kplus_DIF_z->Scale(ProcEvtsScale);
  h_Kplus_DIF_xy->Scale(ProcEvtsScale);
  h_Kplus_DIF_zr->Scale(ProcEvtsScale);
*/  
  /******************************************************************************************************************************/


  SumFluxesFlavours();

  //h_numu->Scale(ProcEvtsScale);
  //h_anumu->Scale(ProcEvtsScale);
  //h_nue->Scale(ProcEvtsScale);
  //h_anue->Scale(ProcEvtsScale);

  // ------------------- SPL
  G4double BL = 130.;
  G4String fnam="";
  if(primaryGen->GetJOBID()>=0){
    fnam = Form("nufl_%06d_GLOBES_%3.0fKm.txt",primaryGen->GetJOBID(),BL);
  }else{
    fnam = Form("nufl_-%06d_GLOBES_%3.0fKm.txt",-primaryGen->GetJOBID(),BL);
  }
  analysis->PrepareGLoBESFlux(fnam,BL);
  
  //-------------------- SLANIC
  BL = 1544.;
  if(primaryGen->GetJOBID()>=0){
    fnam = Form("nufl_%06d_GLOBES_%4.0fKm.txt",primaryGen->GetJOBID(),BL);
  }else{
    fnam = Form("nufl_-%06d_GLOBES_%4.0fKm.txt",-primaryGen->GetJOBID(),BL);
  }
  analysis->PrepareGLoBESFlux(fnam,BL);

  //-------------------- GENERIC 100Km
  BL = 100.;
  if(primaryGen->GetJOBID()>=0){
    fnam = Form("nufl_%06d_GLOBES_%3.0fKm.txt",primaryGen->GetJOBID(),BL);
  }else{
    fnam = Form("nufl_-%06d_GLOBES_%3.0fKm.txt",-primaryGen->GetJOBID(),BL);
  }
  analysis->PrepareGLoBESFlux(fnam,BL);
 //---------------------


  //FluxesStats();
  
  bool WriteHistogramsToFile = true;
  
  if (WriteHistogramsToFile) {
    
    // fROOT->cd();
   //
   analysis->EndOfRun();
   

    /////////////////////////////////////

    h_pt_exit_piplus->Write();
    h_p_exit_piplus->Write();
    h_xy_exit_piplus->Write();
    h_z_exit_piplus->Write();
    h_r_exit_piplus->Write();
    h_pVSr_exit_piplus->Write();
    h_pVStheta_exit_piplus->Write();
    h_thetaVSr_exit_piplus->Write();
    h_theta_exit_piplus->Write();

    h_pt_exit_piminus->Write();
    h_p_exit_piminus->Write();
    h_xy_exit_piminus->Write();
    h_z_exit_piminus->Write();
    h_r_exit_piminus->Write();
    h_pVSr_exit_piminus->Write();
    h_pVStheta_exit_piminus->Write();
    h_thetaVSr_exit_piminus->Write();
    h_theta_exit_piminus->Write();

    h_pt_exit_kplus->Write();
    h_p_exit_kplus->Write();
    h_xy_exit_kplus->Write();
    h_z_exit_kplus->Write();
    h_r_exit_kplus->Write();
    h_pVSr_exit_kplus->Write();
    h_pVStheta_exit_kplus->Write();
    h_thetaVSr_exit_kplus->Write();
    h_theta_exit_kplus->Write();

    h_pt_exit_kminus->Write();
    h_p_exit_kminus->Write();
    h_xy_exit_kminus->Write();
    h_z_exit_kminus->Write();
    h_r_exit_kminus->Write();
    h_pVSr_exit_kminus->Write();
    h_pVStheta_exit_kminus->Write();
    h_thetaVSr_exit_kminus->Write();
    h_theta_exit_kminus->Write();
 
    h_pt_exit_muplus->Write();
    h_p_exit_muplus->Write();
    h_xy_exit_muplus->Write();
    h_z_exit_muplus->Write();
    h_r_exit_muplus->Write();
    h_pVSr_exit_muplus->Write();
    h_pVStheta_exit_muplus->Write();
    h_thetaVSr_exit_muplus->Write();
    h_theta_exit_muplus->Write();

    h_pt_exit_muminus->Write();
    h_p_exit_muminus->Write();
    h_xy_exit_muminus->Write();
    h_z_exit_muminus->Write();
    h_r_exit_muminus->Write();
    h_pVSr_exit_muminus->Write();
    h_pVStheta_exit_muminus->Write();
    h_thetaVSr_exit_muminus->Write();
    h_theta_exit_muminus->Write();

    h_pt_exit_k0L->Write();
    h_p_exit_k0L->Write();
    h_xy_exit_k0L->Write();
    h_z_exit_k0L->Write();
    h_r_exit_k0L->Write();
    h_pVSr_exit_k0L->Write();
    h_pVStheta_exit_k0L->Write();
    h_thetaVSr_exit_k0L->Write();
    h_theta_exit_k0L->Write();

    h_pt_targ_piplus->Write();
    h_p_targ_piplus->Write();
    h_z_targ_piplus->Write();
    h_zabs_targ_piplus->Write();
    h_theta_targ_piplus->Write();
    h_pVStheta_targ_piplus->Write();
    
    for(int i=0;i<NENB;i++){
      h_pVStheta_targ_piplus_Enubins[i]->Write();
      h_p_targ_piplus_Enubins[i]->Write();
      h_theta_targ_piplus_Enubins[i]->Write();
    }

    h_pt_targ_piminus->Write();
    h_p_targ_piminus->Write();
    h_z_targ_piminus->Write();
    h_zabs_targ_piminus->Write();
    h_theta_targ_piminus->Write();
    h_pVStheta_targ_piminus->Write();

    for(int i=0;i<NENB;i++){
      h_pVStheta_targ_piminus_Enubins[i]->Write();
      h_p_targ_piminus_Enubins[i]->Write();
      h_theta_targ_piminus_Enubins[i]->Write();
    }

    // muon decay
    h_MUDEC_probaTunnel->Write();
    h_MUDEC_pathTunnel->Write();

    h_MUDEC_probaTunnel_pmu->Write();
    h_MUDEC_probaTunnel_thmu->Write();
    h_MUDEC_probaTunnel_rmu->Write();

    h_MUDEC_Enumustar->Write();
    h_MUDEC_Enuestar->Write();
    h_MUDEC_Eanumustar->Write();
    h_MUDEC_Eanuestar->Write();

    h_MUDEC_muxy->Write();
    h_MUDEC_muzr->Write();
    
    h_MUDEC_cthstarMu->Write();
    h_MUDEC_cthstarNu->Write();

    h_MUDEC_polaL_muplus->Write();
    h_MUDEC_polaL_muminus->Write();
    h_MUDEC_thpimu_lab->Write();

    h_MUDEC_pmupar->Write();
    h_geom_g4->Write();

    h_decay_flags->Write();
    h_decay_NUM->Write();
    h_decay_BR->Write();
    h_decay_BR_PDG->Write();

    h_prim_match_pi->Write();
    h_prim_match_ka->Write();
    h_prim_match_k0->Write();

    fROOT->Close();    
  }

  //print
  //
  G4cout
     << "\n--------------------End of Run------------------------------\n"
     //<< "\n mean Energy in Target : " << G4BestUnit(sumETarg,"Energy")
     //<< " +- "                          << G4BestUnit(rmsETarg,"Energy")  
     << "\n mean Energy in Target : " << sumETarg
     << " +- "                          << rmsETarg  
     //<< "\n mean Energy in Gap      : " << G4BestUnit(sumEGap,"Energy")
     //<< " +- "                          << G4BestUnit(rmsEGap,"Energy")
     << G4endl;
     
  G4cout
     //<< "\n mean trackLength in Target : " << G4BestUnit(sumLTarg,"Length")
     //<< " +- "                               << G4BestUnit(rmsLTarg,"Length")  
     << "\n mean trackLength in Target : " << sumLTarg
     << " +- "                               << rmsLTarg  
     //<< "\n mean trackLength in Gap      : " << G4BestUnit(sumLGap,"Length")
     //<< " +- "                               << G4BestUnit(rmsLGap,"Length")
     << "\n------------------------------------------------------------\n"
     << G4endl;
}
#include "SBRunActionMessenger.hh"

#include "SBRunAction.hh"
#include "G4UIdirectory.hh"
#include "G4UIcmdWithADoubleAndUnit.hh"
#include "G4UIcmdWithAnInteger.hh"

#include "globals.hh"

SBRunActionMessenger::SBRunActionMessenger(SBRunAction* RunAct) :runAction(RunAct)
{

  SBrunDir = new G4UIdirectory("/SB/run/");
  SBrunDir->SetGuidance("RunAction control");

  NbinCmd = new G4UIcmdWithAnInteger("/SB/run/SetNbin",this);
  NbinCmd->SetGuidance("Set number of bins in neutrino energy");
  NbinCmd->SetParameterName("Nbin",false);
  NbinCmd->SetRange("Nbin>0");
  NbinCmd->AvailableForStates(G4State_PreInit,G4State_Idle);

  EnuMINCmd = new G4UIcmdWithADoubleAndUnit("/SB/run/SetEnuMIN",this);
  EnuMINCmd->SetGuidance("Set MIN neutrino energy in flux histogram");
  EnuMINCmd->SetParameterName("EnuMIN",false);
  EnuMINCmd->SetRange("EnuMIN>=0");
  EnuMINCmd->SetUnitCategory("Energy");
  EnuMINCmd->AvailableForStates(G4State_PreInit,G4State_Idle);

  EnuMAXCmd = new G4UIcmdWithADoubleAndUnit("/SB/run/SetEnuMAX",this);
  EnuMAXCmd->SetGuidance("Set MAX neutrino energy in flux histogram");
  EnuMAXCmd->SetParameterName("EnuMAX",false);
  EnuMAXCmd->SetRange("EnuMAX>0");
  EnuMAXCmd->SetUnitCategory("Energy");
  EnuMAXCmd->AvailableForStates(G4State_PreInit,G4State_Idle);
}

SBRunActionMessenger::~SBRunActionMessenger()
{
  delete SBrunDir;
  delete NbinCmd;
  delete EnuMAXCmd;
  delete EnuMINCmd;
}

void SBRunActionMessenger::SetNewValue(G4UIcommand* command,G4String newValue)
{
  if(command == NbinCmd)
    {runAction->SetNbin(NbinCmd->GetNewIntValue(newValue));}
  if(command == EnuMAXCmd)
    {runAction->SetEnuMAX(EnuMAXCmd->GetNewDoubleValue(newValue));}
  if(command == EnuMINCmd)
    {runAction->SetEnuMIN(EnuMINCmd->GetNewDoubleValue(newValue));}
}
#include "SBSteppingAction.hh"
#include "SBDetectorConstruction.hh"
#include "SBPrimaryGeneratorAction.hh"
#include "SBEventAction.hh"
#include "SBRunAction.hh"

#include "G4Step.hh"
#include "G4VProcess.hh"

#include "G4NeutrinoMu.hh"
#include "G4AntiNeutrinoMu.hh"
#include "G4NeutrinoE.hh"
#include "G4AntiNeutrinoE.hh"
#include "G4PionPlus.hh"
#include "G4PionMinus.hh"
#include "G4KaonPlus.hh"
#include "G4KaonMinus.hh"
#include "G4MuonPlus.hh"
#include "G4MuonMinus.hh"
#include "G4KaonZeroLong.hh"
#include "G4KaonZeroShort.hh"
#include "G4KaonZero.hh"
#include "G4AntiKaonZero.hh"
#include "G4Lambda.hh"
#include "G4AntiLambda.hh"

SBSteppingAction::SBSteppingAction(SBDetectorConstruction* det,SBEventAction* evt,SBPrimaryGeneratorAction* primGen, SBRunAction* run)
  :detector(det), evtAct(evt), primaryGen(primGen), runAct(run)
{ 
  pOutFileExitTunnel.open("ExitTunnel.data");
  pOutFileExitTarget.open("ExitTarget.data");
}

SBSteppingAction::~SBSteppingAction()
{
  pOutFileExitTunnel.close();
  pOutFileExitTarget.close();
}


void SBSteppingAction::UserSteppingAction(const G4Step* aStep)
{

  G4bool DEB = false;
  if(evtAct->GetSBVerbosity()>0)DEB=true;
  
  G4String INUMU = G4NeutrinoMu::NeutrinoMu()->GetParticleName();
  G4String IANUMU = G4AntiNeutrinoMu::AntiNeutrinoMu()->GetParticleName();
  G4String INUE = G4NeutrinoE::NeutrinoE()->GetParticleName();
  G4String IANUE = G4AntiNeutrinoE::AntiNeutrinoE()->GetParticleName();
  G4String IPIMINUS = G4PionMinus::PionMinus()->GetParticleName();
  G4String IPIPLUS = G4PionPlus::PionPlus()->GetParticleName();
  G4String IMUMINUS = G4MuonMinus::MuonMinus()->GetParticleName();
  G4String IMUPLUS = G4MuonPlus::MuonPlus()->GetParticleName();
  G4String IKMINUS = G4KaonMinus::KaonMinus()->GetParticleName();
  G4String IKPLUS = G4KaonPlus::KaonPlus()->GetParticleName();

  //G4int PDGpiplus =  G4PionPlus::PionPlus()->GetPDGEncoding();
  //G4int PDGpiminus =  G4PionMinus::PionMinus()->GetPDGEncoding();
  G4int PDGkplus =  G4KaonPlus::KaonPlus()->GetPDGEncoding();
  G4int PDGkminus =  G4KaonMinus::KaonMinus()->GetPDGEncoding();
  G4int PDGk0L =  G4KaonZeroLong::KaonZeroLong()->GetPDGEncoding();
  G4int PDGk0S =  G4KaonZeroShort::KaonZeroShort()->GetPDGEncoding();
  G4int PDGk0 =  G4KaonZero::KaonZero()->GetPDGEncoding();
  G4int PDGak0 =  G4AntiKaonZero::AntiKaonZero()->GetPDGEncoding();
  G4int PDGL =  G4Lambda::Lambda()->GetPDGEncoding();
  G4int PDGaL =  G4AntiLambda::AntiLambda()->GetPDGEncoding();

  //G4cout<<"CALL SBSteppingAction::UserSteppingAction"<<G4endl;

  G4VPhysicalVolume* volume0 = aStep->GetPreStepPoint()->GetTouchableHandle()->GetVolume();  

  G4double edep = aStep->GetTotalEnergyDeposit();
  G4double stepl = 0.;
  if(aStep->GetTrack()->GetDefinition()->GetPDGCharge() != 0.)
    stepl = aStep->GetStepLength();
  
  if (volume0 == detector->GetTarget()) evtAct->AddTarg(edep,stepl);

  G4StepPoint* point1 = aStep->GetPreStepPoint();
  G4StepPoint* point2 = aStep->GetPostStepPoint();

  G4ThreeVector pos1 = point1->GetPosition();
  G4ThreeVector pos2 = point2->GetPosition();  
  G4ThreeVector mom1 = point1->GetMomentum();
  G4ThreeVector mom2 = point2->GetMomentum();  

  G4TouchableHandle touch1 = point1->GetTouchableHandle();
  G4VPhysicalVolume* volume = touch1->GetVolume();//To get the current volume:
  G4String name = volume->GetName();

  G4TouchableHandle touch2 = point2->GetTouchableHandle();

  G4Track* track = aStep->GetTrack();
  G4int PID = track->GetDynamicParticle()->GetPDGcode();

  G4ThreeVector momentum = track->GetMomentum();
  G4ThreeVector pos = track->GetPosition();
  //G4double kinEnergy     = track->GetKineticEnergy();
  //G4double globalTime    = track->GetGlobalTime();  

  G4double xprim=0,yprim=0,zprim=0,pxprim=0,pyprim=0,pzprim=0;
  xprim = primaryGen->GetPrimaryX();
  yprim = primaryGen->GetPrimaryY();
  zprim = primaryGen->GetPrimaryZ();
  pxprim = primaryGen->GetPrimaryPX();
  pyprim = primaryGen->GetPrimaryPY();
  pzprim = primaryGen->GetPrimaryPZ();

  G4double pTOTprim = sqrt(pxprim*pxprim+pyprim*pyprim+pzprim*pzprim);
  G4double pTOT = sqrt(momentum.x()*momentum.x()+momentum.y()*momentum.y()+momentum.z()*momentum.z());
  //G4double pTOT1 = sqrt(mom1.x()*mom1.x()+mom1.y()*mom1.y()+mom1.z()*mom1.z());
  G4double pTOT2 = sqrt(mom2.x()*mom2.x()+mom2.y()*mom2.y()+mom2.z()*mom2.z());
  G4double polarangle = 0;
  //if(pTOT!=0.)polarangle = acos(momentum.z()/pTOT);
  //if(pTOT!=0.)polarangle = acos(momentum.z()/pTOT);
  //if(pTOT1!=0.)polarangle = acos(mom1.z()/pTOT1);
  if(pTOT2!=0.)polarangle = acos(mom2.z()/pTOT2);
  G4ThreeVector mdir = track->GetMomentumDirection();

  //if(track->GetDefinition()->GetParticleName()=="pi+"){
  //G4cout << "TAG " << pos.z() << " " << sqrt(pos.x()*pos.x()+pos.y()*pos.y()) << " "
  //G4cout << "TAG " << pos1.z() << " " << sqrt(pos1.x()*pos1.x()+pos1.y()*pos1.y()) << " "
  /*
    G4cout << "TAG " << pos2.z() << " " << sqrt(pos2.x()*pos2.x()+pos2.y()*pos2.y()) << " "
    << polarangle <<" " 
    << pTOTprim << " " 
    << zprim << " " 
    << G4endl;
  */
  //}

  //if((polarangle>0)&&(polarangle>0.9)&&(pos.z()<-7800)&&pTOTprim>0.35&&pTOTprim<0.4){//aggiungere PID
  //if((polarangle>0.95)&&(pos1.z()<-7800)){
  //if(polarangle!=0)
  //G4cout << "  SURFACE " << pos.x() << " " << pos.y() << " " << pos.z() << " "<< pTOTprim << " " << polarangle <<" "<< mdir.z()/sqrt(mdir.x()*mdir.x()+mdir.y()*mdir.y()+mdir.z()*mdir.z())<<G4endl;
  //}

  //if ((point1->GetStepStatus() == fGeomBoundary)&&(name=="TUNL"))G4cout<< "GEOMCHECK TUNNEL" <<G4endl;
  if(runAct->h_geom_g4->GetEntries()<100){
    if ((point1->GetStepStatus()==fGeomBoundary)||(point1->GetStepStatus()==fWorldBoundary)){
      //G4cout<< "GEOMCHECK ALL " <<pos1.x()<<" "<<pos1.y()<<" "<<pos1.z()<<G4endl;
      runAct->h_geom_g4->Fill(pos1.z()/CLHEP::m,sqrt(pow(pos1.x()/CLHEP::m,2)+pow(pos1.y()/CLHEP::m,2)));    
    }
  }
  //G4VPhysicalVolume* PV2 = point2->GetPhysicalVolume(); 
  //if (point2->GetStepStatus()==fWorldBoundary)G4cout<<"BRIUS"<<G4endl;
  //if (name=="World"){
  //if (!PV2){
  //G4cout<<"BRIUS"<<G4endl;
  //runAct->h_geom_g4->Fill(pos1.z()/m,sqrt(pow(pos1.x()/m,2)+pow(pos1.y()/m,2)));    
  //}

  G4int NMA=10;
  bool EXITFILEDISABLE=false;
  if(EXITFILEDISABLE==false){
    G4int pid_out = 13;
    //G4int POT_id = POT_id = primaryGen->GetPOT_id();
    G4StepPoint* thePrePoint = aStep->GetPreStepPoint();
    G4VPhysicalVolume* thePrePV = thePrePoint->GetPhysicalVolume();
    G4StepPoint* thePostPoint = aStep->GetPostStepPoint();
    G4VPhysicalVolume* thePostPV = thePostPoint->GetPhysicalVolume();
    if(thePostPoint->GetStepStatus()==fGeomBoundary ){
      if(thePostPV){
	if((thePostPV->GetName()=="World")&& 
	   (thePrePV->GetName()=="TARG")) {      
	  if(track->GetDefinition()->GetParticleName()=="pi+")pid_out=13;
	  if(track->GetDefinition()->GetParticleName()=="pi-")pid_out=14;
	  if(track->GetDefinition()->GetParticleName()=="kaon+")pid_out=15;
	  if(track->GetDefinition()->GetParticleName()=="kaon-")pid_out=16;
	  if(track->GetDefinition()->GetParticleName()=="kaon0")pid_out=24;
	  if(track->GetDefinition()->GetParticleName()=="anti_kaon0")pid_out=25;
	  if(track->GetDefinition()->GetParticleName()=="kaon0S")pid_out=19;
	  if(track->GetDefinition()->GetParticleName()=="kaon0L")pid_out=12;

	  if(track->GetDefinition()->GetParticleName()=="kaon+"){
	    if(primaryGen->n_kplus_exit++<NMA){
	      primaryGen->x_kplus_exit[primaryGen->n_kplus_exit]=pos2.x();
	      primaryGen->y_kplus_exit[primaryGen->n_kplus_exit]=pos2.y();
	      primaryGen->z_kplus_exit[primaryGen->n_kplus_exit]=pos2.z();
	      primaryGen->px_kplus_exit[primaryGen->n_kplus_exit]=momentum.x();
	      primaryGen->py_kplus_exit[primaryGen->n_kplus_exit]=momentum.y();
	      primaryGen->pz_kplus_exit[primaryGen->n_kplus_exit]=momentum.z();
	      primaryGen->n_kplus_exit++;
	    }
	  }
	  if(track->GetDefinition()->GetParticleName()=="kaon-"){
	    if(primaryGen->n_kminus_exit++<NMA){
	      primaryGen->x_kminus_exit[primaryGen->n_kminus_exit]=pos2.x();
	      primaryGen->y_kminus_exit[primaryGen->n_kminus_exit]=pos2.y();
	      primaryGen->z_kminus_exit[primaryGen->n_kminus_exit]=pos2.z();
	      primaryGen->px_kminus_exit[primaryGen->n_kminus_exit]=momentum.x();
	      primaryGen->py_kminus_exit[primaryGen->n_kminus_exit]=momentum.y();
	      primaryGen->pz_kminus_exit[primaryGen->n_kminus_exit]=momentum.z();
	      primaryGen->n_kminus_exit++;
	    }
	  }
	  if(track->GetDefinition()->GetParticleName()=="kaon0S"){
	    if(primaryGen->n_k0s_exit++<NMA){
	      primaryGen->x_k0s_exit[primaryGen->n_k0s_exit]=pos2.x();
	      primaryGen->y_k0s_exit[primaryGen->n_k0s_exit]=pos2.y();
	      primaryGen->z_k0s_exit[primaryGen->n_k0s_exit]=pos2.z();
	      primaryGen->px_k0s_exit[primaryGen->n_k0s_exit]=momentum.x();
	      primaryGen->py_k0s_exit[primaryGen->n_k0s_exit]=momentum.y();
	      primaryGen->pz_k0s_exit[primaryGen->n_k0s_exit]=momentum.z();
	      primaryGen->n_k0s_exit++;
	    }
	  }
	  if(track->GetDefinition()->GetParticleName()=="kaon0L"){
	    if(primaryGen->n_k0l_exit++<NMA){
	      primaryGen->x_k0l_exit[primaryGen->n_k0l_exit]=pos2.x();
	      primaryGen->y_k0l_exit[primaryGen->n_k0l_exit]=pos2.y();
	      primaryGen->z_k0l_exit[primaryGen->n_k0l_exit]=pos2.z();
	      primaryGen->px_k0l_exit[primaryGen->n_k0l_exit]=momentum.x();
	      primaryGen->py_k0l_exit[primaryGen->n_k0l_exit]=momentum.y();
	      primaryGen->pz_k0l_exit[primaryGen->n_k0l_exit]=momentum.z();
	      primaryGen->n_k0l_exit++;
	    }
	  }

	  if((track->GetDefinition()->GetParticleName()=="pi+")||
	     (track->GetDefinition()->GetParticleName()=="pi-")||
	     (track->GetDefinition()->GetParticleName()=="kaon+")||
	     (track->GetDefinition()->GetParticleName()=="kaon-")||
	     (track->GetDefinition()->GetParticleName()=="kaon0S")||
	     (track->GetDefinition()->GetParticleName()=="kaon0L")||
	     (track->GetDefinition()->GetParticleName()=="kaon0")||
	     (track->GetDefinition()->GetParticleName()=="anti_kaon0")){
	    pOutFileExitTarget <<primaryGen->GetFLUKAPOTs()<<" "
			       <<pid_out<<" "
			       <<pos2.x()/CLHEP::cm<<" "
			       <<pos2.y()/CLHEP::cm<<" "
			       <<(pos2.z()-detector->GetTargetZetaPos()+0.5*detector->GetTargetThickness())/CLHEP::cm<<" "
			       <<momentum.x()/CLHEP::GeV<<" "
			       <<momentum.y()/CLHEP::GeV<<" "
			       <<momentum.z()/CLHEP::GeV<<" 1. 1. 1."
			       <<G4endl;
	    //<< xprim<<" "<<yprim<<" "<<zprim<<" "<<pxprim<<" "<<pyprim<<" "<<pzprim<<G4endl;
	  }
	}
      }
    }
    
    
    if ((point1->GetStepStatus() == fGeomBoundary)&&(name=="TUNL")){
      /*     G4cout<< " Particle just entered the current volume "<< name << G4endl;
	     G4cout <<"At tunnel entrance "<<pos1.x()<<" "<<pos1.y()<<" "<<pos1.z()<<" "
	     << momentum.x()<<" "<<momentum.y()<<" "<<momentum.z()<<" " << PID << G4endl;
      */
      
      pOutFileExitTunnel <<pos1.x()/CLHEP::cm<<" "<<pos1.y()/CLHEP::cm<<" "<<pos1.z()/CLHEP::cm<<" "
			 << momentum.x()/CLHEP::GeV<<" "<<momentum.y()/CLHEP::GeV<<" "<<momentum.z()/CLHEP::GeV<<" 1. " << PID << " "
			 << xprim<<" "<<yprim<<" "<<zprim<<" "<<pxprim<<" "<<pyprim<<" "<<pzprim<<G4endl;
      
      if(DEB)G4cout <<"SBSteppingAction: "<< track->GetDefinition()->GetParticleName() << " enters TUNNEL. pos = "<<pos1<<" p = "<< pTOT << G4endl;
      
      if(track->GetDefinition()->GetParticleName()=="pi+"){
	evtAct->x_EXI_piplus=pos1;
	evtAct->p_EXI_piplus=momentum;
	//evtAct->fillEXIT(pos1.x(),pos1.y(),pos1.z(),
	//	       momentum.x(),momentum.y(),momentum.z(),1);
      }
      if(track->GetDefinition()->GetParticleName()=="pi-"){
	evtAct->x_EXI_piminus=pos1;
	evtAct->p_EXI_piminus=momentum;
	//evtAct->fillEXIT(pos1.x(),pos1.y(),pos1.z(),
	//	       momentum.x(),momentum.y(),momentum.z(),2);
	
      }
      
      if(track->GetDefinition()->GetParticleName()=="mu+"){
	evtAct->x_EXI_muplus=pos1;
	evtAct->p_EXI_muplus=momentum;
      }
      if(track->GetDefinition()->GetParticleName()=="mu-"){
	evtAct->x_EXI_muminus=pos1;
	evtAct->p_EXI_muminus=momentum;
      }
    }
  }//disable tagging of exit volum points to speed up

  //************ tag decay in flight
  //if(track->GetDefinition()->GetParticleName()=="mu+"){G4cout<< "mu+ APPEARED"<<G4endl;}
  //if(track->GetDefinition()->GetParticleName()=="mu-"){G4cout<< "mu- APPEARED"<<G4endl;}
  //G4cout << "check "<< evtAct->PIPLUS_TRACKID << G4endl;
  
  const G4VProcess* pProcess = point2->GetProcessDefinedStep();
  G4String theProcessName=" ";
  if(pProcess)theProcessName = pProcess->GetProcessName();
  const G4String theParticleName = track->GetDefinition()->GetParticleName();

  /*
    if(theProcessName!="hIoni"){
    if(theProcessName!="eIoni"){
    if(theProcessName!="muIoni"){
    if(theProcessName!="msc"){

    G4cout << "SBSteppingAction: DUMP PDG_ID: "<<PID<<
    " name: "<<theParticleName<<
    " track ID: "<<track->GetTrackID()<<
    " PARENT ID "<<track->GetParentID()<<
    " proc. name: "<< theProcessName <<G4endl;
    }
    }
    }
    }
  */

  G4int index = track->GetTrackID();
  G4int indexp = track->GetParentID();
  G4int IMAX=evtAct->MAXIND;
  if((index<IMAX)&&(indexp<IMAX)){
    evtAct->vPDG_ID[index]=PID;
    evtAct->vPDG_PAR_ID[index]=evtAct->vPDG_ID[indexp];
    evtAct->vPDG_PARPAR_ID[index]=evtAct->vPDG_PAR_ID[indexp];//?
    // names
    evtAct->vName_ID[index]=theParticleName;
    evtAct->vName_PAR_ID[index]=evtAct->vName_ID[indexp];
    evtAct->vName_PARPAR_ID[index]=evtAct->vName_PAR_ID[indexp];//?
  }else{
    //G4cout << "SBSteppingAction: WARNING OUT OF BOUNDS !!!! "<<index <<" "<<indexp<<G4endl;
  }

  G4int PARID=0;// = track->GetParentID();
  G4int parPDG=0;// = evtAct->vPDG_ID[PARID];
  G4int parparPDG=0;// = evtAct->vPDG_PAR_ID[PARID];
  G4int parparparPDG=0;// = evtAct->vPDG_PARPAR_ID[PARID];
  
  G4String parName="";// = evtAct->vName_ID[PARID];
  G4String parparName="";// = evtAct->vName_PAR_ID[PARID];
  G4String parparparName="";// = evtAct->vName_PARPAR_ID[PARID];
  
  PARID = track->GetParentID();
  if(PARID<IMAX){
    parPDG = evtAct->vPDG_ID[PARID];
    parparPDG = evtAct->vPDG_PAR_ID[PARID];
    parparparPDG = evtAct->vPDG_PARPAR_ID[PARID];
    
    parName = evtAct->vName_ID[PARID];
    parparName = evtAct->vName_PAR_ID[PARID];
    parparparName = evtAct->vName_PARPAR_ID[PARID];
  } else {
    //G4cout << "SBSteppingAction: WARNING PARENT ID OUT OF BOUNDS !!!! "<<index <<" "<<indexp<<G4endl;
  }
  
  G4bool kaonfath = false, kaonGfath = false, kaonGGfath = false;
  G4bool k0fath = false, k0Gfath = false, k0GGfath = false;

  kaonfath =((parPDG==PDGkplus)||(parPDG==PDGkminus));
  kaonGfath =((parparPDG==PDGkplus)||(parparPDG==PDGkminus));
  kaonGGfath = ((parparparPDG==PDGkplus)||(parparparPDG==PDGkminus));

  k0fath =
    ((parPDG==PDGk0)||
     (parPDG==PDGak0)||
     (parPDG==PDGL)||// added lambdas in the definition
     (parPDG==PDGaL)||
     (parPDG==PDGk0S)||
     (parPDG==PDGk0L));
  k0Gfath =
    ((parparPDG==PDGk0)||
     (parparPDG==PDGak0)||
     (parparPDG==PDGL)||// added lambdas in the definition
     (parparPDG==PDGaL)||
     (parparPDG==PDGk0S)||
     (parparPDG==PDGk0L));
  k0GGfath =
    ((parparparPDG==PDGk0)||
     (parparparPDG==PDGak0)||
     (parparparPDG==PDGL)||// added lambdas in the definition
     (parparparPDG==PDGaL)||
     (parparparPDG==PDGk0S)||
     (parparparPDG==PDGk0L));


  //G4cout <<"P A R T I C L E "<<theParticleName<<" "<<PID<<G4endl;
  
  // kill electron muons gamma pi0

  G4bool KILLMUENABLE = true;
  if(KILLMUENABLE){
    if(theParticleName=="mu-"){
      aStep->GetTrack()->SetTrackStatus(fStopAndKill);
      aStep->GetTrack()->SetTrackStatus(fKillTrackAndSecondaries);
      //G4cout <<"SBSteppingAction: mu- killed" << G4endl;
    }
    if(theParticleName=="mu+"){
      aStep->GetTrack()->SetTrackStatus(fStopAndKill);
      aStep->GetTrack()->SetTrackStatus(fKillTrackAndSecondaries);
      //G4cout <<"SBSteppingAction: mu+ killed" << G4endl;
    }
  }
  if(theParticleName=="e+"){
    aStep->GetTrack()->SetTrackStatus(fStopAndKill);
    aStep->GetTrack()->SetTrackStatus(fKillTrackAndSecondaries);
    //G4cout <<"SBSteppingAction: e+ killed" << G4endl;
  }
  if(theParticleName=="e-"){
    aStep->GetTrack()->SetTrackStatus(fStopAndKill);
    aStep->GetTrack()->SetTrackStatus(fKillTrackAndSecondaries);
    //G4cout <<"SBSteppingAction: e- killed" << G4endl;
  }
  if(theParticleName=="gamma"){
    aStep->GetTrack()->SetTrackStatus(fStopAndKill);
    aStep->GetTrack()->SetTrackStatus(fKillTrackAndSecondaries);
    //G4cout <<"SBSteppingAction: gamma killed" << G4endl;
  }
  if(theParticleName=="pi0"){
    aStep->GetTrack()->SetTrackStatus(fStopAndKill);
    aStep->GetTrack()->SetTrackStatus(fKillTrackAndSecondaries);
    //G4cout <<"SBSteppingAction: pi0 killed" << G4endl;
  }

  //***************************************************
  //***************************************************
  //***************************************************
  // check nue
  // direct estimate without weighting
  // meaningful only if kaon replication is off and muons/etc are not killed

  bool NUECHECK_ENABLE=false;
  if(NUECHECK_ENABLE==true){
      
    if((PID==12)||(PID==14)||(PID==-12)||(PID==-14)){//nu
      G4ThreeVector nup = track->GetMomentum();
      //G4double nupx = nup.x();
      //G4double nupy = nup.y();
      //G4double nupz = nup.z();
      //G4double nuE = sqrt((nupx*nupx)+(nupy*nupy)+(nupz*nupz));
	
      G4double OffAxisAngle=11.8/810.;//NOVA
      G4double OffAxisPhi=0;
      G4double eOME[3]={0.,0.,0.};
      eOME[0]=sin(OffAxisAngle)*cos(OffAxisPhi);
      eOME[1]=sin(OffAxisAngle)*sin(OffAxisPhi);
      eOME[2]=cos(OffAxisAngle);
	
      //G4double angnue=0, angnumu=0;
      //G4double angnue0=0, angnumu0=0;	
      //G4double anganue=0, anganumu=0;
      //G4double anganue0=0, anganumu0=0;	

      G4cout<< "neutrino "<<PID<<" tagged"<<G4endl;

      //G4double cone[8]={0.1,0.05,0.025,0.0125,0.00625,0.003125,0.0015625,0.00078125};

/*
      if(nuE!=0){
	if(PID==12){
	  angnue=acos(((eOME[0]*nupx)+(eOME[1]*nupy)+(eOME[2]*nupz))/nuE);	  
	  angnue0=acos(nupz/nuE);
	    
	  if(angnue0!=evtAct->angnue0OLD){// to avoid double counting
	    if(angnue0<cone[0])runAct->h_G4nue_1->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[1])runAct->h_G4nue_2->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[2])runAct->h_G4nue_3->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[3])runAct->h_G4nue_4->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[4])runAct->h_G4nue_5->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[5])runAct->h_G4nue_6->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[6])runAct->h_G4nue_7->Fill(nuE/CLHEP::GeV);
	    if(angnue0<cone[7])runAct->h_G4nue_8->Fill(nuE/CLHEP::GeV);
	      
	    if(angnue<cone[0])runAct->h_G4nueOA_1->Fill(nuE/CLHEP::GeV);
	    if(angnue<cone[1])runAct->h_G4nueOA_2->Fill(nuE/CLHEP::GeV);
	    if(angnue<cone[2])runAct->h_G4nueOA_3->Fill(nuE/CLHEP::GeV);
	    if(angnue<cone[3])runAct->h_G4nueOA_4->Fill(nuE/CLHEP::GeV);
	    if(angnue<cone[4])runAct->h_G4nueOA_5->Fill(nuE/CLHEP::GeV);	      
	    if(angnue<cone[5])runAct->h_G4nueOA_6->Fill(nuE/CLHEP::GeV);	      
	    if(angnue<cone[6])runAct->h_G4nueOA_7->Fill(nuE/CLHEP::GeV);	      
	    if(angnue<cone[7])runAct->h_G4nueOA_8->Fill(nuE/CLHEP::GeV);	      
            G4cout <<"SBSteppingAction: nue_OFFAXIS FIRST ONE "<< nuE/CLHEP::GeV<< G4endl;
	    evtAct->angnue0OLD=angnue0;
	  }
	}//nue
	  	  
	if(PID==14){
	  angnumu=acos(((eOME[0]*nupx)+(eOME[1]*nupy)+(eOME[2]*nupz))/nuE);	  
	  angnumu0=acos(nupz/nuE);
	    
	  if(angnumu0!=evtAct->angnumu0OLD){// to avoid double counting
	    if(angnumu0<cone[0])runAct->h_G4numu_1->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[1])runAct->h_G4numu_2->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[2])runAct->h_G4numu_3->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[3])runAct->h_G4numu_4->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[4])runAct->h_G4numu_5->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[5])runAct->h_G4numu_6->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[6])runAct->h_G4numu_7->Fill(nuE/CLHEP::GeV);
	    if(angnumu0<cone[7])runAct->h_G4numu_8->Fill(nuE/CLHEP::GeV);
	      
	    if(angnumu<cone[0])runAct->h_G4numuOA_1->Fill(nuE/CLHEP::GeV);
	    if(angnumu<cone[1])runAct->h_G4numuOA_2->Fill(nuE/CLHEP::GeV);
	    if(angnumu<cone[2])runAct->h_G4numuOA_3->Fill(nuE/CLHEP::GeV);
	    if(angnumu<cone[3])runAct->h_G4numuOA_4->Fill(nuE/CLHEP::GeV);
	    if(angnumu<cone[4])runAct->h_G4numuOA_5->Fill(nuE/CLHEP::GeV);		
	    if(angnumu<cone[5])runAct->h_G4numuOA_6->Fill(nuE/CLHEP::GeV);		
	    if(angnumu<cone[6])runAct->h_G4numuOA_7->Fill(nuE/CLHEP::GeV);		
	    if(angnumu<cone[7])runAct->h_G4numuOA_8->Fill(nuE/CLHEP::GeV);		
	    G4cout <<"SBSteppingAction: numu_OFFAXIS FIRST ONE "<< nuE/CLHEP::GeV<< G4endl;
	    evtAct->angnumu0OLD=angnumu0;
	  }	    
	}//numu	  

	if(PID==-12){
	  anganue=acos(((eOME[0]*nupx)+(eOME[1]*nupy)+(eOME[2]*nupz))/nuE);	  
	  anganue0=acos(nupz/nuE);
	    
	  if(anganue0!=evtAct->anganue0OLD){// to avoid double counting
	    if(anganue0<cone[0])runAct->h_G4anue_1->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[1])runAct->h_G4anue_2->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[2])runAct->h_G4anue_3->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[3])runAct->h_G4anue_4->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[4])runAct->h_G4anue_5->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[5])runAct->h_G4anue_6->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[6])runAct->h_G4anue_7->Fill(nuE/CLHEP::GeV);
	    if(anganue0<cone[7])runAct->h_G4anue_8->Fill(nuE/CLHEP::GeV);
	      
	    if(anganue<cone[0])runAct->h_G4anueOA_1->Fill(nuE/CLHEP::GeV);
	    if(anganue<cone[1])runAct->h_G4anueOA_2->Fill(nuE/CLHEP::GeV);
	    if(anganue<cone[2])runAct->h_G4anueOA_3->Fill(nuE/CLHEP::GeV);
	    if(anganue<cone[3])runAct->h_G4anueOA_4->Fill(nuE/CLHEP::GeV);
	    if(anganue<cone[4])runAct->h_G4anueOA_5->Fill(nuE/CLHEP::GeV);	      
	    if(anganue<cone[5])runAct->h_G4anueOA_6->Fill(nuE/CLHEP::GeV);	      
	    if(anganue<cone[6])runAct->h_G4anueOA_7->Fill(nuE/CLHEP::GeV);	      
	    if(anganue<cone[7])runAct->h_G4anueOA_8->Fill(nuE/CLHEP::GeV);	      
	    G4cout <<"SBSteppingAction: anue_OFFAXIS FIRST ONE "<< nuE/CLHEP::GeV<< G4endl;
	    evtAct->anganue0OLD=anganue0;
	  }
	}//anue
	  	  
	if(PID==-14){
	  anganumu=acos(((eOME[0]*nupx)+(eOME[1]*nupy)+(eOME[2]*nupz))/nuE);	  
	  anganumu0=acos(nupz/nuE);
	    
	  if(anganumu0!=evtAct->anganumu0OLD){// to avoid double counting
	    if(anganumu0<cone[0])runAct->h_G4anumu_1->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[1])runAct->h_G4anumu_2->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[2])runAct->h_G4anumu_3->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[3])runAct->h_G4anumu_4->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[4])runAct->h_G4anumu_5->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[5])runAct->h_G4anumu_6->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[6])runAct->h_G4anumu_7->Fill(nuE/CLHEP::GeV);
	    if(anganumu0<cone[7])runAct->h_G4anumu_8->Fill(nuE/CLHEP::GeV);
	      
	    if(anganumu<cone[0])runAct->h_G4anumuOA_1->Fill(nuE/CLHEP::GeV);
	    if(anganumu<cone[1])runAct->h_G4anumuOA_2->Fill(nuE/CLHEP::GeV);
	    if(anganumu<cone[2])runAct->h_G4anumuOA_3->Fill(nuE/CLHEP::GeV);
	    if(anganumu<cone[3])runAct->h_G4anumuOA_4->Fill(nuE/CLHEP::GeV);
	    if(anganumu<cone[4])runAct->h_G4anumuOA_5->Fill(nuE/CLHEP::GeV);		
	    if(anganumu<cone[5])runAct->h_G4anumuOA_6->Fill(nuE/CLHEP::GeV);		
	    if(anganumu<cone[6])runAct->h_G4anumuOA_7->Fill(nuE/CLHEP::GeV);		
	    if(anganumu<cone[7])runAct->h_G4anumuOA_8->Fill(nuE/CLHEP::GeV);		
	    G4cout <<"SBSteppingAction: anumu_OFFAXIS FIRST ONE "<< nuE/CLHEP::GeV<< G4endl;
	    evtAct->anganumu0OLD=anganumu0;
	  }	    
	}//anumu  

      }//E!=0
*/

    }//nuecheck
  }// enablea

  //***************************************************
  //***************************************************
  //***************************************************

  if(theProcessName=="Decay"){
    //but then ask additionally for:
    G4StepStatus stepStatus = point2->GetStepStatus();

    //pProcess->DumpInfo();
    
    G4cout << 
      "SBSteppingAction: Decay of PARTICLE "<<theParticleName<<
      " PDGcode: "<<PID<<
      " track ID: "<<track->GetTrackID()<<
      " parent ID: "<< PARID <<
      " step status "<<stepStatus<< G4endl;

    if (stepStatus!=fAtRestDoItProc) { // decay in flight;
      //if (stepStatus==fAtRestDoItProc) { // at rest

      //if(DEB)G4cout << "SBSteppingAction: Decay IN FLIGHT of PARTICLE " << PID <<" "<<theParticleName<<" track ID: "<<track->GetTrackID()<<". parent ID: "<< track->GetParentID()<<". Step status: "<<stepStatus<<" "<<G4endl;

      if(PID==211){
	//if(DEB)
	G4cout << "SBSteppingAction: PI+ Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<< G4endl;
	evtAct->PIPLUS_TRACKID = track->GetTrackID();
	evtAct->x_DIF_PI_piplus=track->GetPosition();
	evtAct->p_DIF_PI_piplus=track->GetMomentum();
	evtAct->NDIF_piplus++;

	//G4cout << "PI+ PARENT IDENTITY "<<parPDG<<" from a "<<parparPDG<<G4endl;
	G4cout << "PI+ <~ "<<parName<<" <~ "<<parparName<<G4endl;

	if(kaonfath||kaonGfath||kaonGGfath){// fails if pion does twice PionMinusInelastic ... 
	  evtAct->ParLevel_piplus = 1;
	  G4cout << "K+/- => PI+ "<<G4endl;
	}else if(k0fath||k0Gfath||k0GGfath){
	  evtAct->ParLevel_piplus = 2;
	  G4cout << "K0 => PI+ "<<G4endl;
	}else{
	  evtAct->ParLevel_piplus = 0;
	  G4cout << "direct PI+"<<G4endl;
	}

	/*
	  if(PARID==evtAct->KPLUS_TRACKID){
	  evtAct->ParLevel_piplus = 1;
	  G4cout << "SBSteppingAction: pi+ from a K+ tagged. pi+ ParLevel "<<evtAct->ParLevel_piplus<<G4endl;
	  }
	  if(PARID==evtAct->KMINUS_TRACKID){
	  evtAct->ParLevel_piplus = 1;
	  G4cout << "SBSteppingAction: pi+ from a K- tagged. pi+ ParLevel "<<evtAct->ParLevel_piplus<<G4endl;
	  }
	  if(PARID==evtAct->KZEROS_TRACKID){
	  evtAct->ParLevel_piplus = 1;
	  G4cout << "SBSteppingAction: pi+ from a K0S tagged. pi+ ParLevel "<<evtAct->ParLevel_piplus<<G4endl;
	  }
	  if(PARID==evtAct->KZEROL_TRACKID){
	  evtAct->ParLevel_piplus = 1;
	  G4cout << "SBSteppingAction: pi+ from a K0L tagged. pi+ ParLevel "<<evtAct->ParLevel_piplus<<G4endl;
	  }
	*/
      } else if(PID==-211){
	//if(DEB)
	G4cout << "SBSteppingAction: PI- Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<< G4endl;
	evtAct->PIMINUS_TRACKID = track->GetTrackID();
	evtAct->x_DIF_PI_piminus=track->GetPosition();
	evtAct->p_DIF_PI_piminus=track->GetMomentum();
	evtAct->NDIF_piminus++;

	//G4cout << "PI- PARENT IDENTITY "<<parPDG <<" from a "<<parparPDG<<G4endl;
	G4cout << "PI- <~ "<<parName<<" <~ "<<parparName<<G4endl;

	if(kaonfath||kaonGfath||kaonGGfath){// fails if pion does twice PionMinusInelastic ... 
	  evtAct->ParLevel_piminus = 1;
	  G4cout << "K+/- => PI- "<<G4endl;
	}else if(k0fath||k0Gfath||k0GGfath){
	  evtAct->ParLevel_piminus = 2;
	  G4cout << "K0 => PI- "<<G4endl;
	}else{
	  evtAct->ParLevel_piminus = 0;
	  G4cout << "direct PI-"<<G4endl;
	}

	/*
	  if(PARID==evtAct->KMINUS_TRACKID){
	  evtAct->ParLevel_piminus = 1;
	  G4cout << "SBSteppingAction: pi- from a K- tagged. pi- ParLevel " <<evtAct->ParLevel_piminus<<G4endl;
	  }
	  if(PARID==evtAct->KPLUS_TRACKID){
	  evtAct->ParLevel_piminus = 1;
	  G4cout << "SBSteppingAction: pi- from a K+ tagged. pi- ParLevel " <<evtAct->ParLevel_piminus<<G4endl;
	  }
	  if(PARID==evtAct->KZEROS_TRACKID){
	  evtAct->ParLevel_piminus = 1;
	  G4cout << "SBSteppingAction: pi- from a K0S tagged. pi- ParLevel " <<evtAct->ParLevel_piminus<<G4endl;
	  }
	  if(PARID==evtAct->KZEROL_TRACKID){
	  evtAct->ParLevel_piminus = 1;
	  G4cout << "SBSteppingAction: pi- from a K0L tagged. pi- ParLevel " <<evtAct->ParLevel_piminus<<G4endl;
	  }
	*/
      } else if(PID==321){
	//if(DEB)
	G4cout << "SBSteppingAction: K+ Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<< G4endl;
	evtAct->KPLUS_TRACKID = track->GetTrackID();
	evtAct->x_DIF_K_kplus=track->GetPosition();
	evtAct->p_DIF_K_kplus=track->GetMomentum();
	evtAct->NDIF_Kplus++;
      } else if(PID==-321){
	//if(DEB)
	G4cout << "SBSteppingAction: K- Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<< G4endl;
	evtAct->KMINUS_TRACKID = track->GetTrackID();
	evtAct->x_DIF_K_kminus=track->GetPosition();
	evtAct->p_DIF_K_kminus=track->GetMomentum();
	evtAct->NDIF_Kminus++;
      } else if(PID==310){
	//if(DEB)
	G4cout << "SBSteppingAction: K0S Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<< G4endl;
	evtAct->KZEROS_TRACKID = track->GetTrackID();
	evtAct->x_DIF_K_kzeroS=track->GetPosition();
	evtAct->p_DIF_K_kzeroS=track->GetMomentum();
	evtAct->NDIF_KzeroS++;
      } else if(PID==130){
	//if(DEB)
	G4cout << "SBSteppingAction: K0L Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<< G4endl;
	evtAct->KZEROL_TRACKID = track->GetTrackID();
	evtAct->x_DIF_K_kzeroL=track->GetPosition();
	evtAct->p_DIF_K_kzeroL=track->GetMomentum();
	evtAct->NDIF_KzeroL++;


      } else if(PID==13){
	//if(DEB)
	G4cout << "SBSteppingAction: MU- Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<<" x= " << track->GetPosition()<<" p= "<<track->GetMomentum()<<G4endl;

      } else if(PID==-13){
	//if(DEB)
	G4cout << "SBSteppingAction: MU+ Decay IN FLIGHT " << PID <<" "<<theParticleName<<" "<<track->GetTrackID()<<" x= " << track->GetPosition()<<" p= "<<track->GetMomentum()<<G4endl;

      }

    }//DIF
    
    //888888888888888888888888888
    //
    // check branching ratios
    //    
    if(theParticleName=="pi+"){runAct->h_decay_NUM->Fill(30.);}
    if(theParticleName=="pi-"){runAct->h_decay_NUM->Fill(31.);}
    if(theParticleName=="kaon+"){
      runAct->h_decay_NUM->Fill(1.);
      runAct->h_decay_NUM->Fill(3.);
      runAct->h_decay_NUM->Fill(5.);
      runAct->h_decay_NUM->Fill(7.);
      runAct->h_decay_NUM->Fill(9.);
      runAct->h_decay_NUM->Fill(11.);
    }
    if(theParticleName=="kaon-"){
      runAct->h_decay_NUM->Fill(2.);
      runAct->h_decay_NUM->Fill(4.);
      runAct->h_decay_NUM->Fill(6.);
      runAct->h_decay_NUM->Fill(8.);
      runAct->h_decay_NUM->Fill(10.);
      runAct->h_decay_NUM->Fill(12.);
    }
    if(theParticleName=="kaon0L"){
      runAct->h_decay_NUM->Fill(13.);
      runAct->h_decay_NUM->Fill(14.);
      runAct->h_decay_NUM->Fill(15.);
      runAct->h_decay_NUM->Fill(16.);
      runAct->h_decay_NUM->Fill(17.);
      runAct->h_decay_NUM->Fill(18.);
    }
    if(theParticleName=="kaon0S"){
      runAct->h_decay_NUM->Fill(19.);
      runAct->h_decay_NUM->Fill(20.);
    }
    //888888888888888888888888888
    //
    // Detect the final state of the decay and categorize
    //

    const G4TrackVector* trkList = aStep->GetSecondary();
    G4TrackVector::const_iterator ite;
    G4ThreeVector p_nutrack=G4ThreeVector(0,0,0);
    G4ThreeVector p_parent=G4ThreeVector(0,0,0);
    G4ThreeVector p_sec_mu=G4ThreeVector(0,0,0);
    G4ThreeVector x_sec_mu=G4ThreeVector(0,0,0);
    G4int PAID = 0, ID=0; 
    G4int id_sec_pip1 = 0; 
    G4int id_sec_pim1 = 0; 
    G4int id_sec_pip2 = 0; 
    G4int id_sec_pim2 = 0; 
    //G4String name_parent[5]={""};
    bool firstpip=true;
    bool firstpim=true;
    G4int Nsec = 0;
    G4String SecNames[5]={""};
    for( ite = trkList->begin(); ite != trkList->end(); ite++){
      /*if(DEB)*/
      G4String CrePro =(*ite)->GetCreatorProcess()->GetProcessName();
      G4String SecParName=(*ite)->GetDefinition()->GetParticleName(); 
      if(CrePro=="Decay"){  
	PAID = track->GetParentID(); 
	ID = track->GetTrackID(); 
	p_parent=track->GetMomentum();

	G4cout <<"SBSteppingAction: DIF SECONDARY "<<SecParName<<" created by "<<CrePro<<G4endl;
	G4cout <<"SBSteppingAction: PARENT ID "<<PAID<<" TRACK ID "<<ID<<G4endl;

	//name_parent=track->GetDefinition()->GetParticleName(); 

	//G4cout<<"PROVA "<<(G4int)(*ite)->GetTrackID()<<" "<<(*ite)->GetParentID()<<G4endl;

	if((SecParName=="nu_e")||(SecParName=="anti_nu_e")||
	   (SecParName=="nu_mu")||(SecParName=="anti_nu_mu"))
	  p_nutrack = (*ite)->GetMomentum();
	
	if((SecParName=="mu+")||(SecParName=="mu-")){
	  p_sec_mu = (*ite)->GetMomentum();
	  x_sec_mu = (*ite)->GetPosition();
	}

	if((SecParName=="pi+")&&firstpip){
	  id_sec_pip1 = (*ite)->GetTrackID();
	  G4cout << " ID first decay pi+ "<<id_sec_pip1<< G4endl;
	  firstpip=false;
	}
	if((SecParName=="pi-")&&firstpim){
	  id_sec_pim1 = (*ite)->GetTrackID();
	  G4cout << " ID first decay pi- "<<id_sec_pim1<< G4endl;
	  firstpim=false;
	}
	if((SecParName=="pi+")&&(!firstpip)){
	  id_sec_pip2 = (*ite)->GetTrackID();
	  G4cout << " ID second decay pi- "<<id_sec_pip2<< G4endl;
	}
	if((SecParName=="pi-")&&(!firstpim)){
	  id_sec_pim2 = (*ite)->GetTrackID();
	  G4cout << " ID second decay pi- "<<id_sec_pim2<< G4endl;
	}
	
	SecNames[Nsec]=SecParName;
	Nsec++;
      }
    }
    //if((*ite)->GetDefinition()==G4Electron::Electron()) 
    G4cout <<"SBSteppingAction: "<< Nsec << " secondaries found."<<G4endl;
    
    evtAct->NBody=Nsec;
    
    G4int N_eplus=0,N_eminus=0,N_muplus=0,N_muminus=0,N_nue=0,N_anue=0,N_numu=0,N_anumu=0,N_piplus=0,N_piminus=0,N_pi0=0;
    for(int i=0;i<Nsec;i++){
      if(SecNames[i]=="e+")N_eplus++;
      if(SecNames[i]=="e-")N_eminus++;
      if(SecNames[i]=="mu+")N_muplus++;
      if(SecNames[i]=="mu-")N_muminus++;
      if(SecNames[i]=="nu_e")N_nue++;
      if(SecNames[i]=="anti_nu_e")N_anue++;
      if(SecNames[i]=="nu_mu")N_numu++;
      if(SecNames[i]=="anti_nu_mu")N_anumu++;
      if(SecNames[i]=="pi+")N_piplus++;
      if(SecNames[i]=="pi-")N_piminus++;
      if(SecNames[i]=="pi0")N_pi0++;
    }
    
    G4double parP=0;
    
    if(Nsec==2){
      if(theParticleName=="pi+"){
	if((N_muplus==1)&&(N_numu==1)){
	  evtAct->decflag=30;
	  evtAct->p_nu30[evtAct->n30]=p_nutrack;
	  evtAct->p_par30[evtAct->n30]=p_parent;
	  evtAct->id_par30[evtAct->n30]=PAID;
	  evtAct->id30[evtAct->n30]=ID;
	  evtAct->p_mu30[evtAct->n30]=p_sec_mu;
	  evtAct->x_mu30[evtAct->n30]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par30[evtAct->n30].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par30[evtAct->n30].mag();
	  runAct->h_prim_match_pi->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);

	  //G4cout << "birbo "<<primaryGen->particleName<<" "<<evtAct->class_par30[evtAct->n30]<<" "<<p_parent<<G4endl;
	  // works only for input from file ... :(
	  /*
	    if(primaryGen->particleName=="pi+")evtAct->class_par30[evtAct->n30]=0;
	    if(primaryGen->particleName=="pi-")evtAct->class_par30[evtAct->n30]=0;
	    if(primaryGen->particleName=="kaon+")evtAct->class_par30[evtAct->n30]=1;
	    if(primaryGen->particleName=="kaon-")evtAct->class_par30[evtAct->n30]=1;
	    if(primaryGen->particleName=="kaon0")evtAct->class_par30[evtAct->n30]=2;
	    if(primaryGen->particleName=="anti_kaon0")evtAct->class_par30[evtAct->n30]=2;
	    if(primaryGen->particleName=="kaon0S")evtAct->class_par30[evtAct->n30]=2;
	    if(primaryGen->particleName=="kaon0L")evtAct->class_par30[evtAct->n30]=2;
	  */
	    
	  // check if primary pion or from K charged or from K neutral

	  G4int mypaid=evtAct->id_par30[evtAct->n30];
	  for(int k=0;k<evtAct->n3;k++){//K+ -> pi+ pi0
	    if (mypaid==evtAct->id3[k])evtAct->class_par30[evtAct->n30]=1;
	  }
	  for(int k=0;k<evtAct->n4;k++){//K- -> pi- pi0
	    if (mypaid==evtAct->id4[k])evtAct->class_par30[evtAct->n30]=1;
	  }
	  for(int k=0;k<evtAct->n5;k++){//K+ -> pi+ pi+ pi-
	    if (mypaid==evtAct->id5[k])evtAct->class_par30[evtAct->n30]=1;
	  }
	  for(int k=0;k<evtAct->n6;k++){//K- -> pi- pi- pi+
	    if (mypaid==evtAct->id6[k])evtAct->class_par30[evtAct->n30]=1;
	  }
	  for(int k=0;k<evtAct->n11;k++){//K+ -> pi+ pi0 pi0
	    if (mypaid==evtAct->id11[k])evtAct->class_par30[evtAct->n30]=1;
	  }
	  for(int k=0;k<evtAct->n12;k++){//K- -> pi- pi0 pi0
	    if (mypaid==evtAct->id12[k])evtAct->class_par30[evtAct->n30]=1;
	  }
	  for(int k=0;k<evtAct->n13;k++){//K0L -> e+ nue pi-
	    if (mypaid==evtAct->id13[k])evtAct->class_par30[evtAct->n30]=2;
	  }
	  for(int k=0;k<evtAct->n14;k++){//K0L -> e- anue pi+
	    if (mypaid==evtAct->id14[k])evtAct->class_par30[evtAct->n30]=2;
	  }
	  for(int k=0;k<evtAct->n15;k++){//K0L -> mu+ numu pi-
	    if (mypaid==evtAct->id15[k])evtAct->class_par30[evtAct->n30]=2;
	  }
	  for(int k=0;k<evtAct->n16;k++){//K0L -> mu- anumu pi+
	    if (mypaid==evtAct->id16[k])evtAct->class_par30[evtAct->n30]=2;
	  }
	  for(int k=0;k<evtAct->n18;k++){//K0L -> pi+ pi- pi0
	    if (mypaid==evtAct->id18[k])evtAct->class_par30[evtAct->n30]=2;
	  }
	  for(int k=0;k<evtAct->n19;k++){//K0S -> pi+ pi-
	    if (mypaid==evtAct->id19[k])evtAct->class_par30[evtAct->n30]=2;
	  }

	  /*
	    G4int mypaid=evtAct->id_par30[evtAct->n30];

	    for(int k=0;k<evtAct->n3;k++){//K+ -> pi+ pi0
	    if (mypaid==evtAct->id_par3[k])evtAct->class_par30[evtAct->n30]=1;
	    }

	    for(int k=0;k<evtAct->n3;k++){//K+ -> pi+ pi0
	    if (mypaid==evtAct->id_sec_pip1_3[k])evtAct->class_par30[evtAct->n30]=1;
	    }
	    for(int k=0;k<evtAct->n4;k++){//K- -> pi- pi0
	    if (mypaid==evtAct->id_sec_pim1_4[k])evtAct->class_par30[evtAct->n30]=1;
	    }
	    for(int k=0;k<evtAct->n5;k++){//K+ -> pi+ pi+ pi-
	    if (mypaid==evtAct->id_sec_pip1_5[k])evtAct->class_par30[evtAct->n30]=1;
	    if (mypaid==evtAct->id_sec_pip2_5[k])evtAct->class_par30[evtAct->n30]=1;
	    if (mypaid==evtAct->id_sec_pim1_5[k])evtAct->class_par30[evtAct->n30]=1;
	    }
	    for(int k=0;k<evtAct->n6;k++){//K- -> pi- pi- pi+
	    if (mypaid==evtAct->id_sec_pim1_6[k])evtAct->class_par30[evtAct->n30]=1;
	    if (mypaid==evtAct->id_sec_pim2_6[k])evtAct->class_par30[evtAct->n30]=1;
	    if (mypaid==evtAct->id_sec_pip1_6[k])evtAct->class_par30[evtAct->n30]=1;
	    }
	    for(int k=0;k<evtAct->n11;k++){//K+ -> pi+ pi0 pi0
	    if (mypaid==evtAct->id_sec_pip1_11[k])evtAct->class_par30[evtAct->n30]=1;
	    }
	    for(int k=0;k<evtAct->n12;k++){//K- -> pi- pi0 pi0
	    if (mypaid==evtAct->id_sec_pim1_12[k])evtAct->class_par30[evtAct->n30]=1;
	    }
	    for(int k=0;k<evtAct->n13;k++){//K0L -> e+ nue pi-
	    if (mypaid==evtAct->id_sec_pim1_13[k])evtAct->class_par30[evtAct->n30]=2;
	    }
	    for(int k=0;k<evtAct->n14;k++){//K0L -> e- anue pi+
	    if (mypaid==evtAct->id_sec_pip1_14[k])evtAct->class_par30[evtAct->n30]=2;
	    }
	    for(int k=0;k<evtAct->n15;k++){//K0L -> mu+ numu pi-
	    if (mypaid==evtAct->id_sec_pim1_15[k])evtAct->class_par30[evtAct->n30]=2;
	    }
	    for(int k=0;k<evtAct->n16;k++){//K0L -> mu- anumu pi+
	    if (mypaid==evtAct->id_sec_pip1_16[k])evtAct->class_par30[evtAct->n30]=2;
	    }
	    for(int k=0;k<evtAct->n18;k++){//K0L -> pi+ pi- pi0
	    if (mypaid==evtAct->id_sec_pip1_18[k])evtAct->class_par30[evtAct->n30]=2;
	    if (mypaid==evtAct->id_sec_pim1_18[k])evtAct->class_par30[evtAct->n30]=2;
	    }
	    for(int k=0;k<evtAct->n19;k++){//K0S -> pi+ pi-
	    if (mypaid==evtAct->id_sec_pip1_19[k])evtAct->class_par30[evtAct->n30]=2;
	    if (mypaid==evtAct->id_sec_pim1_19[k])evtAct->class_par30[evtAct->n30]=2;
	    }

	  */

	  evtAct->n30++;
	}

	if((N_eplus==1)&&(N_nue==1)){G4cout<<"decadimento pi+ -> e+ nue"<<G4endl;}

      }
      if(theParticleName=="pi-"){
	if((N_muminus==1)&&(N_anumu==1)){
	  evtAct->decflag=31;
	  evtAct->p_nu31[evtAct->n31]=p_nutrack;
	  evtAct->p_par31[evtAct->n31]=p_parent;
	  evtAct->id_par31[evtAct->n31]=PAID;
	  evtAct->id30[evtAct->n31]=ID;
	  evtAct->p_mu31[evtAct->n31]=p_sec_mu;
	  evtAct->x_mu31[evtAct->n31]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par31[evtAct->n31].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par31[evtAct->n31].mag();
	  runAct->h_prim_match_pi->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  /*
	    if(primaryGen->particleName=="pi+")evtAct->class_par31[evtAct->n31]=0;
	    if(primaryGen->particleName=="pi-")evtAct->class_par31[evtAct->n31]=0;
	    if(primaryGen->particleName=="kaon+")evtAct->class_par31[evtAct->n31]=1;
	    if(primaryGen->particleName=="kaon-")evtAct->class_par31[evtAct->n31]=1;
	    if(primaryGen->particleName=="kaon0")evtAct->class_par31[evtAct->n31]=2;
	    if(primaryGen->particleName=="anti_kaon0")evtAct->class_par31[evtAct->n31]=2;
	    if(primaryGen->particleName=="kaon0S")evtAct->class_par31[evtAct->n31]=2;
	    if(primaryGen->particleName=="kaon0L")evtAct->class_par31[evtAct->n31]=2;
	  */

	  // check if primary pion or from K charged or from K neutral

	  G4int mypaid=evtAct->id_par31[evtAct->n31];
	  for(int k=0;k<evtAct->n3;k++){//K+ -> pi+ pi0
	    if (mypaid==evtAct->id3[k])evtAct->class_par31[evtAct->n31]=1;
	  }
	  for(int k=0;k<evtAct->n4;k++){//K- -> pi- pi0
	    if (mypaid==evtAct->id4[k])evtAct->class_par31[evtAct->n31]=1;
	  }
	  for(int k=0;k<evtAct->n5;k++){//K+ -> pi+ pi+ pi-
	    if (mypaid==evtAct->id5[k])evtAct->class_par31[evtAct->n31]=1;
	  }
	  for(int k=0;k<evtAct->n6;k++){//K- -> pi- pi- pi+
	    if (mypaid==evtAct->id6[k])evtAct->class_par31[evtAct->n31]=1;
	  }
	  for(int k=0;k<evtAct->n11;k++){//K+ -> pi+ pi0 pi0
	    if (mypaid==evtAct->id11[k])evtAct->class_par31[evtAct->n31]=1;
	  }
	  for(int k=0;k<evtAct->n12;k++){//K- -> pi- pi0 pi0
	    if (mypaid==evtAct->id12[k])evtAct->class_par31[evtAct->n31]=1;
	  }
	  for(int k=0;k<evtAct->n13;k++){//K0L -> e+ nue pi-
	    if (mypaid==evtAct->id13[k])evtAct->class_par31[evtAct->n31]=2;
	  }
	  for(int k=0;k<evtAct->n14;k++){//K0L -> e- anue pi+
	    if (mypaid==evtAct->id14[k])evtAct->class_par31[evtAct->n31]=2;
	  }
	  for(int k=0;k<evtAct->n15;k++){//K0L -> mu+ numu pi-
	    if (mypaid==evtAct->id15[k])evtAct->class_par31[evtAct->n31]=2;
	  }
	  for(int k=0;k<evtAct->n16;k++){//K0L -> mu- anumu pi+
	    if (mypaid==evtAct->id16[k])evtAct->class_par31[evtAct->n31]=2;
	  }
	  for(int k=0;k<evtAct->n18;k++){//K0L -> pi+ pi- pi0
	    if (mypaid==evtAct->id18[k])evtAct->class_par31[evtAct->n31]=2;
	  }
	  for(int k=0;k<evtAct->n19;k++){//K0S -> pi+ pi-
	    if (mypaid==evtAct->id19[k])evtAct->class_par31[evtAct->n31]=2;
	  }

	  /*
	    G4int mypaid=evtAct->id_par31[evtAct->n31];
	    for(int k=0;k<evtAct->n3;k++){//K+ -> pi+ pi0
	    if (mypaid==evtAct->id_sec_pip1_3[k])evtAct->class_par31[evtAct->n31]=1;
	    }
	    for(int k=0;k<evtAct->n4;k++){//K- -> pi- pi0
	    if (mypaid==evtAct->id_sec_pim1_4[k])evtAct->class_par31[evtAct->n31]=1;
	    }
	    for(int k=0;k<evtAct->n5;k++){//K+ -> pi+ pi+ pi-
	    if (mypaid==evtAct->id_sec_pip1_5[k])evtAct->class_par31[evtAct->n31]=1;
	    if (mypaid==evtAct->id_sec_pip2_5[k])evtAct->class_par31[evtAct->n31]=1;
	    if (mypaid==evtAct->id_sec_pim1_5[k])evtAct->class_par31[evtAct->n31]=1;
	    }
	    for(int k=0;k<evtAct->n6;k++){//K- -> pi- pi- pi+
	    if (mypaid==evtAct->id_sec_pim1_6[k])evtAct->class_par31[evtAct->n31]=1;
	    if (mypaid==evtAct->id_sec_pim2_6[k])evtAct->class_par31[evtAct->n31]=1;
	    if (mypaid==evtAct->id_sec_pip1_6[k])evtAct->class_par31[evtAct->n31]=1;
	    }
	    for(int k=0;k<evtAct->n11;k++){//K+ -> pi+ pi0 pi0
	    if (mypaid==evtAct->id_sec_pip1_11[k])evtAct->class_par31[evtAct->n31]=1;
	    }
	    for(int k=0;k<evtAct->n12;k++){//K- -> pi- pi0 pi0
	    if (mypaid==evtAct->id_sec_pim1_12[k])evtAct->class_par31[evtAct->n31]=1;
	    }
	    for(int k=0;k<evtAct->n13;k++){//K0L -> e+ nue pi-
	    if (mypaid==evtAct->id_sec_pim1_13[k])evtAct->class_par31[evtAct->n31]=2;
	    }
	    for(int k=0;k<evtAct->n14;k++){//K0L -> e- anue pi+
	    if (mypaid==evtAct->id_sec_pip1_14[k])evtAct->class_par31[evtAct->n31]=2;
	    }
	    for(int k=0;k<evtAct->n15;k++){//K0L -> mu+ numu pi-
	    if (mypaid==evtAct->id_sec_pim1_15[k])evtAct->class_par31[evtAct->n31]=2;
	    }
	    for(int k=0;k<evtAct->n16;k++){//K0L -> mu- anumu pi+
	    if (mypaid==evtAct->id_sec_pip1_16[k])evtAct->class_par31[evtAct->n31]=2;
	    }
	    for(int k=0;k<evtAct->n18;k++){//K0L -> pi+ pi- pi0
	    if (mypaid==evtAct->id_sec_pip1_18[k])evtAct->class_par31[evtAct->n31]=2;
	    if (mypaid==evtAct->id_sec_pim1_18[k])evtAct->class_par31[evtAct->n31]=2;
	    }
	    for(int k=0;k<evtAct->n19;k++){//K0S -> pi+ pi-
	    if (mypaid==evtAct->id_sec_pip1_19[k])evtAct->class_par31[evtAct->n31]=2;
	    if (mypaid==evtAct->id_sec_pim1_19[k])evtAct->class_par31[evtAct->n31]=2;
	    }
	  */

	  evtAct->n31++;
	}

	if((N_eminus==1)&&(N_anue==1)){G4cout<<"decadimento pi- -> e- antinue"<<G4endl;}

      }
      if(theParticleName=="kaon+"){
	if((N_muplus==1)&&(N_numu==1)){
	  evtAct->decflag=1;
	  evtAct->p_nu1[evtAct->n1]=p_nutrack;
	  evtAct->p_par1[evtAct->n1]=p_parent;
	  evtAct->id_par1[evtAct->n1]=PAID;
	  evtAct->id1[evtAct->n1]=ID;
	  evtAct->p_mu1[evtAct->n1]=p_sec_mu;
	  evtAct->x_mu1[evtAct->n1]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par1[evtAct->n1].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par1[evtAct->n1].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n1++;
	}
	if((N_piplus==1)&&(N_pi0==1)){
	  evtAct->decflag=3;
	  evtAct->p_nu3[evtAct->n3]=p_nutrack;
	  evtAct->p_par3[evtAct->n3]=p_parent;
	  evtAct->id_par3[evtAct->n3]=PAID;
	  evtAct->id3[evtAct->n3]=ID;
	  evtAct->p_mu3[evtAct->n3]=p_sec_mu;
	  evtAct->x_mu3[evtAct->n3]=x_sec_mu;

	  evtAct->id_sec_pip1_3[evtAct->n3]=id_sec_pip1;

	  //runAct->h_prim_match->Fill(evtAct->p_par3[evtAct->n3].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par3[evtAct->n3].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n3++;
	}
      }
      if(theParticleName=="kaon-"){
	if((N_muminus==1)&&(N_anumu==1)){
	  evtAct->decflag=2;
	  evtAct->p_nu2[evtAct->n2]=p_nutrack;
	  evtAct->p_par2[evtAct->n2]=p_parent;
	  evtAct->id_par2[evtAct->n2]=PAID;
	  evtAct->id2[evtAct->n2]=ID;
	  evtAct->p_mu2[evtAct->n2]=p_sec_mu;
	  evtAct->x_mu2[evtAct->n2]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par2[evtAct->n2].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par2[evtAct->n2].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n2++;
	}
	if((N_piminus==1)&&(N_pi0==1)){
	  evtAct->decflag=4;
	  evtAct->p_nu4[evtAct->n4]=p_nutrack;
	  evtAct->p_par4[evtAct->n4]=p_parent;
	  evtAct->id_par4[evtAct->n4]=PAID;
	  evtAct->id4[evtAct->n4]=ID;
	  evtAct->p_mu4[evtAct->n4]=p_sec_mu;
	  evtAct->x_mu4[evtAct->n4]=x_sec_mu;

	  evtAct->id_sec_pim1_4[evtAct->n4]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par4[evtAct->n4].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par4[evtAct->n4].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n4++;
	}
      }
      if(theParticleName=="kaon0S"){
	if((N_piplus==1)&&(N_piminus==1)){
	  evtAct->decflag=19;
	  evtAct->p_nu19[evtAct->n19]=p_nutrack;
	  evtAct->p_par19[evtAct->n19]=p_parent;
	  evtAct->id_par19[evtAct->n19]=PAID;
	  evtAct->id19[evtAct->n19]=ID;
	  evtAct->p_mu19[evtAct->n19]=p_sec_mu;
	  evtAct->x_mu19[evtAct->n19]=x_sec_mu;

	  evtAct->id_sec_pip1_19[evtAct->n19]=id_sec_pip1;
	  evtAct->id_sec_pim1_19[evtAct->n19]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par19[evtAct->n19].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par19[evtAct->n19].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n19++;
	}
	if(N_pi0==2){
	  evtAct->decflag=20;
	  evtAct->p_nu20[evtAct->n20]=p_nutrack;
	  evtAct->p_par20[evtAct->n20]=p_parent;
	  evtAct->id_par20[evtAct->n20]=PAID;
	  evtAct->id20[evtAct->n20]=ID;
	  evtAct->p_mu20[evtAct->n20]=p_sec_mu;
	  evtAct->x_mu20[evtAct->n20]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par20[evtAct->n20].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par20[evtAct->n20].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n20++;
	}
      }
    }//Nsec 2
    
    if(Nsec==3){
      if(theParticleName=="kaon+"){
	if((N_piplus==2)&&(N_piminus==1)){
	  evtAct->decflag=5;
	  evtAct->p_nu5[evtAct->n5]=p_nutrack;
	  evtAct->p_par5[evtAct->n5]=p_parent;
	  evtAct->id_par5[evtAct->n5]=PAID;
	  evtAct->id5[evtAct->n5]=ID;
	  evtAct->p_mu5[evtAct->n5]=p_sec_mu;
	  evtAct->x_mu5[evtAct->n5]=x_sec_mu;

	  evtAct->id_sec_pip1_5[evtAct->n5]=id_sec_pip1;
	  evtAct->id_sec_pip2_5[evtAct->n5]=id_sec_pip2;
	  evtAct->id_sec_pim1_5[evtAct->n5]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par5[evtAct->n5].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par5[evtAct->n5].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n5++;
	}
	if((N_eplus==1)&&(N_nue==1)&&(N_pi0==1)){
	  evtAct->decflag=7;
	  evtAct->p_nu7[evtAct->n7]=p_nutrack;
	  evtAct->p_par7[evtAct->n7]=p_parent;
	  evtAct->id_par7[evtAct->n7]=PAID;
	  evtAct->id7[evtAct->n7]=ID;
	  evtAct->p_mu7[evtAct->n7]=p_sec_mu;
	  evtAct->x_mu7[evtAct->n7]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par7[evtAct->n7].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par7[evtAct->n7].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n7++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;
	}
	if((N_muplus==1)&&(N_numu==1)&&(N_pi0==1)){
	  evtAct->decflag=9;
	  evtAct->p_nu9[evtAct->n9]=p_nutrack;
	  evtAct->p_par9[evtAct->n9]=p_parent;
	  evtAct->id_par9[evtAct->n9]=PAID;
	  evtAct->id9[evtAct->n9]=ID;
	  evtAct->p_mu9[evtAct->n9]=p_sec_mu;
	  evtAct->x_mu9[evtAct->n9]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par9[evtAct->n9].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par9[evtAct->n9].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n9++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;
	}
	if((N_piplus==1)&&(N_pi0==2)){
	  evtAct->decflag=11;
	  evtAct->p_nu11[evtAct->n11]=p_nutrack;
	  evtAct->p_par11[evtAct->n11]=p_parent;
	  evtAct->id_par11[evtAct->n11]=PAID;
	  evtAct->id11[evtAct->n11]=ID;
	  evtAct->p_mu11[evtAct->n11]=p_sec_mu;
	  evtAct->x_mu11[evtAct->n11]=x_sec_mu;

	  evtAct->id_sec_pip1_11[evtAct->n11]=id_sec_pip1;

	  //runAct->h_prim_match->Fill(evtAct->p_par11[evtAct->n11].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par11[evtAct->n11].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n11++;
	}
      }//k+
      if(theParticleName=="kaon-"){
	if((N_piminus==2)&&(N_piplus==1)){
	  evtAct->decflag=6;
	  evtAct->p_nu6[evtAct->n6]=p_nutrack;
	  evtAct->p_par6[evtAct->n6]=p_parent;
	  evtAct->id_par6[evtAct->n6]=PAID;
	  evtAct->id6[evtAct->n6]=ID;
	  evtAct->p_mu6[evtAct->n6]=p_sec_mu;
	  evtAct->x_mu6[evtAct->n6]=x_sec_mu;

	  evtAct->id_sec_pip1_6[evtAct->n6]=id_sec_pip1;
	  evtAct->id_sec_pim1_6[evtAct->n6]=id_sec_pim1;
	  evtAct->id_sec_pim2_6[evtAct->n6]=id_sec_pim2;

	  //runAct->h_prim_match->Fill(evtAct->p_par6[evtAct->n6].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par6[evtAct->n6].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n6++;
	}
	if((N_eminus==1)&&(N_anue==1)&&(N_pi0==1)){
	  evtAct->decflag=8;
	  evtAct->p_nu8[evtAct->n8]=p_nutrack;
	  evtAct->p_par8[evtAct->n8]=p_parent;
	  evtAct->id_par8[evtAct->n8]=PAID;
	  evtAct->id8[evtAct->n8]=ID;
	  evtAct->p_mu8[evtAct->n8]=p_sec_mu;
	  evtAct->x_mu8[evtAct->n8]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par8[evtAct->n8].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par8[evtAct->n8].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n8++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;
	}
	if((N_muminus==1)&&(N_anumu==1)&&(N_pi0==1)){
	  evtAct->decflag=10;
	  evtAct->p_nu10[evtAct->n10]=p_nutrack;
	  evtAct->p_par10[evtAct->n10]=p_parent;
	  evtAct->id_par10[evtAct->n10]=PAID;
	  evtAct->id10[evtAct->n10]=ID;
	  evtAct->p_mu10[evtAct->n10]=p_sec_mu;
	  evtAct->x_mu10[evtAct->n10]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par10[evtAct->n10].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par10[evtAct->n10].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n10++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;
	}
	if((N_piminus==1)&&(N_pi0==2)){
	  evtAct->decflag=12;
	  evtAct->p_nu12[evtAct->n12]=p_nutrack;
	  evtAct->p_par12[evtAct->n12]=p_parent;
	  evtAct->id_par12[evtAct->n12]=PAID;
	  evtAct->id12[evtAct->n12]=ID;
	  evtAct->p_mu12[evtAct->n12]=p_sec_mu;
	  evtAct->x_mu12[evtAct->n12]=x_sec_mu;

	  evtAct->id_sec_pim1_12[evtAct->n12]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par12[evtAct->n12].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par12[evtAct->n12].mag();
	  runAct->h_prim_match_ka->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n12++;
	}
      }//k-
      if(theParticleName=="kaon0L"){
	if((N_eplus==1)&&(N_nue==1)&&(N_piminus==1)){

	  evtAct->decflag=13;
	  evtAct->p_nu13[evtAct->n13]=p_nutrack;
	  evtAct->p_par13[evtAct->n13]=p_parent;
	  evtAct->id_par13[evtAct->n13]=PAID;
	  evtAct->id13[evtAct->n13]=ID;
	  evtAct->p_mu13[evtAct->n13]=p_sec_mu;
	  evtAct->x_mu13[evtAct->n13]=x_sec_mu;

	  evtAct->id_sec_pim1_13[evtAct->n13]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par13[evtAct->n13].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par13[evtAct->n13].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n13++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;

	}
	if((N_eminus==1)&&(N_anue==1)&&(N_piplus==1)){

	  evtAct->decflag=14;
	  evtAct->p_nu14[evtAct->n14]=p_nutrack;
	  evtAct->p_par14[evtAct->n14]=p_parent;
	  evtAct->id_par14[evtAct->n14]=PAID;
	  evtAct->id14[evtAct->n14]=ID;
	  evtAct->p_mu14[evtAct->n14]=p_sec_mu;
	  evtAct->x_mu14[evtAct->n14]=x_sec_mu;

	  evtAct->id_sec_pip1_14[evtAct->n14]=id_sec_pip1;

	  //runAct->h_prim_match->Fill(evtAct->p_par14[evtAct->n14].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par14[evtAct->n14].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n14++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;

	}
	if((N_muplus==1)&&(N_numu==1)&&(N_piminus==1)){
	  evtAct->decflag=15;
	  evtAct->p_nu15[evtAct->n15]=p_nutrack;
	  evtAct->p_par15[evtAct->n15]=p_parent;
	  evtAct->id_par15[evtAct->n15]=PAID;
	  evtAct->id15[evtAct->n15]=ID;
	  evtAct->p_mu15[evtAct->n15]=p_sec_mu;
	  evtAct->x_mu15[evtAct->n15]=x_sec_mu;

	  evtAct->id_sec_pim1_15[evtAct->n15]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par15[evtAct->n15].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par15[evtAct->n15].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n15++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;
	}
	if((N_muminus==1)&&(N_anumu==1)&&(N_piplus==1)){
	  evtAct->decflag=16;
	  evtAct->p_nu16[evtAct->n16]=p_nutrack;
	  evtAct->p_par16[evtAct->n16]=p_parent;
	  evtAct->id_par16[evtAct->n16]=PAID;
	  evtAct->id16[evtAct->n16]=ID;
	  evtAct->p_mu16[evtAct->n16]=p_sec_mu;
	  evtAct->x_mu16[evtAct->n16]=x_sec_mu;

	  evtAct->id_sec_pip1_16[evtAct->n16]=id_sec_pip1;

	  //runAct->h_prim_match->Fill(evtAct->p_par16[evtAct->n16].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par16[evtAct->n16].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n16++;
	  G4cout <<"SBSteppingAction: K3 "<<p_parent<<" "<<p_nutrack<<" "<<evtAct->decflag<<G4endl;
	}
	if(N_pi0==3){
	  evtAct->decflag=17;
	  evtAct->p_nu17[evtAct->n17]=p_nutrack;
	  evtAct->p_par17[evtAct->n17]=p_parent;
	  evtAct->id_par17[evtAct->n17]=PAID;
	  evtAct->id17[evtAct->n17]=ID;
	  evtAct->p_mu17[evtAct->n17]=p_sec_mu;
	  evtAct->x_mu17[evtAct->n17]=x_sec_mu;
	  //runAct->h_prim_match->Fill(evtAct->p_par17[evtAct->n17].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par17[evtAct->n17].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n17++;
	}
	if((N_piplus==1)&&(N_piminus==1)&&(N_pi0==1)){
	  evtAct->decflag=18;
	  evtAct->p_nu18[evtAct->n18]=p_nutrack;
	  evtAct->p_par18[evtAct->n18]=p_parent;
	  evtAct->id_par18[evtAct->n18]=PAID;
	  evtAct->id18[evtAct->n18]=ID;
	  evtAct->p_mu18[evtAct->n18]=p_sec_mu;
	  evtAct->x_mu18[evtAct->n18]=x_sec_mu;

	  evtAct->id_sec_pip1_18[evtAct->n18]=id_sec_pip1;
	  evtAct->id_sec_pim1_18[evtAct->n18]=id_sec_pim1;

	  //runAct->h_prim_match->Fill(evtAct->p_par18[evtAct->n18].mag()/CLHEP::GeV,pTOTprim/CLHEP::GeV);
	  parP = evtAct->p_par18[evtAct->n18].mag();
	  runAct->h_prim_match_k0->Fill((parP-pTOTprim)/CLHEP::GeV,parP/pTOTprim);
	  runAct->h_decay_flags->Fill(evtAct->decflag);
	  evtAct->n18++;
	}
      }//k0L

      if((theParticleName=="kaon+")||
	 (theParticleName=="kaon-")||
	 (theParticleName=="kaon0L")){
	evtAct->p_K_3B=track->GetMomentum();
	evtAct->enuLAB_K_3B=p_nutrack.mag();
      }
      
    }//3 BODY

    if((evtAct->decflag==13)||// 3 body K0 with direct neutrinos
       (evtAct->decflag==14)||
       (evtAct->decflag==15)||
       (evtAct->decflag==16)
       ) evtAct->kzero3B=true;
    
    if((evtAct->decflag==7)||// 3 body K+- with direct neutrinos
       (evtAct->decflag==8)||
       (evtAct->decflag==9)||
       (evtAct->decflag==10)
       ) evtAct->kch3B=true;

    if((evtAct->decflag==1)||// 2 body K+- with direct neutrinos
       (evtAct->decflag==2)
       ) evtAct->kch2B=true;

    if((evtAct->decflag==31)||// 2 body pi+- with direct neutrinos
       (evtAct->decflag==30)
       ) evtAct->pich2B=true;

    if(evtAct->pich2B) G4cout << "SBSteppingAction: CLASS. 2 body pi+/- with direct nus " <<G4endl;
    if(evtAct->kch2B) G4cout << "SBSteppingAction: CLASS. 2 body K+/- with direct nus " <<G4endl;
    if(evtAct->kch3B) G4cout << "SBSteppingAction: CLASS. 3 body K+/- with direct nus " <<G4endl;
    if(evtAct->kzero3B) G4cout << "SBSteppingAction: CLASS. 3 body K0L with direct nus " <<G4endl;

    if(evtAct->decflag!=0){
      G4cout << "SBSteppingAction: Decay flag "<< evtAct->decflag << G4endl;
      //runAct->h_decay_flags->Fill(double(evtAct->decflag));
      /*
	runAct->h_decay_flags->Fill(1,double(evtAct->n1));
	runAct->h_decay_flags->Fill(2,double(evtAct->n2));
	runAct->h_decay_flags->Fill(3,double(evtAct->n3));
	runAct->h_decay_flags->Fill(4,double(evtAct->n4));
	runAct->h_decay_flags->Fill(5,double(evtAct->n5));
	runAct->h_decay_flags->Fill(6,double(evtAct->n6));
	runAct->h_decay_flags->Fill(7,double(evtAct->n7));
	runAct->h_decay_flags->Fill(8,double(evtAct->n8));
	runAct->h_decay_flags->Fill(9,double(evtAct->n9));
	runAct->h_decay_flags->Fill(10,double(evtAct->n10));
	runAct->h_decay_flags->Fill(11,double(evtAct->n11));
	runAct->h_decay_flags->Fill(12,double(evtAct->n12));
	runAct->h_decay_flags->Fill(13,double(evtAct->n13));
	runAct->h_decay_flags->Fill(14,double(evtAct->n14));
	runAct->h_decay_flags->Fill(15,double(evtAct->n15));
	runAct->h_decay_flags->Fill(16,double(evtAct->n16));
	runAct->h_decay_flags->Fill(17,double(evtAct->n17));
	runAct->h_decay_flags->Fill(18,double(evtAct->n18));
	runAct->h_decay_flags->Fill(19,double(evtAct->n19));
	runAct->h_decay_flags->Fill(20,double(evtAct->n20));
	runAct->h_decay_flags->Fill(30,double(evtAct->n30));
	runAct->h_decay_flags->Fill(31,double(evtAct->n31));
      */
    }

    //888888888888888888888888888

  } // decay;
  

    /*********************************/
    // necessary ? skip or keep just as debug
    //  
  if(track->GetCreatorProcess() != 0){
    G4String ParticName = track->GetDefinition()->GetParticleName();
    G4String ProcName = track->GetCreatorProcess()->GetProcessName();
    G4ThreeVector imp = track->GetMomentum();
    //G4ThreeVector pos = track->GetPosition();
    pos = track->GetPosition();
    //if(DEB)G4cout << ParticName << " from " << ProcName << " tagged!" << G4endl;
    G4int PARENTID = track->GetParentID(); 
    if(ProcName=="Decay"){
      if((ParticName==IMUPLUS)){
	//G4cout << "MU+ PARENT IDENTITY "<<evtAct->vPDG_ID[PARENTID]<<G4endl;
	if(PARENTID==evtAct->PIPLUS_TRACKID){//pi+ ~> mu+ 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->PIPLUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->p_muplus_PI==-99999.){// only at first step
	    if(ParticName=="mu+"){
	      evtAct->x_DIF_PI_muplus = pos; 
	      evtAct->p_DIF_PI_muplus = imp;
	      
	      //G4cout << "MU+ PARENT IDENTITY "<<parPDG<<" from a "<<parparPDG<<G4endl;
	      G4cout << "MU+ <~ "<<parName<<" <~ "<<parparName<<" <~ "<<parparparName<<G4endl;
	      /*if((parPDG==PDGpiplus)||(parPDG==PDGpiminus)){*/
	      if((kaonGfath)||(kaonGGfath)){
		evtAct->ParLevel_muplus = 2;
		G4cout << "cascade   K+/- => PI => MU+ "<<G4endl;
	      }else if((k0Gfath)||(k0GGfath)){
		evtAct->ParLevel_muplus = 3;
		G4cout << "cascade   K0 => PI => MU+ "<<G4endl;
	      }else{
		evtAct->ParLevel_muplus = 1;
		G4cout << "direct   PI => MU+ "<<G4endl;
	      }
	      /*	      }
			      else if(kaonfath){
			      evtAct->ParLevel_muplus = 4;
			      G4cout << "direct    K => MU+ "<<G4endl;
			      }
	      */

	      //ooooooooooooooooooooo
	      /*
		if(PARENTID==evtAct->PIPLUS_TRACKID){
		evtAct->ParLevel_muplus = evtAct->ParLevel_piplus + 1;
		G4cout << "SBSteppingAction: mu+ from a pi+ tagged. mu+ ParLevel: "<< evtAct->ParLevel_muplus <<G4endl;
		}
	      */
	      //ooooooooooooooooooooo
	    }
	    if(DEB)G4cout <<" FIRST mu+ "<<evtAct->x_DIF_PI_muplus<<" "<<evtAct->p_DIF_PI_muplus<< G4endl;
	    evtAct->p_muplus_PI=evtAct->p_DIF_PI_muplus.mag();
	  }
	}
	if(PARENTID==evtAct->KPLUS_TRACKID){//K+ ~> mu+ 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->KPLUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->p_muplus_K==-99999.){// only at first step
	    if(ParticName=="mu+"){
	      evtAct->x_DIF_K_muplus = pos; 
	      evtAct->p_DIF_K_muplus = imp;
	    }
	    if(DEB)G4cout <<" FIRST mu+ "<<evtAct->x_DIF_K_muplus<<" "<<evtAct->p_DIF_K_muplus<< G4endl;
	    evtAct->p_muplus_K=evtAct->p_DIF_K_muplus.mag();
	  }	  
	}
      }//mu+
      if((ParticName==IMUMINUS)){
	//G4cout << "MU- PARENT IDENTITY "<<evtAct->vPDG_ID[PARENTID]<<G4endl;
	if(PARENTID==evtAct->PIMINUS_TRACKID){//pi- ~> mu- 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->PIMINUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->p_muminus_PI==-99999.){// only at first step
	    if(ParticName=="mu-"){
	      evtAct->x_DIF_PI_muminus = pos; 
	      evtAct->p_DIF_PI_muminus = imp;

	      //G4cout << "MU- PARENT IDENTITY "<<parPDG<<" from a "<<parparPDG<<G4endl;
	      G4cout << "MU- <~ "<<parName<<" <~ "<<parparName<<" <~ "<<parparparName<<G4endl;
	      /*if((parPDG==PDGpiplus)||(parPDG==PDGpiminus)){*/
	      if((kaonGfath)||(kaonGGfath)){
		evtAct->ParLevel_muminus = 2;
		G4cout << "cascade   K+/- => PI => MU- "<<G4endl;
	      }else if((k0Gfath)||(k0GGfath)){
		evtAct->ParLevel_muminus = 3;
		G4cout << "cascade   K0 => PI => MU- "<<G4endl;
	      }else{
		evtAct->ParLevel_muminus = 1;
		G4cout << "direct   PI => MU- "<<G4endl;
	      }
	      /*	      }
			      else if(kaonfath){
			      evtAct->ParLevel_muminus = 4;
			      G4cout << "direct   K => MU- "<<G4endl;
			      }
	      */

	      //ooooooooooooooooooooo  
	      /*
		if(PARENTID==evtAct->PIMINUS_TRACKID){
		evtAct->ParLevel_muminus = evtAct->ParLevel_piminus + 1;
		G4cout << "SBSteppingAction: mu- from a pi- tagged. mu- ParLevel: "<< evtAct->ParLevel_muminus <<G4endl;
		}
	      */
	      //ooooooooooooooooooooo
	    }
	    if(DEB)G4cout <<" FIRST mu- "<<evtAct->x_DIF_PI_muminus<<" "<<evtAct->p_DIF_PI_muminus<< G4endl;
	    evtAct->p_muminus_PI=evtAct->p_DIF_PI_muminus.mag();
	  }
	}
	if(PARENTID==evtAct->KMINUS_TRACKID){//K- ~> mu- 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->KMINUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->p_muminus_K==-99999.){// only at first step
	    if(ParticName=="mu-"){
	      evtAct->x_DIF_K_muminus = pos; 
	      evtAct->p_DIF_K_muminus = imp;
	    }
	    if(DEB)G4cout <<" FIRST mu- "<<evtAct->x_DIF_K_muminus<<" "<<evtAct->p_DIF_K_muminus<< G4endl;
	    evtAct->p_muminus_K=evtAct->p_DIF_K_muminus.mag();
	  }	  
	}
      }//mu-


      if((ParticName==INUMU)){
	if(PARENTID==evtAct->PIPLUS_TRACKID){//pi+ ~> numu 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->PIPLUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->E_numu_PI==-99999.){// only at first step
	    if(ParticName=="nu_mu"){
	      evtAct->x_DIF_PI_numu = pos; 
	      evtAct->p_DIF_PI_numu = imp;
	    }
	    if(DEB)G4cout <<"PION FIRST nu_mu "<<evtAct->x_DIF_PI_numu<<" "<<evtAct->p_DIF_PI_numu<< G4endl;
	    evtAct->E_numu_PI=evtAct->p_DIF_PI_numu.mag();
	  }
	}
	if(PARENTID==evtAct->KPLUS_TRACKID){//K+ ~> numu 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->KPLUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->E_numu_K==-99999.){// only at first step
	    if(ParticName=="nu_mu"){
	      evtAct->x_DIF_K_numu = pos; 
	      evtAct->p_DIF_K_numu = imp;
	    }
	    if(DEB)G4cout <<"KAPPA FIRST nu_mu "<<evtAct->x_DIF_K_numu<<" "<<evtAct->p_DIF_K_numu<< G4endl;
	    evtAct->E_numu_K=evtAct->p_DIF_K_numu.mag();
	  }
	}
      }//numu


      if((ParticName==IANUMU)){
	if(PARENTID==evtAct->PIMINUS_TRACKID){//pi- ~> antinumu 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->PIPLUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;	  
	  if(evtAct->E_anumu_PI==-99999.){// only at first step
	    if(ParticName=="anti_nu_mu"){
	      evtAct->x_DIF_PI_anumu = pos; 
	      evtAct->p_DIF_PI_anumu = imp;
	    }
	    if(DEB)G4cout <<" FIRST anti_nu_mu "<<evtAct->x_DIF_PI_anumu<<" "<<evtAct->p_DIF_PI_anumu<< G4endl;
	    evtAct->E_anumu_PI=evtAct->p_DIF_PI_anumu.mag();
	  }
	}
	if(PARENTID==evtAct->KMINUS_TRACKID){//K- ~> antinumu 
	  if(DEB)G4cout << "       "<<ParticName << " from " << ProcName << " tagged! parent ID "<<PARENTID<<" "<<evtAct->KPLUS_TRACKID<<" "<<imp<<" "<<pos<<G4endl;
	  if(evtAct->E_anumu_K==-99999.){// only at first step
	    if(ParticName=="anti_nu_mu"){
	      evtAct->x_DIF_K_anumu = pos; 
	      evtAct->p_DIF_K_anumu = imp;
	    }
	    if(DEB)G4cout <<" FIRST anti_nu_mu "<<evtAct->x_DIF_K_anumu<<" "<<evtAct->p_DIF_K_anumu<< G4endl;
	    evtAct->E_anumu_K=evtAct->p_DIF_K_anumu.mag();
	  }
	}
      }//antinumu
      
    }//Decay
  }//CreatorProcess

  //if(track->GetParentID()==0 && track->GetUserInformation()==0) {
  //if(theProcessName == "Decay" && theParticleName=="pi+") {
  //if(track->GetKineticEnergy()>0.){
  //TrackInformation* anInfo = new TrackInformation(track);
  //track->SetUserInformation(anInfo);
  //}
  // if(DEB)G4cout << "pi plus decay"<< G4endl;
  //}
  //}
  

  // from gdecay.f modified
  /*
    G4double  mom1, mom, ener;
    G4bool twoBodiesProba = false;
    G4bool Kaon3bodies = false;
    // geant3
    G4int IGAM = 1;
    G4int IPOS = 2;
    G4int IELE = 3;
    G4int INEU = 4;
    G4int IMUPLUS = 5;
    G4int IMINUS = 6;
    G4int IPIPLUS = 8;
    G4int IPIMINUS = 9;
    G4int IKPLUS = 11;
    G4int IKMINUS = 12;
    G4int IK0L = 10;
    // manca MUMINUS nel check ?

    if(ID==1&&(ipart==IPIPLUS||ipart==IPIMINUS||ipart==IKPLUS||ipart==IKMINUS)) {
    mom1 = sqrt(pcm(1,1)**2+pcm(2,1)**2+pcm(3,1)**2);
    cthstar = PCM(3,1)/mom1;
    mom = VECT(7);
    ener = SQRT(mom*mom+AMASS*AMASS);
    betaPar  = mom/ener;
    gammaPar  = ener/AMASS;
    parentMass = AMASS;
    ieventSav = ievent;
    itrackSav = itra;
    twoBodiesProba = true;
    }
    if((ipart==IK0L)&&(ID==IPOS||ID==IELE||ID==INEU||ID==IMUPLUS)){
    mom1 = sqrt(pcm(1,2)**2+pcm(2,2)**2+pcm(3,2)**2);
    cthstar = PCM(3,2)/mom1;
    mom = VECT(7);
    ener = SQRT(mom*mom+AMASS*AMASS);
    betaPar  = mom/ener;
    gammaPar  = ener/AMASS;
    Kaon3bodies = true;
    }
    if((ipart==IKPLUS||ipart==IKMINUS)&&(ID==INEU||ID==IMUPLUS)){
    mom1 = sqrt(pcm(1,1)**2+pcm(2,1)**2+pcm(3,1)**2);
    cthstar = PCM(3,1)/mom1;
    mom = VECT(7);
    ener = SQRT(mom*mom+AMASS*AMASS);
    betaPar  = mom/ener;
    gammaPar  = ener/AMASS;
    Kaon3bodies = true;
    }


    if(twoBodiesProba)proba2(mom,cth);
    if(Kaon3bodies)proba3K(mom,cth);
 
  */

}

/***********************************************/
G4int SBSteppingAction::FLUKA_G4_PID(G4int pid_in=0){
  
  const G4int N = 30;
  G4int i_FLU[N]={0};
  G4int i_G4[N]={0};
  
  i_FLU[0]=13;//piplus
  i_FLU[1]=14;//piminus
  i_FLU[2]=23;//pizero
  i_FLU[3]=4;//eplus
  i_FLU[4]=3;//eminus
  i_FLU[5]=1;//proton
  i_FLU[6]=2;//antiproton
  i_FLU[7]=8;//neutron
  i_FLU[8]=9;//antineutron
  i_FLU[9]=7;//gamma
  i_FLU[10]=15;//kplus
  i_FLU[11]=16;//kminus
  i_FLU[12]=24;//kzero
  i_FLU[13]=25;//antikzero
  i_FLU[14]=17;//lambda
  i_FLU[15]=18;//antilambda
  i_FLU[16]=5;//nue
  i_FLU[17]=6;//antinue
  i_FLU[18]=27;//numu
  i_FLU[19]=28;//antinumu
  i_FLU[20]=43;//nutau
  i_FLU[21]=44;//antinutau
  i_FLU[22]=-6;//alpha
  i_FLU[23]=-5;//he3
  i_FLU[24]=-3;//deu
  i_FLU[25]=-4;//tri
  i_FLU[26]=10;//muplus
  i_FLU[27]=11;//muminus
  i_FLU[28]=21;//sigplus
  i_FLU[29]=20;//sigminus

  i_G4[0]=211;//piplus
  i_G4[1]=-211;//piminus
  i_G4[2]=111;//pizero
  i_G4[3]=-11;//eplus
  i_G4[4]=11;//eminus
  i_G4[5]=2212;//proton
  i_G4[6]=-2212;//antiproton
  i_G4[7]=2112;//neutron
  i_G4[8]=-2112;//antineutron
  i_G4[9]=22;//gamma
  i_G4[10]=321;//kplus
  i_G4[11]=-321;//kminus
  i_G4[12]=311;//kzero
  i_G4[13]=-311;//antikzero
  i_G4[14]=3122;//lambda
  i_G4[15]=-3122;//antilambda
  i_G4[16]=12;//nue
  i_G4[17]=-12;//antinue
  i_G4[18]=14;//numu
  i_G4[19]=-14;//antinumu
  i_G4[20]=16;//nutau
  i_G4[21]=-16;//antinutau
  i_G4[22]=0;//alpha NOT PRESENT
  i_G4[23]=0;//he3 NOT PRESENT
  i_G4[24]=0;//deu NOT PRESENT
  i_G4[25]=0;//tri NOT PRESENT
  i_G4[26]=-13;//muplus
  i_G4[27]=13;//muminus
  i_G4[28]=3222;//sigplus
  i_G4[29]=3112;//sigminus
 
  G4int pid_out=0; 

  for (G4int i=0;i<N;i++){
    if(i_G4[i]==pid_in) pid_out = i_FLU[i];
  }

  return pid_out;
}
#include "SBSteppingVerbose.hh"
#include "G4SteppingManager.hh"
#include "G4UnitsTable.hh"

SBSteppingVerbose::SBSteppingVerbose()
{}


SBSteppingVerbose::~SBSteppingVerbose()
{}

void SBSteppingVerbose::StepInfo()
{
  CopyState();
  
  G4int prec = G4cout.precision(3);

  if( verboseLevel >= 1 ){
    if( verboseLevel >= 4 ) VerboseTrack();
    if( verboseLevel >= 3 ){
      G4cout << G4endl;    
      G4cout << std::setw( 5) << "#Step#"     << " "
	     << std::setw( 6) << "X"          << "    "
	     << std::setw( 6) << "Y"          << "    "  
	     << std::setw( 6) << "Z"          << "    "
	     << std::setw( 9) << "KineE"      << " "
	     << std::setw( 9) << "dEStep"     << " "  
	     << std::setw(10) << "StepLeng"     
	     << std::setw(10) << "TrakLeng" 
	     << std::setw(10) << "Volume"    << "  "
	     << std::setw(10) << "Process"   << G4endl;	          
    }

    G4cout << std::setw(5) << fTrack->GetCurrentStepNumber() << " "
    << std::setw(6) << G4BestUnit(fTrack->GetPosition().x(),"Length")
    << std::setw(6) << G4BestUnit(fTrack->GetPosition().y(),"Length")
    << std::setw(6) << G4BestUnit(fTrack->GetPosition().z(),"Length")
    << std::setw(6) << G4BestUnit(fTrack->GetKineticEnergy(),"Energy")
    << std::setw(6) << G4BestUnit(fStep->GetTotalEnergyDeposit(),"Energy")
    << std::setw(6) << G4BestUnit(fStep->GetStepLength(),"Length")
    << std::setw(6) << G4BestUnit(fTrack->GetTrackLength(),"Length")
    << "  ";

    // if( fStepStatus != fWorldBoundary){ 
    if( fTrack->GetNextVolume() != 0 ) { 
      G4cout << std::setw(10) << fTrack->GetVolume()->GetName();
    } else {
      G4cout << std::setw(10) << "OutOfWorld";
    }

    if(fStep->GetPostStepPoint()->GetProcessDefinedStep() != 0){
      G4cout << "  "
             << std::setw(10)
	     << fStep->GetPostStepPoint()->GetProcessDefinedStep()
	                                 ->GetProcessName();
    } else {
      G4cout << "   UserLimit";
    }

    G4cout << G4endl;

    if( verboseLevel == 2 ){
      G4int tN2ndariesTot = fN2ndariesAtRestDoIt +
	                    fN2ndariesAlongStepDoIt +
	                    fN2ndariesPostStepDoIt;
      if(tN2ndariesTot>0){
	G4cout << "    :----- List of 2ndaries - "
	       << "#SpawnInStep=" << std::setw(3) << tN2ndariesTot 
	       << "(Rest="  << std::setw(2) << fN2ndariesAtRestDoIt
	       << ",Along=" << std::setw(2) << fN2ndariesAlongStepDoIt
	       << ",Post="  << std::setw(2) << fN2ndariesPostStepDoIt
	       << "), "
	       << "#SpawnTotal=" << std::setw(3) << (*fSecondary).size()
	       << " ---------------"
	       << G4endl;

	for(size_t lp1=(*fSecondary).size()-tN2ndariesTot; 
                        lp1<(*fSecondary).size(); lp1++){
	  G4cout << "    : "
		 << std::setw(6)
		 << G4BestUnit((*fSecondary)[lp1]->GetPosition().x(),"Length")
		 << std::setw(6)
		 << G4BestUnit((*fSecondary)[lp1]->GetPosition().y(),"Length")
		 << std::setw(6)
		 << G4BestUnit((*fSecondary)[lp1]->GetPosition().z(),"Length")
		 << std::setw(6)
		 << G4BestUnit((*fSecondary)[lp1]->GetKineticEnergy(),"Energy")
		 << std::setw(10)
		 << (*fSecondary)[lp1]->GetDefinition()->GetParticleName();
	  G4cout << G4endl;
	}
              
	G4cout << "    :-----------------------------"
	       << "----------------------------------"
	       << "-- EndOf2ndaries Info ---------------"
	       << G4endl;
      }
    }
    
  }
  G4cout.precision(prec);
}


void SBSteppingVerbose::TrackingStarted()
{

  CopyState();
G4int prec = G4cout.precision(3);
  if( verboseLevel > 0 ){

    G4cout << std::setw( 5) << "Step#"      << " "
           << std::setw( 6) << "X"          << "    "
	   << std::setw( 6) << "Y"          << "    "  
	   << std::setw( 6) << "Z"          << "    "
	   << std::setw( 9) << "KineE"      << " "
	   << std::setw( 9) << "dEStep"     << " "  
	   << std::setw(10) << "StepLeng"  
	   << std::setw(10) << "TrakLeng"
	   << std::setw(10) << "Volume"     << "  "
	   << std::setw(10) << "Process"    << G4endl;	     

   G4cout << std::setw( 5) << fTrack->GetCurrentStepNumber() << " "
    << std::setw( 6) << G4BestUnit(fTrack->GetPosition().x(),"Length")
    << std::setw( 6) << G4BestUnit(fTrack->GetPosition().y(),"Length")
    << std::setw( 6) << G4BestUnit(fTrack->GetPosition().z(),"Length")
    << std::setw( 6) << G4BestUnit(fTrack->GetKineticEnergy(),"Energy")
    << std::setw( 6) << G4BestUnit(fStep->GetTotalEnergyDeposit(),"Energy")
    << std::setw( 6) << G4BestUnit(fStep->GetStepLength(),"Length")
    << std::setw( 6) << G4BestUnit(fTrack->GetTrackLength(),"Length")
    << "  ";

    if(fTrack->GetNextVolume()){
      G4cout << std::setw(10) << fTrack->GetVolume()->GetName();
    } else {
      G4cout << "OutOfWorld";
    }
    G4cout << "    initStep" << G4endl;
  }
  G4cout.precision(prec);
}
#include "SBTrajectory.hh"
#include "G4TrajectoryPoint.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleTypes.hh"
#include "G4ThreeVector.hh"
#include "G4Polyline.hh"
#include "G4Circle.hh"
#include "G4Colour.hh"
#include "G4VisAttributes.hh"
#include "G4VVisManager.hh"

G4Allocator<SBTrajectory> myTrajectoryAllocator;

SBTrajectory::SBTrajectory()
{
   fpParticleDefinition = 0;
   ParticleName = "";
   PDGCharge = 0;
   PDGEncoding = 0;
   fTrackID = 0;
   fParentID = 0;
   positionRecord = 0;
}

SBTrajectory::SBTrajectory(const G4Track* aTrack)
{
   fpParticleDefinition = aTrack->GetDefinition();
   ParticleName = fpParticleDefinition->GetParticleName();
   PDGCharge = fpParticleDefinition->GetPDGCharge();
   PDGEncoding = fpParticleDefinition->GetPDGEncoding();
   fTrackID = aTrack->GetTrackID();
   fParentID = aTrack->GetParentID();
   positionRecord = new SBTrajectoryPointContainer();
   positionRecord->push_back(new G4TrajectoryPoint(aTrack->GetPosition()));
}

SBTrajectory::SBTrajectory(SBTrajectory & right)
    : G4VTrajectory()
{
  ParticleName = right.ParticleName;
  fpParticleDefinition = right.fpParticleDefinition;
  PDGCharge = right.PDGCharge;
  PDGEncoding = right.PDGEncoding;
  fTrackID = right.fTrackID;
  fParentID = right.fParentID;
  positionRecord = new SBTrajectoryPointContainer();
  for(int i=0;i<(int)right.positionRecord->size();i++)
  {
    G4TrajectoryPoint* rightPoint = (G4TrajectoryPoint*)((*(right.positionRecord))[i]);
    positionRecord->push_back(new G4TrajectoryPoint(*rightPoint));
  }
}

SBTrajectory::~SBTrajectory()
{
  size_t i;
  for(i=0;i<positionRecord->size();i++){
    delete  (*positionRecord)[i];
  }
  positionRecord->clear();

  delete positionRecord;
}

void SBTrajectory::ShowTrajectory() const
{
   G4cout << G4endl << "TrackID =" << fTrackID
        << ":ParentID=" << fParentID << G4endl;
   G4cout << "Particle name : " << ParticleName
        << "  Charge : " << PDGCharge << G4endl;
   G4cout << "  Current trajectory has " << positionRecord->size()
        << " points." << G4endl;

   for( size_t i=0 ; i < positionRecord->size() ; i++){
       G4TrajectoryPoint* aTrajectoryPoint = (G4TrajectoryPoint*)((*positionRecord)[i]);
       G4cout << "Point[" << i << "]"
            << " Position= " << aTrajectoryPoint->GetPosition() << G4endl;
   }
}

void SBTrajectory::ShowTrajectory(std::ostream& o) const
{
    G4VTrajectory::ShowTrajectory(o);
}


void SBTrajectory::DrawTrajectory(/*G4int i_mode*/) const
{

   G4VVisManager* pVVisManager = G4VVisManager::GetConcreteInstance();
   G4ThreeVector pos;

   G4Polyline pPolyline;
   for (int i = 0; i < (int)positionRecord->size() ; i++) {
     G4TrajectoryPoint* aTrajectoryPoint = (G4TrajectoryPoint*)((*positionRecord)[i]);
     pos = aTrajectoryPoint->GetPosition();
     pPolyline.push_back( pos );
   }

   G4Colour colour(0.75,0.75,0.75);    // LightGray
   if(fpParticleDefinition==G4Gamma::GammaDefinition())
      colour = G4Colour(0.,1.,1.);     // Cyan
   else if(fpParticleDefinition==G4Electron::ElectronDefinition()
         ||fpParticleDefinition==G4Positron::PositronDefinition())
      colour = G4Colour(1.,1.,0.);      // Yellow
   else if(fpParticleDefinition==G4MuonMinus::MuonMinusDefinition()
         ||fpParticleDefinition==G4MuonPlus::MuonPlusDefinition())
      colour = G4Colour(1.,0.,1.);      // Magenta
   else if(fpParticleDefinition->GetParticleType()=="meson")
   {
      if(PDGCharge!=0.)
         colour = G4Colour(1.,0.,0.);   // Red
      else
         colour = G4Colour(0.5,0.,0.);  // HalfRed
   }
   else if(fpParticleDefinition->GetParticleType()=="baryon")
   {
      if(PDGCharge!=0.)
         colour = G4Colour(1.,0.78,0.); // Orange
      else
         colour = G4Colour(0.5,0.39,0.);// HalfOrange
   }

   G4VisAttributes attribs(colour);
   pPolyline.SetVisAttributes(attribs);
   if(pVVisManager) pVVisManager->Draw(pPolyline);
}

void SBTrajectory::AppendStep(const G4Step* aStep)
{
   positionRecord->push_back( new G4TrajectoryPoint(aStep->GetPostStepPoint()->
                                 GetPosition() ));
}

G4ParticleDefinition* SBTrajectory::GetParticleDefinition()
{
   return (G4ParticleTable::GetParticleTable()->FindParticle(ParticleName));
}

void SBTrajectory::MergeTrajectory(G4VTrajectory* secondTrajectory)
{
  if(!secondTrajectory) return;

  SBTrajectory* seco = (SBTrajectory*)secondTrajectory;
  G4int ent = seco->GetPointEntries();
  for(int i=1;i<ent;i++) // initial point of the second trajectory should not be merged
  {
    positionRecord->push_back((*(seco->positionRecord))[i]);
  }
  delete (*seco->positionRecord)[0];
  seco->positionRecord->clear();

}


